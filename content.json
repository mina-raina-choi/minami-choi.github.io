{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"About","text":"최민아Frontend Engineer / React / Angular이메일: cmina2846@gmail.com블로그: https://mingcoder.me 저는 이왕 하는 거 제대로 해보자라는 삶의 태도를 가진 최민아입니다.현업에서 일한 지 3년차, 블록체인 스타트업에서 웹 지갑과 블록익스 플로러를 성공적으로 런칭하며 실무 경험을 쌓아왔습니다.저는 시키는대로 코딩하는 개발자가 아니라 어떻게 하면 좀 더 괜찮은 서비스,좀 더 좋은 구조의 프로젝트를 만들 수 있을까를 능동적으로 고민하며 개발합니다. 또한 서버개발자와의 커뮤니케이션을 통해 원하는 바를 빠르게 구현하고 업그레이드를 시키는 작업을 하며 성취감을 느낍니다. 개인 프로젝트의 경우 서버쪽 api도 직접 구현하는 등 개발에 대한 호기심과 열정이 많고 앞으로 더 나은 IT전문가가 되기 위해 노력하고있습니다.그리고 2 년 전부터 현업에서 배운 기술과 마주친 이슈에 대해서 정리하는 개인 기술 블로그도 운영하고 있습니다. https://www.mintscan.io/https://wallet.wannabit.io/access?curr=btc&amp;lang=ko","link":"/about/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"}],"posts":[{"title":"이직 준비 시이작~!","text":"퇴사를 결정하고 이직 준비를 시작했다.남은 시간들 동안 마무리해야할 일들을 잘 마무리하고, 이직을 위한 공부를 시작해야겠뜨아~!","link":"/2019/11/23/Essay/이직일기/"},{"title":"2020년 새로운 도전, 글또 4기","text":"개인 정리용으로 드문드문 정리하던 블로그를 좀 더 본격적으로 잘 운영해 봐야겠다고 생각하게 된 건 마이크로 소프트 이소영 이사님의 홀로 성장하는 시대는 끝났다를 접하고 나서부터였다. 이전까지 개발 블로그는 업계에서 내로라하는 실력자들만이 제대로 운영을 할 수 있고 그런 사람들이 개발 커뮤니티를 이끌어간다고 생각을 했었는데 그 책을 읽고 나서 나도 커뮤니티의 일원이 될 수 있겠구나, 그 안에서 함께 성장할 수 있겠구나! 희망을 봤다. 어떤 커뮤니티에서 활동을 할 수 있을까 고민하던 중 글또 4기를 모집한다는 글을 보게 되었고 정말 운 좋게 글또 4기가 되었다! 늘 페이스북 페이지에서 커뮤니티 눈팅만 하며 좋아요만 누르는 입장이었는데 처음으로 개발자 커뮤니티에서 활동하게 되어 굉장히 설렌다. 주로 올리게 될 포스팅은 이렇게 될 것 같다. 코딩테스트 문제 풀이 자바스크립트 기본 개념 정리(https://tylermcginnis.com/ 의 글을 주로 보는데, 이 글들을 번역하고 싶다.) 현재 퇴사를 하고 이직 준비 중인데 그 과정에서 겪는 심경의 변화들도 기록으로 남기고 싶다. 그렇다면 나는 대체 왜 글을 쓰고 싶은가 생각을 해봤다. 그냥 글을 잘 쓰고 싶다…!글을 안 써 버릇하니까 내가 전하고 싶은 의도를 글로 정리하는 게 점점 어려워지고 자꾸 피하게 되더라. 내 생각을 글로 남겨 본 적이 언제였던가 기억조차 안 나는 것 같다. 공개적인 장소에 내 생각을 솔직하게 쓰는 게 조금 두려운 것 같다. 내가 쓴 글을 보고 나를 판단하게 될 다른 사람들의 시선이 두려운 것일 수도 있겠다. 나의 깊이가 부족한 것이 고대로 드러나면 어쩌지 하는 염려도 있는 것 같다. 이런 두려움이 더 쌓이기 전에 일단 글쓰기를 시작해야겠다는 생각을 했다. 쓰다 보면, 피드백을 받으며 수정을 하다 보면 글 쓰는 능력도 개발되리라 믿는다. 학습 효율 UP!아래 그림은 공부를 한 다음 24시간 이후에 남아있는 비율을 나타낸 학습 효율 피라미드이다. 수동적으로 강의를 듣거나 읽기만 했을 때는 24시간 후에 5~10%만 기억에 남지만 실제로 해보거나 서로 설명하기 등 능동적으로 학습했을 때는 효율이 75~90%까지 올라가는 걸 볼 수가 있다. 이거는 실제로 나도 느꼈던 부분이었다. 강의를 보면서 학습을 할 때는 다 이해한 것 같다가도 시간이 좀 지나고 되새겨보면 아, 그게 뭐였지? 기억조차 가물가물할 때가 많다. 서로 배운 것을 말로 설명할 수 있는 환경이 있다면 좋겠지만 나 혼자서 가장 능동적으로 학습할 수 있는 방법은 바로 글로 정리하는 것이 아닐까 생각된다. 배운 내용을 글로 정리하면서 배웠던 것을 다시 되새기고 정확히 이해가 안 되는 부분에 대해서 다시 한번 고민하게 되니 능동적으로 학습할 수밖에 없는 것 같다. 나날이 새로운 기술이 나오는 요즘, 가끔은 그 속도가 버겁게 느껴질 때가 있다. 모든 새로운 기술을 탐내기보다는 기본에 충실하고 내가 지금 사용하고 있는 기술에 대해 깊게 이해하는 게 더 중요하다고 생각한다. 잘 정리해서 온전히 내 것으로 만들자. (코로나가 잠잠해지면 글또 오프라인 모임도 활성화되어 서로 기술 토론하는 기회도 생겼으면 좋겠다. ) 회고하자그동안은 꾸준히 글을 포스팅하지 않고 열정이 불타오를 때🔥🔥 아주 가끔 글을 올리다 보니 블로그를 통해 회고하긴 어려웠다. 하지만 이번엔 다르다! 글또 4기를 통해서 적어도 6개월간은 꾸준히 글을 포스팅할 거고 글 쓰는 습관을 들이게 되면 그 후로도 꾸준히 글을 쓰게 될 거다. 블로그를 보면 내가 지난 1년을 어떻게 보냈는지 알 수 있겠지. 회고를 통해 반성도 하고 새로운 방향 설정도 할 수 있으리라 기대한다. 끝으로 요즘 근황에 대한 얘기를 하자면 어느덧 퇴사한 지 1달이 다 되어간다. 시간이 정~말 빠르다😳😳😳😳😳 (지난주에 박새로이를 본 게 엊그제 같은데 벌써 또 이태원 클라쓰 하는 날이다!!!! 새로이를 보는 건 좋은데😍 시간이 너어~~~무 빨리 가는 것은 좀 무섭다😒 ) 지난 4주 동안 주로 한 일은 코딩 테스트를 위한 알고리즘 문제를 꾸준히 풀었고 자바스크립트 기본 개념에 대한 공부를 다시 하는 중이다. 그리고 1차적으로 이력서를 정리했고 어떤 한 회사의 채용에 지원했는데 서류부터 탈락했다. 조금 충격이었다. 서류에서는 무난하고 통과하고 코테를 잘 봐서 꼭 면접까지 가야지! 마음을 가다듬고 있었는데 서류부터 광탈…ㅠ.ㅠ 이력서에 좀 이상한 부분은 없는지 다시 체크하고 있다. 불안감이 엄습…하지만 그냥 하던 대로 준비를 잘해야겠다.","link":"/2020/02/29/Essay/geultto-start/"},{"title":"[LeetCode] LinkedList - Add two numbers","text":"문제2개의 양의 정수를 나타내는 링크드리스트가 주어진다. 각각 일의 자리부터 역순으로 숫자 하나씩 저장되어 있다. 두 숫자를 더한 후 링크드리스트로 리턴하시오. 0을 제외하고는 [0, 0, 0] 이런 식의 숫자는 없는 것으로 가정한다. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807.출처 - https://leetcode.com/problems/add-two-numbers/ 풀이 과정숫자를 더할 때 1의 자리부터 더해서 10이 넘어가는 값은 다음 자릿수 더할 때 올려주는 식으로 계산을 하니까 문제에서 주어진 리버스 링크드리스트 그대로 사용하면 된다. l1, l2 둘 중에 하나라도 값이 있다면 계속 while 문을 돈다. 일의 자리부터 더하는데, 9를 넘어가는 값은 올림값으로 prevNum에 담아두고, 일의 자리값만 answerNode에 추가한다.링크드 리스트를 더할 때, 이전 계산값에서 올려보낸 값이 있을 수도 있으니 항상 prevNum을 같이 더한다. 그리고 while 문을 다 돌고도 prevNum 값이 존재할 수도 있다.값이 존재하면 링크드리스트에 값을 추가한다. 나의 풀이/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function(l1, l2) { let node1 = l1 let node2 = l2 let answerNode = null // 올림한 값 let prevNum = 0 while (node1 || node2) { // 링크드 리스트의 크기가 같지 않을 수도 있다. val가 없다면 0으로 셋팅 const sum = (node1 ? node1.val : 0) + (node2 ? node2.val : 0) const temp = sum + prevNum prevNum = 0 // 일의 자리만 const num = temp % 10 if (answerNode) { addNode(answerNode, new ListNode(num)) } else { answerNode = new ListNode(num) } //num + prevNum도 10넘는지 체크 if (temp &gt; 9) { prevNum = Math.floor(temp / 10) } node1 = node1 ? node1.next : null node2 = node2 ? node2.next : null } if (prevNum) { addNode(answerNode, new ListNode(prevNum)) } return answerNode}const addNode = (node, data) =&gt; { if (node) { while (node.next) { node = node.next } node.next = data }}","link":"/2019/12/11/Programming/Algorithm/add-two-numbers/"},{"title":"[백준] 9663 N-Queen, 15649 N과 M(1), 15649 N과 M(4)","text":"N-QueenN-Queen 문제는 크기가 N × N인 체스판 위에 퀸 N개를 서로 공격할 수 없게 놓는 문제이다. N이 주어졌을 때, 퀸을 놓는 방법의 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 N이 주어진다. (1 ≤ N &lt; 15) 출력첫째 줄에 퀸 N개를 서로 공격할 수 없게 놓는 경우의 수를 출력한다.https://www.acmicpc.net/problem/9663 체스에서 퀸은 상하좌우, 대각선 어느 방향으로도 이동이 가능하다.n개의 퀸들이 서로 공격을 할 수 없게 놓기 위해서는 한 줄씩 일일이 각 행마다 넣어보면서 검증을 해야한다. function solution(params) { const n = parseInt(params) let count = 0 // array[i] 는 i열에 퀸을 놓은 행의 index const array = new Array(n).fill(0) dfs(0) console.log(count) function dfs(x) { // 퀸을 n개까지 다 놓았다면 count를 한다. if (x == n) { console.log(array.join(\" \")) count++ } else { // 각 행에다 퀸을 놓아본다. for (let i = 0; i &lt; n; i++) { array[x] = i // 만약 x위치에 퀸을 놓을 수 있다면 다음 열로 넘어간다. if (check(x)) { dfs(x + 1) } } } } // x 위치에 퀸을 놓을 수 있는지 없는지 확인 function check(x) { // x 이전의 열들을 모두 검사 for (let i = 0; i &lt; x; i++) { // 같은 행 X if (array[x] == array[i]) { return false } // 대각선 X if (Math.abs(array[x] - array[i]) == x - i) { return false } } return true }} N과 M (1)자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 중복 없이 M개를 고른 수열 입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8) 출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다.https://www.acmicpc.net/problem/15649 이 문제는 순열을 구하면 되는 문제다.숫자는 중복없이 골라야하므로 i번째 숫자를 골랐는지 여부를 visited[i] 저장해뒀다가 false일 때만 수열에 추가할 수 있도록 했다. function solution(params) { const input = params.split(\" \").map(a =&gt; +a) const n = input[0], m = input[1] const array = [] for (let i = 1; i &lt;= n; i++) { array.push(i) } // console.log(array) const answer = [] const visited = new Array(n).fill(false) permutation(0) //순서가 다르면 다른 값 -&gt; 순열 function permutation() { // answer.push(array[curr]) if (answer.length == m) { console.log(answer.join(\" \")) return } // 숫자 중복 선택은 제외 for (let i = 0; i &lt; n; i++) { if (!visited[i]) { answer.push(array[i]) visited[i] = true permutation() visited[i] = false answer.pop() // console.log(\"answer\", answer) // console.log(\"visited\", visited) } } }}// solution(`4 2`)solution(`3 3`) N과 M (4)자연수 N과 M이 주어졌을 때, 아래 조건을 만족하는 길이가 M인 수열을 모두 구하는 프로그램을 작성하시오. 1부터 N까지 자연수 중에서 M개를 고른 수열같은 수를 여러 번 골라도 된다.고른 수열은 비내림차순이어야 한다.길이가 K인 수열 A가 A1 ≤ A2 ≤ … ≤ AK-1 ≤ AK를 만족하면, 비내림차순이라고 한다. 입력첫째 줄에 자연수 N과 M이 주어진다. (1 ≤ M ≤ N ≤ 8) 출력한 줄에 하나씩 문제의 조건을 만족하는 수열을 출력한다. 중복되는 수열을 여러 번 출력하면 안되며, 각 수열은 공백으로 구분해서 출력해야 한다. 수열은 사전 순으로 증가하는 순서로 출력해야 한다. https://www.acmicpc.net/problem/15652 위의 15649 N과 M(1)문제와 비슷한 문제이다. 다른 부분이 있다면 숫자선택에서 중복을 허용하고, 수열이 오름차순이어야 한다는 점이다. function solution(params) { const input = params.split(\" \").map(a =&gt; +a) const n = input[0], m = input[1] const array = [] for (let i = 1; i &lt;= n; i++) { array.push(i) } // console.log(array) const answer = [] permutation(0) //오름차순 체크 function check(array) { let isUp = true for (let i = 0; i &lt; array.length - 1; i++) { if (array[i] &gt; array[i + 1]) { isUp = false break } } return isUp } //순서가 다르면 다른 값 -&gt; 순열 function permutation() { if (answer.length == m) { // 오름차순이어야함 if (check(answer)) console.log(answer.join(\" \")) return } for (let i = 0; i &lt; n; i++) { answer.push(array[i]) permutation() answer.pop() } }}solution(`4 2`)solution(`3 3`)// solution(`5 3`) 참고 // 조합 만드는 방법function combi(start) { // 재귀에서는 탈출구문을 먼저 if (answer.length == m) { console.log(answer.join(\" \")) return } for (let i = start; i &lt; n; i++) { answer.push(array[i]) // 똑같아도 되면 i, 중복선택안되면 i+1 combi(i + 1) answer.pop() }}","link":"/2020/02/26/Programming/Algorithm/backtracking-ps/"},{"title":"[백준] 1654 랜선 자르기","text":"랜선 자르기집에서 시간을 보내던 오영식은 박성원의 부름을 받고 급히 달려왔다. 박성원이 캠프 때 쓸 N개의 랜선을 만들어야 하는데 너무 바빠서 영식이에게 도움을 청했다. 이미 오영식은 자체적으로 K개의 랜선을 가지고 있다. 그러나 K개의 랜선은 길이가 제각각이다. 박성원은 랜선을 모두 N개의 같은 길이의 랜선으로 만들고 싶었기 때문에 K개의 랜선을 잘라서 만들어야 한다. 예를 들어 300cm 짜리 랜선에서 140cm 짜리 랜선을 두 개 잘라내면 20cm 은 버려야 한다. (이미 자른 랜선은 붙일 수 없다.) 편의를 위해 랜선을 자르거나 만들 때 손실되는 길이는 없다고 가정하며, 기존의 K개의 랜선으로 N개의 랜선을 만들 수 없는 경우는 없다고 가정하자. 그리고 자를 때는 항상 센티미터 단위로 정수길이만큼 자른다고 가정하자. N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다. 이때 만들 수 있는 최대 랜선의 길이를 구하는 프로그램을 작성하시오. 입력첫째 줄에는 오영식이 이미 가지고 있는 랜선의 개수 K, 그리고 필요한 랜선의 개수 N이 입력된다. K는 1이상 10,000이하의 정수이고, N은 1이상 1,000,000이하의 정수이다. 그리고 항상 K ≦ N 이다. 그 후 K줄에 걸쳐 이미 가지고 있는 각 랜선의 길이가 센티미터 단위의 정수로 입력된다. 랜선의 길이는 231-1보다 작거나 같은 자연수이다. 출력첫째 줄에 N개를 만들 수 있는 랜선의 최대 길이를 센티미터 단위의 정수로 출력한다. https://www.acmicpc.net/problem/1654 전형적인 이분탐색 문제이다.이분 탐색이란 탐색 범위를 두 부분으로 분할해서 찾는 방식으로, max, min, mid 값을 잡아서 탐색한다. 주의할 점은 이분 탐색을 하려면 배열이 이미 정렬되어 있어야 한다는 점이다! 탐색할 배열 정렬한다. max, min값의 중간값으로 mid를 구한다. mid값과 구하고자하는 value를 비교한다. mid &lt; value이면 min = mid + 1, mid &gt; value이면 max = mid - 1로 값을 셋팅한다. min &lt;= max일 때 위 2~4번 과정을 반복한다. function solution(params) { const input = params.split(\"\\n\") const [n, k] = input .shift() .split(\" \") .map(a =&gt; +a) const lines = input.map(a =&gt; +a).sort() const sum = lines.reduce((a, b) =&gt; a + b, 0) let min = 1, // 합을 k개로 나눈 값을 최초의 최대값으로 max = parseInt(sum / k), mid = 0, result = 0 while (min &lt;= max) { mid = parseInt((max + min) / 2) let isPossible = splitable(mid) if (isPossible) { // mid를 더 크게해줘야함 min = mid + 1 // 이전까지의 최대랜선길이 보다 더 긴 mid가 나타나면 result에 저장 if (result &lt; mid) result = mid } else { max = mid - 1 } } console.log(result) // mid 길이로 쪼갤 수 있는 랜선의 갯수가 k보다 크거나 같은지 체크 function splitable(mid) { let count = 0 lines.forEach(a =&gt; { count += parseInt(a / mid) }) // N개보다 많이 만드는 것도 N개를 만드는 것에 포함된다 return count &gt;= k }}","link":"/2020/02/17/Programming/Algorithm/baekjoon-1654/"},{"title":"[백준] 1182 부분 수열의 합 - 자바스크립트","text":"문제N개의 정수로 이루어진 수열이 있을 때, 크기가 양수인 부분수열 중에서 그 수열의 원소를 다 더한 값이 S가 되는 경우의 수를 구하는 프로그램을 작성하시오. 입력첫째 줄에 정수의 개수를 나타내는 N과 정수 S가 주어진다. (1 ≤ N ≤ 20, |S| ≤ 1,000,000) 둘째 줄에 N개의 정수가 빈 칸을 사이에 두고 주어진다. 주어지는 정수의 절댓값은 100,000을 넘지 않는다. 출력첫째 줄에 합이 S가 되는 부분수열의 개수를 출력한다. https://www.acmicpc.net/problem/1182 일반적인 subsequence문제이다.주의해야하는 부분은 연속된 부분수열이 아니어도 된다는 것! function solution(params) { const input = params.split(\"\\n\") const conditions = input[0].split(\" \").map(a =&gt; +a) const n = conditions[0] const s = conditions[1] const array = input[1].split(\" \").map(a =&gt; +a) // 인덱스 i 까지 배열에서 가질 수 잇는 모든 부분 수열의 합을 배열에 저장한다. const dp = new Array(n).fill(null).map((a, i) =&gt; [array[i]]) for (let i = 1; i &lt; n; i++) { for (let j = 0; j &lt; i; j++) { for (let k = 0; k &lt; dp[j].length; k++) { dp[i].push(dp[i][0] + dp[j][k]) } } } // dp를 돌면서 부분수열의 합이 s와 같은 경우 answer++를 해준다. let answer = 0 dp.forEach(a =&gt; a.forEach(a =&gt; { if (a == s) answer++ }) ) console.log(answer)}solution(`5 0-7 -3 -2 5 8`)","link":"/2020/02/08/Programming/Algorithm/baekjoon-1182/"},{"title":"[백준] 1874 스택 수열 - 자바스크립트","text":"https://www.acmicpc.net/problem/1874 문제스택 (stack)은 기본적인 자료구조 중 하나로, 컴퓨터 프로그램을 작성할 때 자주 이용되는 개념이다. 스택은 자료를 넣는 (push) 입구와 자료를 뽑는 (pop) 입구가 같아 제일 나중에 들어간 자료가 제일 먼저 나오는 (LIFO, Last in First out) 특성을 가지고 있다. 1부터 n까지의 수를 스택에 넣었다가 뽑아 늘어놓음으로써, 하나의 수열을 만들 수 있다. 이때, 스택에 push하는 순서는 반드시 오름차순을 지키도록 한다고 하자. 임의의 수열이 주어졌을 때 스택을 이용해 그 수열을 만들 수 있는지 없는지, 있다면 어떤 순서로 push와 pop 연산을 수행해야 하는지를 알아낼 수 있다. 이를 계산하는 프로그램을 작성하라. 입력첫 줄에 n (1 ≤ n ≤ 100,000)이 주어진다. 둘째 줄부터 n개의 줄에는 수열을 이루는 1이상 n이하의 정수가 하나씩 순서대로 주어진다. 물론 같은 정수가 두 번 나오는 일은 없다. 출력입력된 수열을 만들기 위해 필요한 연산을 한 줄에 한 개씩 출력한다. push연산은 +로, pop 연산은 -로 표현하도록 한다. 불가능한 경우 NO를 출력한다. function solution(inputString) { const input = inputString.split(\"\\n\").map(a =&gt; +a) let n = input[0] const pairs = input.slice(1) // 1부터 순서대로 담을 배열 const stack = [] // +, - 담을 배열 const answer = [] let index = 1 while (n) { // 스택의 맨 위의 값과 출력해야하는 첫번째 값이 같을 경우 pop if (stack[stack.length - 1] === pairs[0]) { pairs.shift() stack.pop() answer.push(\"-\") } else { answer.push(\"+\") // 1부터 stack에 쌓아준다 stack.push(index) index++ n-- } } let isAvailable = true for (let i = 0; i &lt; stack.length; i++) { if (stack[i] == pairs.pop()) answer.push(\"-\") else { isAvailable = false break } } isAvailable ? answer.forEach(a =&gt; console.log(a)) : console.log(\"NO\")}solution(`843687521`) 로직은 맞는 것 같은데 실패라고 하지 위의 로직을 조금 수정해서 제출하니 이번에는 시간초과라고 뜬다.똑같은 로직을 자바로 제출하면 통과된다. function solution(inputString) { const input = inputString.split(\"\\n\").map(a =&gt; +a) let n = input[0] const pairs = input.slice(1) // 1부터 순서대로 담을 배열 const stack = [] // +, - 담을 배열 const answer = [] for (let i = 1; i &lt;= n; i++) { answer.push(\"+\") // 1부터 stack에 쌓아준다 stack.push(i) while (stack.length &gt; 0 &amp;&amp; stack[stack.length - 1] === pairs[0]) { pairs.shift() stack.pop() answer.push(\"-\") } } stack.length == 0 ? answer.forEach(a =&gt; console.log(a)) : console.log(\"NO\")}","link":"/2020/02/08/Programming/Algorithm/baekjoon-1874/"},{"title":"[백준] 백트래킹 핵심 유형 문제풀이","text":"백트래킹 문제란, 가능한 경우를 전부 탐색하면서 더이상 나아갈 수 없는 경우를 만났을때, 다시 다른 경우를 탐색하는 문제 유형이다.보통 dfs/bfs와 같은 맥락인데,주로 백트래킹은 dfs로 푸는게 풀이가 간단한 경우가 많다. 1987 문제문제세로 R칸, 가로 C칸으로 된 표 모양의 보드가 있다. 보드의 각 칸에는 대문자 알파벳이 하나씩 적혀 있고, 좌측 상단 칸 (1행 1열) 에는 말이 놓여 있다. 말은 상하좌우로 인접한 네 칸 중의 한 칸으로 이동할 수 있는데, 새로 이동한 칸에 적혀 있는 알파벳은 지금까지 지나온 모든 칸에 적혀 있는 알파벳과는 달라야 한다. 즉, 같은 알파벳이 적힌 칸을 두 번 지날 수 없다. 좌측 상단에서 시작해서, 말이 최대한 몇 칸을 지날 수 있는지를 구하는 프로그램을 작성하시오. 말이 지나는 칸은 좌측 상단의 칸도 포함된다. 입력첫째 줄에 R과 C가 빈칸을 사이에 두고 주어진다. (1&lt;=R,C&lt;=20) 둘째 줄부터 R개의 줄에 걸쳐서 보드에 적혀 있는 C개의 대문자 알파벳들이 빈칸 없이 주어진다. 출력첫째 줄에 말이 지날 수 있는 최대의 칸 수를 출력한다. https://www.acmicpc.net/problem/1987 node에서 돌려보면 정답이 나오는데 백준에 제출하면 시간초과로 실패한다 ㅠ function solution(inputString) { const input = inputString.split(\"\\n\") const conditions = input[0].split(\" \") const r = Number(conditions[0]) const c = Number(conditions[1]) var visited = new Array(r).fill(null).map(function(a) { return new Array(c).fill(false) }) const pairs = input.splice(1) const alphaVisited = [] let result = 1 let count = 1 dfs(0, 0, count) console.log(result) function dfs(x, y, count) { alphaVisited.push(pairs[x][y]) visited[x][y] = true const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ] for (var i = 0; i &lt; directions.length; i++) { var elem = directions[i] var nx = x + elem[0] var ny = y + elem[1] //좌표범위 if (nx &lt; 0 || nx &gt;= r || ny &lt; 0 || ny &gt;= c) continue const item = pairs[nx][ny] const index = alphaVisited.indexOf(item) // alphaVisited에 없으면 push if (!visited[nx][ny] &amp;&amp; index &lt; 0) { dfs(nx, ny, count + 1) result = Math.max(count + 1, result) // 방문리스트에서 제거해주는게 중요 alphaVisited.splice(index, 1) visited[nx][ny] = false } } }}solution(`10 10ASWERHGCFHQWERHDLKDGZKFOWOHKRKSALTPWOKSSBMDLKLKDKFALSKEMFLFQGMHMBPTIYUDMNKJZKQLFHKFKGLKEOLOTOJKNKRMW`)solution(`2 4CAABADCB`) 새로운 풀이 : bfs로 풀었다.=&gt; q를 일반배열이 아니라 중복을 허용하지 않는 Set자료형을 쓰고( Set 자료형 사용방법 : [참고] https://alligator.io/js/sets-introduction/)좌표 x, y, value를 배열값이 아니라 문자열값으로 넣어준다. 값비교를 할 수 있도록. function solution2(inputString) { const input = inputString.split(\"\\n\") const conditions = input[0].split(\" \") const r = Number(conditions[0]) const c = Number(conditions[1]) const array = input.splice(1) let result = 0 const directions = [ [0, 1], [0, -1], [1, 0], [-1, 0] ] function bfs(x, y) { // 동일한 경우는 한번만 체크하기 위해서 자료형 Set를 쓴다. const q = new Set() // 값으로 중복체크를 하기 위해서 string형으로 넣어준다. q.add([x, y, array[x][y]].toString()) while (q.size &gt; 0) { let items = q.values() const elem = items.next() const arr = elem.value.split(\",\") // 큐에서 제거 q.delete(elem.value) const x = arr[0], y = arr[1], item = arr[2] result = Math.max(result, item.length) for (let i = 0; i &lt; 4; i++) { const elem = directions[i] const nx = Number(x) + elem[0] const ny = Number(y) + elem[1] // 이동할 수 있는 위치이면서 새로운 알파벳 if (nx &gt;= 0 &amp;&amp; nx &lt; r &amp;&amp; ny &gt;= 0 &amp;&amp; ny &lt; c &amp;&amp; item.indexOf(array[nx][ny]) &lt; 0) { // nx, ny, item+array[nx][ny]가 모두 동일하면 추가하지 않도록 q.add([nx, ny, item + array[nx][ny]].toString()) } } } } bfs(0, 0) console.log(result)} 1759 문제문제바로 어제 최백준 조교가 방 열쇠를 주머니에 넣은 채 깜빡하고 서울로 가 버리는 황당한 상황에 직면한 조교들은, 702호에 새로운 보안 시스템을 설치하기로 하였다. 이 보안 시스템은 열쇠가 아닌 암호로 동작하게 되어 있는 시스템이다. 암호는 서로 다른 L개의 알파벳 소문자들로 구성되며 최소 한 개의 모음과 최소 두 개의 자음으로 구성되어 있다고 알려져 있다. 또한 정렬된 문자열을 선호하는 조교들의 성향으로 미루어 보아 암호를 이루는 알파벳이 암호에서 증가하는 순서로 배열되었을 것이라고 추측된다. 즉, abc는 가능성이 있는 암호이지만 bac는 그렇지 않다. 새 보안 시스템에서 조교들이 암호로 사용했을 법한 문자의 종류는 C가지가 있다고 한다. 이 알파벳을 입수한 민식, 영식 형제는 조교들의 방에 침투하기 위해 암호를 추측해 보려고 한다. C개의 문자들이 모두 주어졌을 때, 가능성 있는 암호들을 모두 구하는 프로그램을 작성하시오. 입력첫째 줄에 두 정수 L, C가 주어진다. (3 ≤ L ≤ C ≤ 15) 다음 줄에는 C개의 문자들이 공백으로 구분되어 주어진다. 주어지는 문자들은 알파벳 소문자이며, 중복되는 것은 없다. 출력각 줄에 하나씩, 사전식으로 가능성 있는 암호를 모두 출력한다.https://www.acmicpc.net/problem/1759 핵심 아이디어는 6가지 문자 중에 4가지 문자를 선택해 사전식(알파벳순)으로 나열하는 것이다. 모든 조합을 구해야 함 (dfs를 이용해서 모든 조합을 구하는 함수구현) 모음의 개수 세기 모음 한 개이상, 자음 2개이상인 케이스 출력! function solution(inputString) { const input = inputString.split(\"\\n\") const conditions = input[0].split(\" \") const l = Number(conditions[0]) const c = Number(conditions[1]) const alpha = input[1].split(\" \").sort() const vowels = [\"a\", \"e\", \"i\", \"o\", \"u\"] // console.log(l, c, alpha) const result = [] const string = [] const visited = [] // 모든 조합찾기 function combination(alpha, l, index) { // 길이가 l인 모든 조합 찾기 if (string.length == l) { result.push(JSON.parse(JSON.stringify(string))) return } // 각 원소를 한번씩만 뽑도록 for (let i = index; i &lt; alpha.length; i++) { if (visited.indexOf(i) &gt; 0) continue string.push(alpha[i]) visited.push(i) combination(alpha, l, i + 1) // 비워주는게 중요!! string.pop() visited.pop() } } combination(alpha, l, 0) result.forEach(pwd =&gt; { let count = 0 pwd.forEach(i =&gt; { if (vowels.indexOf(i) &gt; -1) count++ }) if (count &gt;= 1 &amp;&amp; count &lt;= l - 2) { console.log(pwd.join(\"\")) } })}solution(`4 6a t c i s w`) 6603 문제https://www.acmicpc.net/problem/6603 문제독일 로또는 {1, 2, …, 49}에서 수 6개를 고른다. 로또 번호를 선택하는데 사용되는 가장 유명한 전략은 49가지 수 중 k(k&gt;6)개의 수를 골라 집합 S를 만든 다음 그 수만 가지고 번호를 선택하는 것이다. 예를 들어, k=8, S={1,2,3,5,8,13,21,34}인 경우 이 집합 S에서 수를 고를 수 있는 경우의 수는 총 28가지이다. ([1,2,3,5,8,13], [1,2,3,5,8,21], [1,2,3,5,8,34], [1,2,3,5,13,21], …, [3,5,8,13,21,34]) 집합 S와 k가 주어졌을 때, 수를 고르는 모든 방법을 구하는 프로그램을 작성하시오. 입력입력은 여러 개의 테스트 케이스로 이루어져 있다. 각 테스트 케이스는 한 줄로 이루어져 있다. 첫 번째 수는 k (6 &lt; k &lt; 13)이고, 다음 k개 수는 집합 S에 포함되는 수이다. S의 원소는 오름차순으로 주어진다. 입력의 마지막 줄에는 0이 하나 주어진다. 출력각 테스트 케이스마다 수를 고르는 모든 방법을 출력한다. 이때, 사전 순으로 출력한다.각 테스트 케이스 사이에는 빈 줄을 하나 출력한다. 1759번 문제와 동일하게 dfs를 이용해서 모든 조합을 구하면 해결되는 문제다. 핵심 아이디어는 정렬되어 있는 k 개 숫자 중에서 6개를 선택하는 모든 조합 dfs를 이용해서 조합함수를 구현 function solution(params) { const input = params.split(\"\\n\") const len = input.length let result = [] const lottos = [] const visited = [] function combination(elem, index) { // 길이가 6인 모든 조합 if (lottos.length == 6) { result.push(JSON.parse(JSON.stringify(lottos))) return } // 각 원소를 한번씪만 뽑도록 for (let i = index; i &lt; elem.length; i++) { if (visited.indexOf(i) &gt; 0) continue lottos.push(elem[i]) visited.push(i) combination(elem, i + 1) lottos.pop() visited.pop() } } for (let i = 0; i &lt; len; i++) { const nums = input[i].split(\" \").map(a =&gt; +a) // console.log(nums) result = [] combination(nums.slice(1), 0) // console.log(\"result\", result) result.forEach(pwd =&gt; { console.log(pwd.join(\" \")) }) if (result.length) { console.log(\"\") } }}solution(`7 1 2 3 4 5 6 78 1 2 3 5 8 13 21 340`)","link":"/2020/02/07/Programming/Algorithm/back-tracking-core/"},{"title":"[백준] 2110 공유기 설치","text":"공유기 설치도현이의 집 N개가 수직선 위에 있다. 각각의 집의 좌표는 x1, …, xN이고, 집 여러개가 같은 좌표를 가지는 일은 없다. 도현이는 언제 어디서나 와이파이를 즐기기 위해서 집에 공유기 C개를 설치하려고 한다. 최대한 많은 곳에서 와이파이를 사용하려고 하기 때문에, 한 집에는 공유기를 하나만 설치할 수 있고, 가장 인접한 두 공유기 사이의 거리를 가능한 크게 하여 설치하려고 한다. C개의 공유기를 N개의 집에 적당히 설치해서, 가장 인접한 두 공유기 사이의 거리를 최대로 하는 프로그램을 작성하시오. 입력첫째 줄에 집의 개수 N (2 ≤ N ≤ 200,000)과 공유기의 개수 C (2 ≤ C ≤ N)이 하나 이상의 빈 칸을 사이에 두고 주어진다. 둘째 줄부터 N개의 줄에는 집의 좌표를 나타내는 xi (1 ≤ xi ≤ 1,000,000,000)가 한 줄에 하나씩 주어진다. 출력첫째 줄에 가장 인접한 두 공유기 사이의 최대 거리를 출력한다. function solution(params) { const input = params.split(\"\\n\") const [n, c] = input .shift() .split(\" \") .map(a =&gt; +a) const houses = input.map(a =&gt; +a).sort() let min = houses[1] - houses[0], max = houses[n - 1] - houses[0], result = 0 while (min &lt;= max) { let mid = parseInt((min + max) / 2) let cnt = 1 let value = houses[0] for (let i = 1; i &lt; houses.length; i++) { // 간격 mid로 설치할 수 있는 공유기 갯수 세기 if (houses[i] - value &gt;= mid) { cnt += 1 value = houses[i] } } if (cnt &gt;= c) { // 공유기의 수를 줄이자 =&gt; 간격 넓히기 if (result &lt; mid) result = mid min = mid + 1 } else { max = mid - 1 } } console.log(result)}","link":"/2020/02/17/Programming/Algorithm/baekjoon-2110/"},{"title":"[백준] 2512 예산","text":"예산국가의 역할 중 하나는 여러 지방의 예산요청을 심사하여 국가의 예산을 분배하는 것이다. 국가예산의 총액은 미리 정해져 있어서 모든 예산요청을 배정해 주기는 어려울 수도 있다. 그래서 정해진 총액 이하에서 가능한 한 최대의 총 예산을 다음과 같은 방법으로 배정한다. 모든 요청이 배정될 수 있는 경우에는 요청한 금액을 그대로 배정한다.모든 요청이 배정될 수 없는 경우에는 특정한 정수 상한액을 계산하여 그 이상인 예산요청에는 모두 상한액을 배정한다. 상한액 이하의 예산요청에 대해서는 요청한 금액을 그대로 배정한다.예를 들어, 전체 국가예산이 485이고 4개 지방의 예산요청이 각각 120, 110, 140, 150이라고 하자. 이 경우, 상한액을 127로 잡으면, 위의 요청들에 대해서 각각 120, 110, 127, 127을 배정하고 그 합이 484로 가능한 최대가 된다. 여러 지방의 예산요청과 국가예산의 총액이 주어졌을 때, 위의 조건을 모두 만족하도록 예산을 배정하는 프로그램을 작성하시오. 입력첫째 줄에는 지방의 수를 의미하는 정수 N이 주어진다. N은 3 이상 10,000 이하이다. 다음 줄에는 각 지방의 예산요청을 표현하는 N개의 정수가 빈칸을 사이에 두고 주어진다. 이 값들은 모두 1 이상 100,000 이하이다. 그 다음 줄에는 총 예산을 나타내는 정수 M이 주어진다. M은 N 이상 1,000,000,000 이하이다. 출력첫째 줄에는 배정된 예산들 중 최댓값인 정수를 출력한다. function solution(params) { const input = params.split(\"\\n\") const n = parseInt(input.shift()) const budgets = input .shift() .split(\" \") .map(a =&gt; +a) .sort() const sumBud = budgets.reduce((a, b) =&gt; a + b, 0) const total = parseInt(input.shift()) let max = budgets[n - 1] // 요청한대로 다 줄 수 있을 경우 if (sumBud &lt;= total) { console.log(max) } else { // ! 분배가능한 예산이 budgets[0]보다 작은 경우도 있으니... 최소값을 0으로 설정 let min = 0, result = 0 while (min &lt;= max) { let mid = parseInt((min + max) / 2) const temp = getSum(mid) if (temp &gt; total) { // 예산 줄이기 max = mid - 1 } else { // 예산보다 작거나 같아야함. 그중에 최대값 // 예산 늘리기 min = mid + 1 if (result &lt; mid) result = mid } } console.log(result) } function getSum(mid) { let sum = 0 budgets.forEach(a =&gt; { sum += Math.min(mid, a) }) return sum }}","link":"/2020/02/17/Programming/Algorithm/baekjoon-2512/"},{"title":"[백준] 2577 숫자의 개수, 1475 방번호, 1158 요세푸스 문제","text":"2477 숫자의 개수세 개의 자연수 A, B, C가 주어질 때 A×B×C를 계산한 결과에 0부터 9까지 각각의 숫자가 몇 번씩 쓰였는지를 구하는 프로그램을 작성하시오. 예를 들어 A = 150, B = 266, C = 427 이라면 A × B × C = 150 × 266 × 427 = 17037300 이 되고, 계산한 결과 17037300 에는 0이 3번, 1이 1번, 3이 2번, 7이 2번 쓰였다. 입력첫째 줄에 A, 둘째 줄에 B, 셋째 줄에 C가 주어진다. A, B, C는 모두 100보다 같거나 크고, 1,000보다 작은 자연수이다. 출력첫째 줄에는 A×B×C의 결과에 0 이 몇 번 쓰였는지 출력한다. 마찬가지로 둘째 줄부터 열 번째 줄까지 A×B×C의 결과에 1부터 9까지의 숫자가 각각 몇 번 쓰였는지 차례로 한 줄에 하나씩 출력한다. https://www.acmicpc.net/problem/2577 0~9까지 출현횟수를 담는 count 배열을 0으로 초기화한다.그리고 단순히 세 자연수의 곱을 구한 뒤 string으로 변환한 후 for문을 돌면서 세어주면 된다. function solution(params) { const input = params.split(\"\\n\").map(a =&gt; +a) let sum = input[0] * input[1] * input[2] sum = sum.toString() const count = new Array(10).fill(0) for (let i = 0; i &lt; sum.length; i++) { const element = sum[i] count[element] += 1 } count.forEach(a =&gt; console.log(a))}solution(`150266427`) 1475 방번호다솜이는 은진이의 옆집에 새로 이사왔다. 다솜이는 자기 방 번호를 예쁜 플라스틱 숫자로 문에 붙이려고 한다. 다솜이의 옆집에서는 플라스틱 숫자를 한 세트로 판다. 한 세트에는 0번부터 9번까지 숫자가 하나씩 들어있다. 다솜이의 방 번호가 주어졌을 때, 필요한 세트의 개수의 최솟값을 출력하시오. (6은 9를 뒤집어서 이용할 수 있고, 9는 6을 뒤집어서 이용할 수 있다.) 입력첫째 줄에 다솜이의 방 번호 N이 주어진다. N은 1,000,000보다 작거나 같은 자연수 또는 0이다. 출력첫째 줄에 필요한 세트의 개수를 출력한다.https://www.acmicpc.net/problem/1475 2477번과 유사한 방식으로 풀면 된다.0~9까지의 출현횟수를 담는 count 배열을 0으로 초기화하고방번호에 나오는 숫자 카운트를 세면 된다. 6은 9를 뒤집어서 이용할 수 있고, 9는 6을 뒤집어서 이용할 수 있다 이 조건을 적용하기 위해서6이 출현할 때 count[9]의 값을 +1한다.그리고 Math.ceil(count[9] / 2) 한 값을 count[6], count[9]에 넣어준다. 수집된 count를 forEach문으로 돌면서 가장 큰 값을 찾아내면 된다. function solution(params) { const input = params const len = input.length const count = new Array(10).fill(0) // 어떤 숫자가 필요한지 파악 for (let i = 0; i &lt; len; i++) { const elem = input[i] // 9와 6은 한꺼번에 센다 if (elem == 6) count[9] += 1 else count[elem] += 1 } const temp = Math.ceil(count[9] / 2) count[6] = temp count[9] = temp let max = 0 count.forEach(a =&gt; { if (max &lt; a) max = a }) console.log(max)}solution(`9999`) 1158 요세푸스 문제요세푸스 문제는 다음과 같다. 1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고, 양의 정수 K(≤ N)가 주어진다. 이제 순서대로 K번째 사람을 제거한다. 한 사람이 제거되면 남은 사람들로 이루어진 원을 따라 이 과정을 계속해 나간다. 이 과정은 N명의 사람이 모두 제거될 때까지 계속된다. 원에서 사람들이 제거되는 순서를 (N, K)-요세푸스 순열이라고 한다. 예를 들어 (7, 3)-요세푸스 순열은 &lt;3, 6, 2, 7, 5, 1, 4&gt;이다. N과 K가 주어지면 (N, K)-요세푸스 순열을 구하는 프로그램을 작성하시오. 입력첫째 줄에 N과 K가 빈 칸을 사이에 두고 순서대로 주어진다. (1 ≤ K ≤ N ≤ 5,000) 출력예제와 같이 요세푸스 순열을 출력한다.https://www.acmicpc.net/problem/1158 링크드리스트를 이용해 풀었다.1번부터 N번까지 N명의 사람이 원을 이루면서 앉아있고 이므로 링크드리스트의 꼬리의 next가 머리가 되도록 해야한다.일반적인 링크드리스트 구현에서 삭제를 위한 count를 세기 시작하는 노드 정보를 this._del_node에 담아두는 것만 추가했다. class Node { constructor(data) { this.data = data this.next = null }}class LinkedList { constructor(n, k) { this._length = 0 this._head = null this._del_node = null this._n = n this._k = k } getLength() { return this._length } // 마지막이면... 연결 insert(node) { if (this._head) { let elem = this._head while (elem.next) { elem = elem.next } elem.next = node // 꼬리의 next가 머리가 되도록 if (node.data == this._n) { elem.next.next = this._head } } else { this._head = node this._del_node = node } this._length++ } // k번째 delete() { let k = this._k - 1 // 삭제 후, 앞 뒤를 연결해주기 위해서 prev 노드정보도 필요하다. let prev = this._del_node, elem = this._del_node while (k &gt; 0 &amp;&amp; this._length &gt; 0) { prev = elem elem = elem.next k-- } const deleted = elem.data // 삭제한노드의 앞,뒤를 연결 prev.next = elem.next // 다음번 삭제를 위해 탐색을 시작하는 첫번째 노드 this._del_node = elem.next this._length-- return deleted }}function solution(params) { const input = params.split(\" \").map(a =&gt; +a) const n = input[0], k = input[1] const linked = new LinkedList(n, k) for (let i = 0; i &lt; n; i++) { const node = new Node(i + 1) linked.insert(node) } const answer = [] let len = n while (len) { answer.push(linked.delete()) len-- } console.log(`&lt;${answer.join(\", \")}&gt;`)}// 링크드리스트solution(`7 3`)","link":"/2020/02/22/Programming/Algorithm/baekjoon-array/"},{"title":"[백준] 3986 좋은 단어 / 9012 괄호 - 자바스크립트","text":"3986 문제https://www.acmicpc.net/problem/3986 이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 ‘좋은 단어’나 세보기로 마음 먹었다. 평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 ‘좋은 단어’이다. 평석이가 ‘좋은 단어’ 개수를 세는 것을 도와주자. 입력첫째 줄에 단어의 수 N이 주어진다. (1 ≤ N ≤ 100) 다음 N개 줄에는 A와 B로만 이루어진 단어가 한 줄에 하나씩 주어진다. 단어의 길이는 2와 100,000사이이며, 모든 단어 길이의 합은 1,000,000을 넘지 않는다. 출력첫째 줄에 좋은 단어의 수를 출력한다. 해결방법단어 문자하나하나를 stack에 넣고 만약 stack의 맨 위 2개의 문자가 같으면 pop 해준다.단어의 길이만큼 for문을 돌고나서 stack 이 비어있으면 answer++을 해주면 된다. function solution(params) { const input = params.split(\"\\n\") const n = parseInt(input[0]) const strs = input.slice(1) let answer = 0 for (let i = 0; i &lt; n; i++) { const stack = [] const elem = strs[i] stack.push(elem[0]) for (let j = 1; j &lt; elem.length; j++) { const element = elem[j] // 스택 맨위의 문자와 같으면 pop if (element == stack[stack.length - 1]) { stack.pop() } else { stack.push(element) } } if (stack.length == 0) { answer++ } } console.log(answer)}solution(`3ABABAABBABBA`)solution(`3ABBABBABBBBAAAAAABBAAAAA`)solution(`1BABBAB`) 동일한 풀이법으로 해결가능한 9012번 괄호 문제도 풀어보았다. 9012 문제괄호 문자열(Parenthesis String, PS)은 두 개의 괄호 기호인 ‘(’ 와 ‘)’ 만으로 구성되어 있는 문자열이다. 그 중에서 괄호의 모양이 바르게 구성된 문자열을 올바른 괄호 문자열(Valid PS, VPS)이라고 부른다. 한 쌍의 괄호 기호로 된 “( )” 문자열은 기본 VPS 이라고 부른다. 만일 x 가 VPS 라면 이것을 하나의 괄호에 넣은 새로운 문자열 “(x)”도 VPS 가 된다. 그리고 두 VPS x 와 y를 접합(concatenation)시킨 새로운 문자열 xy도 VPS 가 된다. 예를 들어 “(())()”와 “((()))” 는 VPS 이지만 “(()(”, “(())()))” , 그리고 “(()” 는 모두 VPS 가 아닌 문자열이다. 여러분은 입력으로 주어진 괄호 문자열이 VPS 인지 아닌지를 판단해서 그 결과를 YES 와 NO 로 나타내어야 한다. 입력입력 데이터는 표준 입력을 사용한다. 입력은 T개의 테스트 데이터로 주어진다. 입력의 첫 번째 줄에는 입력 데이터의 수를 나타내는 정수 T가 주어진다. 각 테스트 데이터의 첫째 줄에는 괄호 문자열이 한 줄에 주어진다. 하나의 괄호 문자열의 길이는 2 이상 50 이하이다. 출력출력은 표준 출력을 사용한다. 만일 입력 괄호 문자열이 올바른 괄호 문자열(VPS)이면 “YES”, 아니면 “NO”를 한 줄에 하나씩 차례대로 출력해야 한다. 이 문제를 풀 핵심 아이디어는괄호를 차례대로 stack에 넣고, 열린괄호 닫힌괄호가 한 세트가 되면 pop해준다.괄호문자열의 길이만큼 다 돌았을 때, stack의 길이가 0이면 올바른 괄호 문자열이다. function solution(params) { const input = params.split(\"\\n\") const n = parseInt(input[0]) const pairs = input.slice(1) for (let i = 0; i &lt; n; i++) { const elem = pairs[i] const stack = [elem[0]] for (let j = 1; j &lt; elem.length; j++) { const char = elem[j] if (char == \")\" &amp;&amp; stack[stack.length - 1] == \"(\") { stack.pop() } else { stack.push(char) } } if (stack.length &gt; 0) { console.log(\"NO\") } else { console.log(\"YES\") } }}solution(`6(())())(((()())()(()())((()))((()()(()))(((())))()()()()()(()()())()(()((())()(`)","link":"/2020/02/08/Programming/Algorithm/baekjoon-3986/"},{"title":"이진탐색(binary-search)","text":"순차적으로 나열된 배열에서 특정 원소를 빨리 찾는 법!! 만약 1 ~ 100 사이의 숫자 가운데 87을 찾는다고 한다면 1부터 순서대로 추측하면 87번 추측을 해야 우리가 찾고자하는 숫자 87에 도달할 수 있다.(만약 찾고자하는 수가 99라면 99번이나 추측을 해야하겠지요…)이런 방법을 단순 검색(Simple Search)… 띠리한 방법… 좀 더 나은 방법을 찾아보면! 중간부터 시작하는 것!1 ~ 100 가운데 87을 찾기위해 중간 숫자 50부터 추측을 해보면,“50이 너무 작다”는 결과를 통해 1~50을 날려버릴 수가 있다. 남은 51 ~ 100의 숫자 중 중간 숫자 75로 추측해보면“75가 너무 작다” 76 ~ 100의 가운데 숫자 87을 추측해보면 불과 3번만에 우리가 찾는 숫자 “87”을 찾아낼 수 있다!!!! 이런 식의 방법을 이진 탐색(Binary Search)이라고 한다. 만약 n개의 원소를 가진 리스트에서 이진탐색을 사용하면 최대 log2의 n번 만에 답을 찾을 수 있다. 기존의 파이썬으로 된 예제를 자바스크립트로 바꿔봤다.binary_search = (list, item) =&gt; { let low = 0; let high = list.length - 1; let count = 1;s while (low &lt;= high) { let mid = Math.floor((low + high) / 2); let guess = list[mid]; if (guess == item) { console.log(`${item}을 ${count}번만에 찾았다!! my_list[${mid}]에 위치해있다.`); return mid; } else if (guess &gt; item) { high = mid - 1; count++; } else { low = mid + 1; count++; } } console.log(`${item}은 my_list에 존재하지 않는다!!`); return;};my_list = [];for(let i = 0; i&lt; 100; i++) { my_list.push(2*i-1);}binary_search(my_list, 117);binary_search(my_list, -3); 결과값117을 6번만에 찾았다!! my_list[59]에 위치해있다.-3은 my_list에 존재하지 않는다!!","link":"/2018/04/07/Programming/Algorithm/binary-search/"},{"title":"빅오 표기법(Big-O Notation)","text":"알고리즘이 얼마나 빠른지 표시하는 방법.알고리즘의 속도는 시간이 아니라 연산의 횟수가 어떻게 증가하는지로 측정한다.빅오 표기법을 사용하면 수행해야 할 일이 많아질 때, 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지를 알 수가 있다. 전화번호부에서 사람을 찾기 위해 단순탐색을 사용한다고 하면 단순 탐색의 실행시간 : O(n)Adit이라는 이름을 전화번호부의 맨 앞에서 찾았다고 하더라도 이 경우의 실행시간은 O(n)이다. 빅오 표기법은 최악의 경우에 대한 것!즉, 단순 탐색이 절대로 O(n)의 시간보다 느려지지 않는다는 일종의 보장! 이진 탐색의 실행시간 : O(log n)O(log n)은 O(n)보다 빠르다. 리스트의 원소 개수가 증가하면 상대적으로 더 빨라진다!! 많이 사용하는 빅오 실행시간의 예 O(1) – 상수 시간 : 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다. ex) 해시테이블, 해시함수O(log n) – 로그 시간 : 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듭니다. ex) 이진탐색O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가집니다. ex) 단순탐색O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱입니다. ex) 선택정렬O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱입니다. (상당히 큰수가 됩니다)O(n!) : 문제를 해결하기 위해 n!번의 연산이 필요하다. ex)외판원 문제 위의 그래프를 통해 데이터의 수가 증가함에 따라 수행시간이 어떤 비율로 증가하는지 한 눈에 비교해 볼 수 있다. 연습문제1-1. 128개의 이름이 정렬되어 있는 리스트. 이진 탐색으로 이름을 찾을 때 필요한 최대 추측 횟수는?=&gt; log 128 = 7 번1-2. 만약 리스트의 크기가 두 배가 된다면 최대 추측 횟수는 ?=&gt; log 256 = 8 번!1-3. 어떤 사람의 이름을 알고 있다. 전화번호부에서 이 사람의 전화번호를 찾고 싶다.=&gt; 이름을 찾은 후에, 그 이름에 해당하는 전화번호를 찾아야하니까 O(n+1) 이거는 결국 O(n)과 실행시간이 같겠지...?? ==&gt;해답 엇... 해답을 보니 O(log n)이네. 이름을 알고 있다는 것은 이진탐색을 할 수 있다는 의미니까! O(log n)이구나...1-4. 전화번호가 있다. 전호번호부에서 이 전화번호를 가진 사람의 이름을 찾고 싶다.(힌트: 전화번호부를 모두 찾아야 할 수도 있다)=&gt; O(n)1-5. 전화번호부에 있는 모든 사람의 전화번호를 알고 싶다.=&gt; O(n)1-6. 알파벳 A로 시작하는 사람들의 전화번호를 알고 싶다….=&gt; O(n) =&gt; 알파벳 A로 시작하는 사람을 찾는 것 역시... 전화번호부 전체를 다 뒤져봐야할 수도 있으니까....? ==&gt; 해답의 좀 더 정확한 해설을 보면 알파벳 26자중 하나의 알파벳만 탐색하면 되니까 O(n/26) 이라고 생각하기 쉬우나, 실행시간에 대해 상수는 무시한다는 규칙!!! O(n/26) -&gt; O(n)으로 표기해야함.","link":"/2018/04/07/Programming/Algorithm/big-o/"},{"title":"이진탐색트리 구현","text":"이진탐색트리를 구현해보자.그전에 자료구조 트리의 개념을 먼저 살펴보면, 트리 (Tree) 란?트리: Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조 이진 트리 : Node가 가질 수 있는 Branch가 최대 2개인 트리이진 탐색 트리 : 이진트리 중에서 Branch를 만들 때, 자기 노드보다 작은 것은 왼쪽, 큰 것은 오른쪽에 위치하도록 하는 트리. [참고]알아둘 용어 Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함)Root Node: 트리 맨 위에 있는 노드Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄Parent Node: 어떤 노드의 다음 레벨에 연결된 노드Child Node: 어떤 노드의 상위 레벨에 연결된 노드Leaf Node (Terminal Node): Child Node가 하나도 없는 노드Sibling (Brother Node): 동일한 Parent Node를 가진 노드Depth: 트리에서 Node가 가질 수 있는 최대 Level 실제로 어디에 많이 사용되나?트리 중 이진 트리 (Binary Tree) 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용된다. 탐색시 시간복잡도 depth (트리의 높이) 를 h라고 표기한다면, O(h)n개의 노드를 가진다면, ℎ=𝑙𝑜𝑔2𝑛 에 가까우므로, 시간 복잡도는 𝑂(𝑙𝑜𝑔𝑛)참고: 빅오 표기법에서 𝑙𝑜𝑔𝑛 에서의 log의 밑은 10이 아니라, 2이다.한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미한다. 하지만 위와 같은 시간복잡도는 이진트리가 균형잡혀 있을 때의 평균 시간복잡도이다.최악의 경우 링크드 리스트와 동일한 성능을 보여주기도 한다. 이진탐색트리 구현class Node { constructor(data) { this.data = data this.right = null this.left = null }}class BinarySearchTree { constructor() { this._head = null } insert(data) { if (this._head) { let currNode = this._head while (true) { if (data &lt; currNode.data) { if (currNode.left) { // 비교할 대상 바꾸기 currNode = currNode.left } else { currNode.left = new Node(data) break } } else { if (currNode.right) { // 비교할 대상 바꾸기 currNode = currNode.right } else { currNode.right = new Node(data) break } } } } else { this._head = new Node(data) } } search(data) { let curr = this._head while (curr) { if (curr.data === data) { return true } else if (data &lt; curr.data) { curr = curr.left } else { curr = curr.right } } return false } /* 복잡하므로 경우를 나눠서 생각하는게 좋다. 1. 삭제할 노드가 leaf node일 경우 2. child node가 하나인 노드 삭제 3. child node가 두개인 노드 삭제 (둘중에 하나의 전략으로) 전략 1. 삭제할 노드의 오른쪽 자식중, 가장 작은 값을 삭제할 노드의 parent노드가 가리키도록 한다. 전략 2. 삭제할 노드의 왼쪽 자식중, 가장 큰 값을 삭제할 노드의 parent 노드가 가리키도록 한다. 아래의 코드에서는 전략1을 사용 */ delete(data) { let searched = false let currNode = this._head let parentNode = this._head // 1. 삭제할 노드 있는 체크 while (currNode) { if (currNode.data === data) { searched = true break } else if (data &lt; currNode.data) { parentNode = currNode currNode = currNode.left } else { parentNode = currNode currNode = currNode.right } } if (!searched) return false // case 1 : leaf node 인지 체크 if (currNode.left === null &amp;&amp; currNode.right === null) { // 삭제할 노드가 왼쪽노드인지 오른쪽노드인지 체크 if (data &lt; parentNode.data) { parentNode.left = null } else { parentNode.right = null } // delete currNode } // case 2 : child 노드를 하나만 가지고 있을 때 if (currNode.left !== null &amp;&amp; currNode.right === null) { if (data &lt; parentNode.data) { parentNode.left = currNode.left } else { parentNode.right = currNode.left } } else if (currNode.left === null &amp;&amp; currNode.right !== null) { if (data &lt; parentNode.data) { parentNode.left = currNode.right } else { parentNode.right = currNode.right } } /* case 3 전략 1 삭제할 노드의 오른쪽 자식중, 가장 작은 값을 삭제할 노드의 parent노드가 가리키도록 한다. */ if (currNode.left !== null &amp;&amp; currNode.right !== null) { // case 3-1 : 삭제할 Node가 Parent Node 왼쪽에 있을 때 if (data &lt; parentNode.data) { let changeNode = currNode.right let changeNodeParent = currNode.right while (changeNode.left !== null) { changeNodeParent = changeNode changeNode = changeNode.left } // 오른쪽 노드들중 가장 작은 값의 노드가 right child가 있는지 체크 if (changeNode.right !== null) { changeNodeParent.left = changeNode.right } else { changeNodeParent.left = null } parentNode.left = changeNode changeNode.right = currNode.right changeNode.left = currNode.left } // case 3-2 : 삭제할 Node가 Parent Node 오른쪽에 있을 때 else { let changeNode = currNode.left let changeNodeParent = currNode.left while (changeNode.left !== null) { changeNodeParent = changeNode changeNode = changeNode.left } // 오른쪽 노드들중 가장 작은 값의 노드가 right child가 있는지 체크 if (changeNode.right !== null) { changeNodeParent.left = changeNode.right } else { changeNodeParent.left = null } parentNode.right = changeNode changeNode.left = currNode.left changeNode.right = currNode.right } } }} 이진검색트리 테스트// 임의의 숫자 100개 준비const numset = new Set()while (numset.size != 100) { numset.add(Math.floor(Math.random() * 1000))}// 헤드값을 500을 가지는 이진검색트리 생성const bst = new BinarySearchTree()bst.insert(500)// 선택된 100개의 숫자를 이진 탐색 트리에 입력for (let item of numset) { bst.insert(item)}// 입력한 100개의 숫자 검색 (검색 기능 확인)for (let item of numset) { if (bst.search(item) === false) { console.log(\"search failed\", item) }}// 10개 임의로 삭제해보기const deleteNums = new Set()const numArray = [...numset]while (deleteNums.size != 10) { const index = Math.floor(Math.random() * 100) deleteNums.add(numArray[index])}for (let item of deleteNums) { if (bst.delete(item) === false) { console.log(\"delete failed\") }}","link":"/2019/12/26/Programming/Algorithm/binary-search-tree-implement/"},{"title":"다익스트라 알고리즘(dijkstra-algorithm)","text":"그래프의 간선에 가중치를 준 가중 그래프weighted graph을 배우자. 가중 그래프에서 X까지의 최단 경로를 구하는 다익스트라 알고리즘을 배우자. 그래프에 사이클 cycle이 있을 경우 다익스트라 알고리즘을 사용할 수 없다. 너비 우선 탐색 vs 다익스트라 알고리즘너비 우선 탐색으로 최단 경로(가장 적은 수의 구간을 지나는)를 찾을 수 있었다.다익스트라 알고리즘으로는 최단 시간 경로를 구할 수 있다!다익스트라 알고리즘은 각 구간에 대해 숫자 혹은 가중치를 줄 수 있다. 전체 가중치의 합이 가장 작은 구간을 찾는다. 다익스트라 알고리즘 4단계 가장 가격이 싼 정점, 즉 도달하는 데 시간이 가장 적게 걸리는 정점을 찾는다. 이 정점의 이웃 정점에 대해 현재의 가격보다 더 싼 경로가 존재하는 지 확인, 만약 존재한다면 가격을 수정. 그래프 상의 모든 정점에 대해 이러한 일을 반복 최종 경로를 계산 위의 그래프는 라마가 바꿀 수 있는 물건들을 정점으로 나타냈다. 간선의 가중치는 물건을 바꾸는 데 드는 돈이다.라마가 돈을 가장 적게 쓰면서 악보를 피아노와 바꾸려면 어떤 경로를 택해야할까? 일단 각 정점에 대한 가격표를 만든다. 정점의 가격이란 그 정점에 도달하기까지 드는 돈을 의미한다. 정점 가격 LP 5 포스터 0 기타 * 드럼 * 피아노 * 알고리즘을 진행하면서 표를 수정하는데, 최종 경로를 계산하려면 부모열이 필요하다. 부모 정점 가격 악보 LP 5 악보 포스터 0 포스터 기타 30 포스터 드럼 35 LP 기타 20 LP 드럼 25 기타 피아노 40 드럼 피아노 35 위이 표를 보면 라마가 가장 싸게 피아노를 구매할 수 있는 가격은 35달러!!경로를 찾아보면, 악보 -&gt; (5) -&gt; LP -&gt; (20) -&gt; 드럼 -&gt; (10) -&gt; 피아노 간선의 가중치가 음수인 경우만약 아래의 그래프에서 드럼을 살 수 있는 최소 가격을 다익스트라 알고리즘으로 구해보면? 부모 정점 가격 악보 LP 5 LP 포스터 -2 악보 포스터 0 포스터 드럼 35 포스터에 도달하는 0달러보다 더 싼 경로는 없다고 가정하지만, 실제로 -2달러인 경로가 존재한다.다익스트라 알고리즘에서는 포스터 정점을 이미 처리했기 때문에 더 싼 경로는 없다고 가정한다.그래서 드럼에 이르는 더 싼 경로를(33달러) 다익스트라 알고리즘에서는 찾지 못한다. 코드로 구현 위의 그래프를 코드로 구현해보자. //그래프에 대한 해시테이블graph = {};graph[\"start\"] = {};graph[\"start\"][\"a\"] = 6;graph[\"start\"][\"b\"] = 2;graph[\"a\"] = {};graph[\"a\"][\"fin\"] = 1;graph[\"b\"] = {};graph[\"b\"][\"a\"] = 3;graph[\"b\"][\"fin\"] = 5;graph[\"fin\"] = {};//가격에 대한 해시테이블costs = {};costs[\"a\"] = 6;costs[\"b\"] = 2;costs[\"fin\"] = Infinity;//부모를 위한 해시테이블parents = {};parents[\"a\"] = \"start\";parents[\"b\"] = \"start\";parents[\"fin\"] = \"\";// 이미 처리한 정점 배열processed = [];// 아직 처리하지 않은 가장 싼 정점을 찾는다find_lowest_cost_node = (costs) =&gt; { lowest_cost = Infinity; lowest_cost_node = \"\"; for( let node in costs) { const cost = costs[node]; if(cost &lt; lowest_cost &amp;&amp; processed.indexOf(node) &lt; 0) { lowest_cost = cost; lowest_cost_node = node; } } return lowest_cost_node;}let node = find_lowest_cost_node(costs);while(node) { const cost = costs[node]; const neighbors = graph[node] for(let i =0; i&lt; Object.keys(neighbors).length; i++) { const new_cost = cost + neighbors[Object.keys(neighbors)[i]] if( costs[Object.keys(neighbors)[i]] &gt; new_cost ) { costs[Object.keys(neighbors)[i]] = new_cost; parents[Object.keys(neighbors)[i]] = node } } processed.push(node) node = find_lowest_cost_node(costs)}//{ a: 5, b: 2, fin: 6 } 7장에서 배운 내용1. 너비 우선 탐색은 가중치가 없는 균일 그래프에서 최단 경로를 계산하는 데 사용. 2. 다익스트라 알고리즘은 가중 그래프에서 최단 거리를 계산하는 데 사용. 3. 다익스트라 알고리즘은 모든 가중치가 양수일 때 정상적으로 동작. 4. 만약 가중치가 음수이면 벨만-포드 알고리즘을 사용.","link":"/2018/05/06/Programming/Algorithm/dijkstra-algorithm/"},{"title":"[백준] 동적프로그래밍 기본 문제풀이","text":"대표적인 동적 프로그래밍 알고리즘의 문제를 풀어보면서 어떻게 동적 프로그래밍 알고리즘 문제에 접근해야하는지 파악해보았다. 동적 프로그래밍 알고리즘 문제는 한 번 계산한 값은 다시 구하지 않는다는 것, 즉 메모이제이션을 활용한다는 것이 특징이다. n이 작을 때의 값을 구해서 배열에 담아둔다.그리고 인접한 항들 사이의 관계를 파악한다.이 관계에 따라 앞서 미리 구해둔 값들을 이용해 n이 클 때의 값을 구한다. 보통 위와 같은 과정을 통해 동적 프로그래밍 문제를 푼다. 풀어본 문제는 백준 알고리즘 사이트에 있는 1904, 11053, 12865번 문제다. 1904문제https://www.acmicpc.net/problem/1904 풀이 과정 그림을 그려 규칙을 찾아보면 n = 1 -&gt; 1n = 2 -&gt; 2 그 이후 타일을 나열하는 경우의 수는 n-1 일 때의 경우의 수에 1타일을 붙이는 경우 n-2 일 때의 경우의 수에 00타일을 붙이는 경우 즉 f(n) = f(n-1) + f(n-2) 의 규칙성을 띤다. 나의 풀이function solution(input) { const n = Number(input) dp = [] dp[1] = 1 dp[2] = 2 for (let i = 3; i &lt;= n; i++) { dp[i] = (dp[i - 1] + dp[i - 2]) % 15746 } console.log(dp[n])}solution(4) 11053문제https://www.acmicpc.net/problem/11053 풀이 과정 먼저 수열 크기 n을 길이로하는 배열을 1로 초기화를 해준다.i=1부터 n까지 for문을 돌면서 이전 요소와 비교를 한다.만약 elements[i] &gt; elements[j]일 경우 elements[j] + 1한 값을 dp[i]에 넣어준다. 요소 30의 경우를 보면10, 20, 10과 각각 비교해보면 30이 더 크기때문에 dp[i]에 2,3,2 값이 들어오게 된다.그 중에서 max값을 선택하면 된다. 나의 풀이function solution(inputString) { var input = inputString.trim().split(\"\\n\") // 6 // 10 20 10 30 20 50 var n = +input[0] var elements = input[1].split(\" \").map(a =&gt; +a) const dp = new Array(n).fill(1, 0) for (let i = 1; i &lt; n; i++) { for (let j = 0; j &lt; i; j++) { if (elements[i] &gt; elements[j]) { dp[i] = Math.max(dp[i], dp[j] + 1) } } console.log(dp) // [ 1, 2, 1, 1, 1, 1 ] // [ 1, 2, 1, 1, 1, 1 ] // [ 1, 2, 1, 3, 1, 1 ] // [ 1, 2, 1, 3, 2, 1 ] // [ 1, 2, 1, 3, 2, 4 ] } console.log(Math.max(...dp))}solution(`610 20 10 30 20 50`) 12865문제https://www.acmicpc.net/problem/12865 2020.02.07 자 새로운 접근각 무게에 대해서 최대가치를 저장하기!각 무게를 index로 하고 그 때의 최대 가치를 값에 저장해둔다. (하지만 백준에 제출하면 시간초과가 된다 ㅠ) function solution2(inputString) { const input = inputString .toString() .trim() .split(\"\\n\") // 4 7 const firstInput = input[0] .toString() .trim() .split(\" \") .map(a =&gt; +a) const n = firstInput[0] const maxWeight = firstInput[1] const pairs = input.slice(1).map(a =&gt; a.split(\" \").map(a =&gt; +a)) pairs.sort((a, b) =&gt; a[0] - b[0]) // 0으로 초기화 const dp = new Array(maxWeight + 1).fill(0) // 물건 하나씩 담았을 때의 가치를 셋팅 pairs.forEach(a =&gt; { dp[a[0]] = a[1] }) // 물건의 최소무게 ~ 담을 수 있는 최대 무게까지 for문을 돌면서 for (let i = pairs[0][0]; i &lt;= maxWeight; i++) { for (let j = 0; j &lt; i; j++) { // 더해서 i가 되는 경우 중 가치가 가장 높은 것을 dp[i]에 담는다. dp[i] = Math.max(dp[i - j] + dp[j], dp[i]) } } console.log(Math.max(...dp))}solution2(`4 76 134 83 65 12`) 이전 풀이 먼저 빈배열 dp에다 물건하나씩 넣었을 때의 가치를 아래와 같이 셋팅해준다. dp[무게] = 가치 물건 두 개씩 넣었을 때 무게의 값이 k를 넘지 않을 때 dp[무게]를 갱신해준다. dp에 담긴 값 중에서 가장 큰 값을 리턴하면 된다. 하지만… 이 방법은 k가 무한히 큰 값에서는 맞지 않는 풀이다.만약 리밋 무게값 k가 큰 수라면 물품을 3,4 넣어야하는 경우가 생길 수도 있다.그렇게 되면 삼중, 사중 for문을 돌게되는 경우가 생긴다. 잘못된 풀이다.다시 풀어야지… function solution(inputString) { const input = inputString .toString() .trim() .split(\"\\n\") // 4 7 const firstInput = input[0] .toString() .trim() .split(\" \") .map(a =&gt; +a) const n = firstInput[0] const maxWeight = firstInput[1] const userInputs = [] const dp = [] for (let i = 1; i &lt; input.length; i++) { const temp = input[i] .toString() .trim() .split(\" \") .map(a =&gt; +a) dp[temp[0]] = temp[1] userInputs.push(temp) } for (let i = 0; i &lt; n; i++) { for (let j = i + 1; j &lt; n; j++) { if (userInputs[i][0] + userInputs[j][0] &lt;= maxWeight) { dp[userInputs[i][0] + userInputs[j][0]] = userInputs[i][1] + userInputs[j][1] } } } const valid = dp.filter(a =&gt; { if (a) return a }) console.log(Math.max(...valid))}solution(`4 76 134 83 65 12`)","link":"/2020/01/07/Programming/Algorithm/dp_basic/"},{"title":"[백준] 동적프로그래밍 핵심 문제풀이","text":"9251 문제문제LCS(Longest Common Subsequence, 최장 공통 부분 수열)문제는 두 수열이 주어졌을 때, 모두의 부분 수열이 되는 수열 중 가장 긴 것을 찾는 문제이다. 예를 들어, ACAYKP와 CAPCAK의 LCS는 ACAK가 된다. 입력첫째 줄과 둘째 줄에 두 문자열이 주어진다. 문자열은 알파벳 대문자로만 이루어져 있으며, 최대 1000글자로 이루어져 있다. 출력첫째 줄에 입력으로 주어진 두 문자열의 LCS의 길이를 출력한다.https://www.acmicpc.net/problem/9251이 문제는 전형적인 LCS 문제이다. Longest Common Subsequences 접근하는 방법은 아래와 같다. 마지막 문자가 같은 경우String A: “ABCD”, String B: “AEBD”LCS(“ABCD”, “AEBD”) = 1 + LCS(“ABC”, “AEB”) 마지막 문자가 다른 경우String A: “ABCDE”, String B: “AEBDF”LCS(“ABCDE”, “AEBDF”) = Max(LCS(“ABCDE”, “AEBD”), LCS(“ABCD”, “AEBDF”)) 재귀적으로 이 문제를 풀어보면, function LCS(inputString) { var input = inputString.split(\"\\n\") var string1 = input[0] var string2 = input[1] var len1 = string1.length var len2 = string2.length if (len2 == 0 || len1 == 0) return 0 if (string1[len1 - 1] == string2[len2 - 1]) { return 1 + LCS(`${string1.substring(0, len1 - 1)}\\n${string2.substring(0, len2 - 1)}`) } else { return Math.max( LCS(`${string1.substring(0, len1 - 1)}\\n${string2.substring(0, len2)}`), LCS(`${string1.substring(0, len1)}\\n${string2.substring(0, len2 - 1)}`) ) }}const count = LCS(`ACAYKPCAPCAK`)console.log(count) 하지만 이렇게 풀면 백준에서 시간초과가 난다. DP를 좀 더 활용해서 이 문제를 접근해보면 function LCS(inputString) { var input = inputString.split(\"\\n\") var string1 = input[0] var string2 = input[1] var len1 = string1.length var len2 = string2.length // 0으로 초기화 var dp = Array(len1 + 1) .fill(null) .map(function() { return Array(len2 + 1).fill(0) }) for (var i = 1; i &lt;= len1; i++) { for (var j = 1; j &lt;= len2; j++) { // case1 마지막 글자가 같을 경우 if (string1[i - 1] === string2[j - 1]) { dp[i][j] = dp[i - 1][j - 1] + 1 } // case2 마지막 글자가 다를 경우 else { dp[i][j] = Math.max(dp[i - 1][j], dp[i][j - 1]) } } } // console.log(\"dp\", dp) console.log(dp[len1][len2])} 1495 문제https://www.acmicpc.net/problem/1495 문제Day Of Mourning의 기타리스트 강토는 다가오는 공연에서 연주할 N개의 곡을 연주하고 있다. 지금까지 공연과는 다른 공연을 보여주기 위해서 이번 공연에서는 매번 곡이 시작하기 전에 볼륨을 바꾸고 연주하려고 한다. 먼저, 공연이 시작하기 전에 각각의 곡이 시작하기 전에 바꿀 수 있는 볼륨의 리스트를 만들었다. 이 리스트를 V라고 했을 때, V[i]는 i번째 곡을 연주하기 전에 바꿀 수 있는 볼륨을 의미한다. 항상 리스트에 적힌 차이로만 볼륨을 바꿀 수 있다. 즉, 현재 볼륨이 P이고 지금 i번째 곡을 연주하기 전이라면, i번 곡은 P+V[i]나 P-V[i] 로 연주해야 한다. 하지만, 0보다 작은 값으로 볼륨을 바꾸거나, M보다 큰 값으로 볼륨을 바꿀 수 없다. 곡의 개수 N과 시작 볼륨 S, 그리고 M이 주어졌을 때, 마지막 곡을 연주할 수 있는 볼륨 중 최댓값을 구하는 프로그램을 작성하시오. 모든 곡은 리스트에 적힌 순서대로 연주해야 한다. 입력첫째 줄에 N, S, M이 주어진다. (1 ≤ N ≤ 100, 1 ≤ M ≤ 1000, 0 ≤ S ≤ M) 둘째 줄에는 각 곡이 시작하기 전에 줄 수 있는 볼륨의 차이가 주어진다. 이 값은 1보다 크거나 같고, M보다 작거나 같다. 출력첫째 줄에 가능한 마지막 곡의 볼륨 중 최댓값을 출력한다. 만약 마지막 곡을 연주할 수 없다면 (중간에 볼륨 조절을 할 수 없다면) -1을 출력한다. 배열 dp에는 index번째 노래를 틀 수 있는 볼륨 배열값을 가진다. dp[0] = [5]dp[1] = [0, 10] 맨마지막 곡을 연주할 수 있는 볼륨 크기 중 가장 큰 값을 출력하도록 했다.console.log(dp[n].length &gt; 0 ? Math.max(...dp[n]) : -1) BUT!!!! 아래와 같이 구현하면 런타임에러가 나네? function solution2(inputString) { var input = inputString.trim().split(\"\\n\") var conditions = input[0].split(\" \").map(a =&gt; +a) var volumes = input[1].split(\" \").map(a =&gt; +a) //5 3 7 //3 5 10 var n = conditions[0] var start = conditions[1] var max = conditions[2] const dp = new Array(n + 1).fill(null).map(a =&gt; new Array()) dp[0].push(start) for (let i = 0; i &lt; volumes.length; i++) { for (let j = 0; j &lt; dp[i].length; j++) { // 연주할 수 있는 볼륨이면 dp[i+1]에 넣기 if (dp[i][j] + volumes[i] &gt;= 0 &amp;&amp; dp[i][j] + volumes[i] &lt;= max) { dp[i + 1].push(dp[i][j] + volumes[i]) } if (dp[i][j] - volumes[i] &gt;= 0 &amp;&amp; dp[i][j] - volumes[i] &lt;= max) { dp[i + 1].push(dp[i][j] - volumes[i]) } } } console.log(dp[n].length &gt; 0 ? Math.max(...dp[n]) : -1)} 다른 방법!! 핵심 아이디어는 dp[i][x]: i번째 음악을 볼륨 x로 연주할 수 있는가?를 true, false로 저장한다. function solution3(inputString) { var input = inputString.trim().split(\"\\n\") var conditions = input[0].split(\" \").map(a =&gt; +a) var volumes = input[1].split(\" \").map(a =&gt; +a) //5 3 7 //3 5 10 var n = conditions[0] var start = conditions[1] var max = conditions[2] const dp = new Array(n + 1).fill(null).map(a =&gt; new Array(max).fill(false)) // 시작음악은 볼륨 5로 dp[0][start] = true for (let i = 0; i &lt; n; i++) { const changeVolume = volumes[i] for (let j = 0; j &lt;= max; j++) { if (!dp[i][j]) continue // 가능한 볼륨 범위이면 if (j + changeVolume &gt;= 0 &amp;&amp; j + changeVolume &lt;= max) { dp[i + 1][j + changeVolume] = true } if (j - changeVolume &gt;= 0 &amp;&amp; j - changeVolume &lt;= max) { dp[i + 1][j - changeVolume] = true } } } let answer = -1 // 가장 큰 볼륨값을 구하는 것이므로 역순으로 찾아간다! for (let i = max; i &gt;= 0; i--) { if (dp[n][i]) { answer = i break } } console.log(answer)} 2655 문제https://www.acmicpc.net/problem/2655 문제밑면이 정사각형인 직육면체 벽돌들을 사용하여 탑을 쌓고자 한다. 탑은 벽돌을 한 개씩 아래에서 위로 쌓으면서 만들어 간다. 아래의 조건을 만족하면서 가장 높은 탑을 쌓을 수 있는 프로그램을 작성하시오. 벽돌은 회전시킬 수 없다. 즉, 옆면을 밑면으로 사용할 수 없다.밑면의 넓이가 같은 벽돌은 없으며, 또한 무게가 같은 벽돌도 없다.벽돌들의 높이는 같을 수도 있다.탑을 쌓을 때 밑면이 좁은 벽돌 위에 밑면이 넓은 벽돌은 놓을 수 없다.무게가 무거운 벽돌을 무게가 가벼운 벽돌 위에 놓을 수 없다. 입력첫째 줄에는 입력될 벽돌의 수가 주어진다. 입력으로 주어지는 벽돌의 수는 최대 100개이다. 둘째 줄부터는 각 줄에 한 개의 벽돌에 관한 정보인 벽돌 밑면의 넓이, 벽돌의 높이 그리고 무게가 차례대로 양의 정수로 주어진다. 각 벽돌은 입력되는 순서대로 1부터 연속적인 번호를 가진다. 벽돌의 넓이, 높이 무게는 10,000보다 작거나 같은 자연수이다. 출력탑을 쌓을 때 사용된 벽돌의 수를 빈칸없이 출력하고, 두 번째 줄부터는 탑의 가장 위 벽돌부터 가장 아래 벽돌까지 차례로 한 줄에 하나씩 벽돌 번호를 빈칸없이 출력한다. function solution(stringInput) { var input = stringInput.trim().split(\"\\n\") const n = parseInt(input[0]) const boxes = input.slice(1).map(a =&gt; a.split(\" \").map(a =&gt; +a)) boxes.forEach((a, i) =&gt; a.push(i + 1)) boxes.sort((a, b) =&gt; a[0] - b[0]) // n개 상자를 쌓았을 때의 최대높이 const dp = new Array(n).fill(0) // 각 상자의 높이로 초기화 for (let i = 0; i &lt; n; i++) { dp[i] = boxes[i][1] } for (let i = 1; i &lt; n; i++) { for (let j = 0; j &lt; i; j++) { // 무게가 더 크면 if (boxes[j][2] &lt; boxes[i][2]) { dp[i] = Math.max(dp[i], boxes[i][1] + dp[j]) } } } let max = Math.max(...dp) let answer = [] for (let i = dp.length - 1; i &gt;= 0; i--) { if (max == dp[i]) { answer.push(boxes[i][3]) max -= boxes[i][1] } } // console.log(\"answer\", answer) console.log(answer.length) answer.reverse() answer.forEach(a =&gt; console.log(a))}","link":"/2020/02/07/Programming/Algorithm/dp-core/"},{"title":"스택/큐 - 기능개발","text":"문제프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 1. 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 2. 작업 진도는 100 미만의 자연수입니다. 3. 작업 속도는 100 이하의 자연수입니다. 4. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다.풀이 과정먼저 각 기능별로 완료까지 걸리는 일수를 구한다.done배열을 forloop을 돌리면서 첫 번째 값부터 larger값과 비교해서 larger보다 같거나 작으면 answer[answer.length - 1]++ 이렇게 원래있던 값에 +1을 해주고 아니면 answer[answer.length] = 1 새로운 값을 넣어준다. 나의 풀이function solution(progresses, speeds) { var answer = [] const done = [] progresses.forEach((progress, index) =&gt; { const days = Math.ceil((100 - progress) / speeds[index]) done.push(days) }) let larger for (let i = 0; i &lt; done.length; i++) { if (larger &gt;= done[i]) { answer[answer.length - 1]++ } else { larger = done[i] answer[answer.length] = 1 } } return answer}","link":"/2019/12/02/Programming/Algorithm/feature-develop/"},{"title":"[LeetCode] Unique Number of Occurrences","text":"문제소문자로 이루어진 문자열 배열 A가 주어졌을 때, 모든 문자열에 등장하는 문자의 리스트를 리턴하세요. 중복도 포함해서. Example 1:Input: [“bella”,”label”,”roller”]Output: [“e”,”l”,”l”] Example 2:Input: [“cool”,”lock”,”cook”]Output: [“c”,”o”] Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] is a lowercase letter출처 - https://leetcode.com/problems/find-common-characters/ 풀이과정먼저 가장 짧은 길이의 문자열을 { &quot;b0&quot;: 1, &quot;e1&quot;: 1, &quot;l2&quot;: 1, &quot;l3&quot;: 1, &quot;a4&quot;: 1 }이런 식의 object로 만들었다. key는 중복된 문자도 유니크하게 만들기 위해 문자+index로 구성했고, 이 때의 값은 등장횟수다.이제 가장 짧은 문자열을 forloop으로 돌면서 그 안에서 주어진 문자열 배열을 forloop으로 돈다. 기준이 되는 가장 짧은 문자는 제외하기 때문에 j=1부터 시작한다. 만약 찾는 문자가 존재한다면 shortestObj[shortest[i] + i] += 1을 통해 등장횟수를 1만큼 더해주고 그 문자가 다시 카운트되지 않도록 array.splice(idx, 1) 문자열에서 삭제한다. 마지막으로, shortestObj의 값이 sorted.length와 같다면 모든 문자열에 등장한 것이므로 그 때의 문자 shortest[i]를 정답 배열에 추가한다. 이 방법은 이중 forloop를 돌아서 효율이 좋진 않다… discuss를 보며 새로운 방법을 찾아봐야할 것 같다. 나의 풀이/** * @param {string[]} A * @return {string[]} */var commonChars = function(A) { const sorted = A.sort((a, b) =&gt; a.length - b.length) // 가장 짧은 스트링 찾기 const shortest = sorted[0] const shortestObj = {} for (let i = 0; i &lt; shortest.length; i++) { shortestObj[shortest[i] + i] = 1 } for (let i = 0; i &lt; shortest.length; i++) { const value = shortest[i] for (let j = 1; j &lt; sorted.length; j++) { const array = sorted[j].split(\"\") const idx = array.indexOf(value) if (idx &gt; -1) { shortestObj[shortest[i] + i] += 1 array.splice(idx, 1) sorted[j] = array.join(\"\") } } } let answer = [] for (let i = 0; i &lt; shortest.length; i++) { if (shortestObj[shortest[i] + i] === sorted.length) { answer.push(shortest[i]) } } return answer} 더 공부할 내용 : splice의 정확한 사용법https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice","link":"/2019/12/15/Programming/Algorithm/find-common-characters/"},{"title":"[백준] 다익스트라 핵심 유형 문제풀이","text":"10282 문제다익스트라 알고리즘은 도로 교통망 같은 곳에서 나타날 수 있는 그래프에서 꼭짓점 간의 최단 경로를 찾는 알고리즘이다. 10282문제는 다익스트라 알고리즘을 구현하면 해결된다. https://www.acmicpc.net/problem/10282 const input = params.split(\"\\n\")const caseCount = parseInt(input.shift())for (let i = 0; i &lt; caseCount; i++) { const conditions = input .shift() .split(\" \") .map(a =&gt; +a) const n = conditions[0], d = conditions[1], startNode = conditions[2] const map = setGraph(input.splice(0, d), d) // 해당 컴퓨터까지의 최단거리 기록 const distances = new Array(n + 1).fill(Infinity) bfs(startNode, map, distances) const virus = distances.filter(a =&gt; a != Infinity) console.log(virus.length, Math.max(...virus))}// 최단거리...다익스트라 알고리즘에서는 visited를 체크 Xfunction bfs(startNode, graph, distances) { // node 정보, 해당 노드까지의 최단거리를 q에 넣는다. // 우선순위 큐 : 무조건 FIFO이 아니라 우선순위가 높은 순부터 (여기서는 최단거리순으로) const q = [[0, startNode]] q.sort((a, b) =&gt; a[0][0] - b[0][0]) distances[startNode] = 0 while (q.length &gt; 0) { const [dist, node] = q.shift() // 최단거리보다 현재 dist가 크면 무시 if (distances[node] &lt; dist) continue const new_nodes = graph.get(node) for (let i in new_nodes) { const element = new_nodes[i] const cost = dist + element[1] // 새로운 최단거리가 나타나면 if (distances[element[0]] &gt; cost) { distances[element[0]] = cost q.push([cost, element[0]]) } } }}function setGraph(inputs, d) { const graph = new Map() for (let j = 0; j &lt; d; j++) { const element = inputs[j].split(\" \").map(a =&gt; +a) // console.log(\"element\", element) const node = element[0], value = element[2] if (graph.get(element[1])) { graph.get(element[1]).push([node, value]) } else { graph.set(element[1], [[node, value]]) } } return graph} setGraph함수를 아래와 같이 하면 시간초과난다.두 값을 저장할 때 object로 관리하는 것보다 배열로 관리하는 게 낫다. function setGraph(input, d) { const map = new Map() for (let j = 0; j &lt; d; j++) { const element = input .shift() .split(\" \") .map(a =&gt; +a) if (map.get(element[1])) { map.get(element[1]).push({ node: element[0], value: element[2] }) } else { map.set(element[1], [{ node: element[0], value: element[2] }]) } } return map} 5719 문제https://www.acmicpc.net/problem/5719 처음에 생각했던 방법다익스트라 알고리즘에서 최단거리만 저장하던 것을 모든 거리를 배열로 저장해 그 중 2번째로 큰값을 리턴하는 방법 =&gt; 하지만 이 방법은 메모리초과 인터넷을 찾아보니 거의 최단거리의 풀이법이 있더라.다익스트라를 두 번 하는 방법으로첫번째 다익스트\b라 돌린 결과 중 최단거리에 속하는 경로를 제외하고 다시 다익스트라를 돌리는 방법이다. ==&gt; 햐….왜 런타임 오류가 뜨냐… node 에서 실행시킬 때는 문제없이 답이 나오는데 BOJ에서는 런타임 오류가 뜬다.BOJ에서 node.js 버전이 es5이다보니 https://es6console.com/ 을 통해서 es6 -&gt; es5로 변환해서 코드를 제출하는데 여기서 뭔가 잘못된걸까? 정말 힘들게 하네;;; // 제출한 답function setGraph(pairs) { const inputs = pairs.map(a =&gt; a.split(\" \").map(a =&gt; +a)) const graph = new Map() const reverseGraph = new Map() // 0 1 1 for (let i = 0; i &lt; inputs.length; i++) { const element = inputs[i] const key = element[0], node = element[1], value = element[2] if (graph.has(key)) { graph.get(key).push([node, value]) } else { graph.set(key, [[node, value]]) } if (reverseGraph.has(node)) { reverseGraph.get(node).push([key, value]) } else { reverseGraph.set(node, [[key, value]]) } } return [graph, reverseGraph]}function dijkstra(startNode, distance, adjList, dropped) { const heap_data = [] heap_data.push([0, startNode]) distance[startNode] = 0 while (heap_data.length &gt; 0) { const [dist, now] = heap_data.shift() if (distance[now] &lt; dist) continue adjList.get(now) &amp;&amp; adjList.get(now).forEach(element =&gt; { // console.log(\"element\", element) const cost = dist + element[1] // dropped : 최단거리 제외 if (distance[element[0]] &gt; cost &amp;&amp; !dropped[now][element[0]]) { distance[element[0]] = cost heap_data.push([cost, element[0]]) } }) }}function bfs(endNode, startNode, reverseAdjList, distance, dropped) { const q = [] q.push(endNode) while (q.length &gt; 0) { const now = q.shift() if (now === startNode) continue reverseAdjList.get(now).forEach(element =&gt; { const [prev, cost] = element if (distance[now] === distance[prev] + cost) { dropped[prev][now] = true q.push(prev) } }) }}function solution(inputString) { const inputs = inputString.split(\"\\n\") for (let i = 0; i &lt; inputs.length; i++) { const condition = inputs.splice(0, 1).map(a =&gt; a.split(\" \").map(a =&gt; +a))[0] const condition2 = inputs.splice(0, 1).map(a =&gt; a.split(\" \").map(a =&gt; +a))[0] const N = condition[0] // 장소수 const M = condition[1] // 도로수 const startNode = condition2[0] const endNode = condition2[1] const pairs = inputs.splice(0, M) const [graph, reverseGraph] = setGraph(pairs) const distance = new Array(N + 1).fill(undefined).map(u =&gt; Infinity) const dropped = new Array(N + 1).fill(undefined).map(u =&gt; new Array(N + 1).fill(false)) dijkstra(startNode, distance, graph, dropped) bfs(endNode, startNode, reverseGraph, distance, dropped) const newdistance = new Array(N + 1).fill(undefined).map(u =&gt; Infinity) dijkstra(startNode, newdistance, graph, dropped) console.log(newdistance[endNode] != Infinity ? newdistance[endNode] : -1) }}solution(`7 90 60 1 10 2 10 3 20 4 31 5 22 6 43 6 24 6 45 6 14 60 20 1 11 2 11 3 13 2 12 0 33 0 26 80 10 1 10 2 20 3 32 5 33 4 24 1 15 1 13 0 10 0`) [참고] 처음 접근했던 방법 function solution(inputString) { const inputs = inputString.split(\"\\n\") for (let i = 0; i &lt; inputs.length; i++) { const condition = inputs.splice(0, 1).map(a =&gt; a.split(\" \").map(a =&gt; +a))[0] const condition2 = inputs.splice(0, 1).map(a =&gt; a.split(\" \").map(a =&gt; +a))[0] const N = condition[0] // 장소수 const M = condition[1] // 도로수 const startNode = condition2[0] const endNode = condition2[1] const pairs = inputs.splice(0, M) const graph = setGraph(pairs) const distance = new Array(N + 1).fill(undefined).map(u =&gt; []) const visited = new Array(N).fill(undefined).map(u =&gt; false) dijkstra(startNode, graph, distance, endNode, visited) const min = distance[endNode].sort()[0] const answer = distance[endNode].filter(a =&gt; a &gt; min) console.log(answer[0] ? answer[0] : -1) }}function dijkstra(startNode, graph, distance, endNode, visited) { // 우선순위 큐 사용. const heap_data = [] visited[startNode] = true heap_data.push([[0], startNode]) // sort heap_data.sort((a, b) =&gt; a[0][1] - b[0][1]) // distance 배열에 각 index별로 도달할 수 있는 모든 cost를 저장 distance[startNode].push(0) while (heap_data.length &gt; 0) { const [distArray, now] = heap_data.shift() // 충분히 다 돌고 가야해 if (now === endNode &amp;&amp; visited.slice(1).every(a =&gt; a === true)) { break } // 만약 지금까지 찾은 최단경로보다 더 짧은 경우가 있다면 // 현재의 정점을 꺼내, 그 정점과 연결된 모든 정점과의 거리 확인 if (graph.get(now)) { distArray.forEach(dist =&gt; { graph.get(now).forEach(element =&gt; { // [node , cost] cost = dist + element[1] distance[element[0]].push(cost) visited[element[0]] = true heap_data.push([distance[element[0]], element[0]]) }) }) } }}","link":"/2020/01/20/Programming/Algorithm/graph-core-2/"},{"title":"[백준] BFS / DFS 핵심유형 문제풀이","text":"2606 문제 - 바이러스문제신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다. 예를 들어 7대의 컴퓨터가 &lt;그림 1&gt;과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다. 어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오. 입력첫째 줄에는 컴퓨터의 수가 주어진다. 컴퓨터의 수는 100 이하이고 각 컴퓨터에는 1번 부터 차례대로 번호가 매겨진다. 둘째 줄에는 네트워크 상에서 직접 연결되어 있는 컴퓨터 쌍의 수가 주어진다. 이어서 그 수만큼 한 줄에 한 쌍씩 네트워크 상에서 직접 연결되어 있는 컴퓨터의 번호 쌍이 주어진다. 출력1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다. https://www.acmicpc.net/problem/2606 시작 정점에서 도달할 수 있는 모든 정점들의 갯수를 구하는 문제이다.dfs든 bfs든 정점의 갯수를 구하면 된다. function solution(params) { const input = params.split(\"\\n\") const computer_count = parseInt(input.shift()) const edge_count = parseInt(input.shift()) const pairs = input.map(a =&gt; a.split(\" \").map(a =&gt; Number(a))) // console.log(computer_count, edge_count, pairs) const graph = setGraph(pairs) const visited = new Array(computer_count).fill(false) let count = 0 dfs(1) console.log(count) function dfs(startNode) { const new_nodes = graph.get(startNode) visited[startNode] = true for (let i = 0; i &lt; new_nodes.length; i++) { const node = new_nodes[i] if (node &lt;= 100 &amp;&amp; !visited[node]) { count++ // console.log(node) dfs(node) visited[node] = true } } } function setGraph(pairs) { const map = new Map() for (let i = 0; i &lt; pairs.length; i++) { const node = pairs[i] if (map.get(node[0])) { map.get(node[0]).push(node[1]) } else { map.set(node[0], [node[1]]) } if (map.get(node[1])) { map.get(node[1]).push(node[0]) } else { map.set(node[1], [node[0]]) } } // console.log(map) return map }}solution(`761 22 31 55 25 64 7`) 1012 문제 - 유기농 배추문제차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. (한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있다고 간주한다) 한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. (0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.) 1 1 0 0 0 0 0 0 0 00 1 0 0 0 0 0 0 0 00 0 0 0 1 0 0 0 0 00 0 0 0 1 0 0 0 0 00 0 1 1 0 0 0 1 1 10 0 0 0 1 0 0 1 1 1 입력입력의 첫 줄에는 테스트 케이스의 개수 T가 주어진다. 그 다음 줄부터 각각의 테스트 케이스에 대해 첫째 줄에는 배추를 심은 배추밭의 가로길이 M(1 ≤ M ≤ 50)과 세로길이 N(1 ≤ N ≤ 50), 그리고 배추가 심어져 있는 위치의 개수 K(1 ≤ K ≤ 2500)이 주어진다. 그 다음 K줄에는 배추의 위치 X(0 ≤ X ≤ M-1), Y(0 ≤ Y ≤ N-1)가 주어진다. 출력각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다. https://www.acmicpc.net/problem/1012 그래프 자료구조가 몇 개나 나오나? 인접한 노드 묶음이 몇 개인지를 구하면 된다.=&gt; 연결요소를 구하는 문제==&gt; 응용된 문제가 많이 나오는 유형!!!! 좌표를 (0, 0) 하나의 노드로 보고 그래프를 구성하려고 한다.이 노드로부터 나올 수 있는 자식 노드는 아래와 같다. var next_pos_list = [ [now_pos[0] - 1, now_pos[1]], [now_pos[0] + 1, now_pos[1]], [now_pos[0], now_pos[1] - 1], [now_pos[0], now_pos[1] + 1]] 그 중에서 좌표를 벗어나지 않는 노드들 중 isIncluded(input, element) &amp;&amp; !isIncluded(visited, element) &amp;&amp; !isIncluded(q, element) 이 조건을 만족하는 노드들만 탐색할 리스트 q에 넣어줬다. BFS의 방식으로 몇 개의 그래프를 만들 수 있는지 count를 셌다. 하지만,,, 시간초과 뜸.. 다시 생각해봐야겠다. function test(inputString) { var input = inputString.split(\"\\n\") // 2 const caseCount = Number(input[0]) let n = 1 for (let index = 0; index &lt; caseCount; index++) { const conditions = input[n].split(\" \").map(function(a) { return +a }) n++ const pairs = input.slice(n, n + conditions[2]) n = n + conditions[2] solution(pairs, conditions[0], conditions[1]) } function solution(params, maxX, maxY) { // input 하나하나를 하나의 node로 보면? var input = params.map(function(a) { return a.split(\" \").map(function(a) { return +a }) }) var inputLen = input.length var count = 0 var q = [] var visited = [] while (inputLen &gt; 0) { q.push(input[input.length - inputLen]) count++ while (q.length &gt; 0) { var now_pos = q.shift() visited.push(now_pos) inputLen-- var next_pos_list = [ [now_pos[0] - 1, now_pos[1]], [now_pos[0] + 1, now_pos[1]], [now_pos[0], now_pos[1] - 1], [now_pos[0], now_pos[1] + 1] ] next_pos_list.forEach(function(element) { if (element[0] &gt;= 0 &amp;&amp; element[0] &lt; maxX &amp;&amp; element[1] &gt;= 0 &amp;&amp; element[1] &lt; maxY) { if ( isIncluded(input, element) &amp;&amp; !isIncluded(visited, element) &amp;&amp; !isIncluded(q, element) ) { q.push(element) } } }) } } console.log(count) } function isIncluded(array, compairElement) { return !array.every(function(element) { return JSON.stringify(element) != JSON.stringify(compairElement) }) }}test(`210 8 170 01 01 14 24 34 52 43 47 48 49 47 58 59 57 68 69 610 10 15 5`) 1325 문제 - 효율적인 해킹문제해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다. 이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다. 이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오. 입력첫째 줄에, N과 M이 들어온다. N은 10,000보다 작거나 같은 자연수, M은 100,000보다 작거나 같은 자연수이다. 둘째 줄부터 M개의 줄에 신뢰하는 관계가 A B와 같은 형식으로 들어오며, “A가 B를 신뢰한다”를 의미한다. 컴퓨터는 1번부터 N번까지 번호가 하나씩 매겨져 있다. 출력첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다. https://www.acmicpc.net/problem/1325 방향을 가지는 그래프를 만든 후에 각각 어떤 노드에서 시작하는 것이 가장 많은 자식노드를 가지는 지 체크했다.하지만 시간초과 뜸.. 어디를 개선해야할까… 같은 로직으로 파이썬으로 제출하면 통과된다. function solution(params) { const input = params.split(\"\\n\") const conditions = input .shift() .split(\" \") .map(a =&gt; +a) const n = conditions[0] const m = conditions[1] const map = new Map() for (let i = 0; i &lt; m; i++) { const element = input[i].split(\" \").map(a =&gt; +a) if (map.get(element[1])) { map.get(element[1]).push(element[0]) } else { map.set(element[1], [element[0]]) } } // console.log(map) let answer = [] let max = -1 for (let i = 1; i &lt;= n; i++) { const visited = new Array(n + 1).fill(false) // startNode i 에서의 노드 개수 const count = bfs(i, visited) if (count &gt; max) { answer = [i] max = count } else if (count == max) { answer.push(i) } } console.log(answer.join(\" \")) function bfs(startNode, visited) { const q = [startNode] visited[startNode] = true let count = 0 while (q.length &gt; 0) { const node = q.shift() const new_nodes = map.get(node) for (let i in new_nodes) { const element = new_nodes[i] if (!visited[element]) { count++ q.push(element) visited[element] = true } } } return count } // function dfs(startNode, visited) { // visited[startNode] = true // const new_nodes = map.get(startNode) // for (let i in new_nodes) { // const element = new_nodes[i] // if (!visited[element]) { // dfs(element, visited) // visited[element] = true // } // } // }}solution(`5 43 13 24 35 3`)","link":"/2020/01/16/Programming/Algorithm/graph-core/"},{"title":"[백준] BFS / DFS 기본 문제풀이","text":"자료구조 그래프를 이용한 BFS / DFS 알고리즘 문제의 대표적인 유형을 풀어보았다.아직 익숙하지가 않아 BFS, DFS를 어떻게 구현하는지 일일이 찾아보며 해결했다. 1260문제 - DFS와 BFS문제그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다. 입력첫째 줄에 정점의 개수 N(1 ≤ N ≤ 1,000), 간선의 개수 M(1 ≤ M ≤ 10,000), 탐색을 시작할 정점의 번호 V가 주어진다. 다음 M개의 줄에는 간선이 연결하는 두 정점의 번호가 주어진다. 어떤 두 정점 사이에 여러 개의 간선이 있을 수 있다. 입력으로 주어지는 간선은 양방향이다. 출력첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다. https://www.acmicpc.net/problem/1260 bfs와 dfs를 구현하는 기본문제. function solution(inputString) { const input = param.split(\"\\n\") const conditions = input .shift() .split(\" \") .map(a =&gt; +a) const numberOfNodes = conditions[0] const numberOfEdges = conditions[1] const startNode = conditions[2] const graph = setGraph() let nodes = new Array() let visited = new Array(numberOfNodes + 1).fill(false) // dfs : 재귀적으로 dfs(startNode) console.log(nodes.join(\" \")) function dfs(startNode) { // console.log(startNode) nodes.push(startNode) visited[startNode] = true const new_nodes = graph.get(startNode) for (let i = 0; i &lt; new_nodes.length; i++) { const node = new_nodes[i] if (!visited[node]) { dfs(node) } } } nodes = new Array() visited = new Array(numberOfNodes + 1).fill(false) // bfs : q 이용 bfs(startNode) console.log(nodes.join(\" \")) // 너비우선 function bfs(startNode) { const q = [startNode] visited[startNode] = true // console.log(q) while (q.length &gt; 0) { const node = q.shift() nodes.push(node) const new_nodes = graph.get(node) for (let i = 0; i &lt; new_nodes.length; i++) { const new_node = new_nodes[i] if (!visited[new_node]) { q.push(new_node) visited[new_node] = true } } } } function setGraph() { const map = new Map() for (let i = 0; i &lt; numberOfEdges; i++) { const node = input[i].split(\" \").map(a =&gt; +a) if (map.get(node[0])) { map.get(node[0]).push(node[1]) } else { map.set(node[0], [node[1]]) } if (map.get(node[1])) { map.get(node[1]).push(node[0]) } else { map.set(node[1], [node[0]]) } } // sort를 해줘야함 map.forEach(value =&gt; { value.sort() }) return map } 1697문제 - 숨바꼭질문제수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다. 수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오. 입력첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다. 출력수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.https://www.acmicpc.net/problem/1697 bfs에서 depth를 어떻게 계산할 것인가!! function solution(params) { const input = params.split(\" \").map(a =&gt; +a) const startNode = input[0] const endNode = input[1] const MAX = 100000 // 각 노드를 탐색할 때의 depth를 array에 저장해둔다. const countArray = new Array(MAX + 1).fill(0) bfs(startNode) // 10만 미만 function bfs(startNode) { const q = [startNode] countArray[startNode] = 0 while (q.length &gt; 0) { const node = q.shift() if (node == endNode) { console.log(countArray[endNode]) break } const new_nodes = [node - 1, node + 1, 2 * node] for (let i = 0; i &lt; 3; i++) { const elem = new_nodes[i] if (elem &gt;= 0 &amp;&amp; elem &lt;= MAX &amp;&amp; !countArray[elem]) { // depth가 깊어질 때마다 이전 depth + 1 countArray[elem] = countArray[node] + 1 q.push(elem) } } } }}solution(`5 17`)","link":"/2020/01/14/Programming/Algorithm/graph_basic/"},{"title":"탐욕 알고리즘( greedy-algorithm )","text":"불가능한 문제, 즉 빠른 알고리즘 해법이 존재하지 않는 NP-완전 문제를 다루는 법을 배우자 문제 해결이 불가능한지 아닌지 파악하는 법을 배우고, NP-완전 문제에 대한 간략한 해법을 빨리 구할 수 있는 근사 알고리즘도 배우자 아주 간단한 문제 해결 기법의 하나인 탐욕 알고리즘을 공부하자! 수업 시간표 짜기 문제학교에서 되도록 많은 수업을 듣고 싶어한다고 가정하고, 가장 많은 수업을 듣도록 시간표를 짜는 방법은?(수업마다 시간이 일부 겹치기 때문에 모든 수업을 다 들을 수는 없다.) 1. 가장 빨리 끝나는 과목을 고른다. 이 과목이 첫 번째로 신청해야할 과목! 2. 첫 번째 과목이 끝난 후 시작하는 과목 중 가장 빨리 끝나는 수업을 선택!이런 식으로 반복하면 가장 많은 수업을 들을 수 있다. 이것이 바로 탐욕 알고리즘greedy-algorithm!!간단하다!!각각의 단계에서 최적의 수를 찾으면 된다! 국소 최적해locally optimal solution를 찾음으로써 최종적으로는 전역 최적해globally optimal solution를 구하게 된다!! 배낭 채우기 문제물론 탐욕 알고리즘이 항상 올바른 답을 찾는 것은 아니다. 스테레오 $3000 30 lbs 노트북 $2000 20 lbs 기타 $1500 15 lbs 35파운드까지 담을 수 있는 배낭에 넣을 물건의 합을 최대한 크게 하려면? 탐욕 알고리즘을 사용하면,들어갈 수 있는 물건중에서 가장 비싼것을 고르는 것을 반복하면 되는데이 경우에는 30파운드의 스테레오를 넣을 수 있다.총 가치는 3000달러! 하지만, 노트북과 기타를 넣으면 총 35파운드의 배낭에 3500달러의 가치를 담을 수 있다. 1. 탐욕 알고리즘은 올바른 답을 내놓지 못할 수도 있지만, 정답에 상당히 가까운 답을 내놓을 수는 있다.2. 탐욕 알고리즘은 구현이 간단하면서도 보통은 정답에 상당히 가까운 답을 준다! 집합 커버링 문제라디오 쇼를 시작했다고 가정해보자.최대한 적은 수의 방송국 방문하면서 모든 주의 사람들에게 방송을 들려주려면 어떻게 해야할까? (각 방송국마다 커버할 수 있는 지역이 서로 다르고 겹치는 지역도 있다.) 1. 가능한 모든 방송국의 부분 집합을 나열하자. 이것을 멱집합이라고 함.(가능한 부분 집합의 수는 2^n개) * 멱집합 : 어떤 집합의 멱집합(冪集合, 영어: power set)은 그 집합의 모든 부분 집합을 모은 집합 2. 이 부분집합 중에서 50개 주 전체를 커버할 수 있으면서 가장 원소의 수가 적은 부분 집합을 고른다!여기서 문제는 가능한 부분 집합을 계산하는 데 시간이 많이 걸린다. 부분 집합의 수가 2^n이기 때문에 O(2^n) 시간이 걸린다. 이 문제에 대해 충분히 빠른 속도를 가진 알고리즘은 존재하지 않는다. 그렇다면 어떻게 해결할까? 근사 알고리즘이럴 때는 탐욕 알고리즘을 사용하면 된다! 거의 정답과 비슷한 답을 유추한다. 1. 아직 방송하지 않은 지역 중 가장 많은 지역을 방송할 수 있는 방송국을 선택.(이미 방송되고 있는 지역이 일부 포함되어 있어도 상관없음.) 2. 모든 주에 방송이 될 때까지 반복.근사 알고리즘의 성능은 1. 얼마나 빠른가 2. 얼마나 최적해에 가까운가로 판단하는 데 탐욕 알고리즘은 단순해서 실행 속도가 빨라 좋은 선택이라고 할 수 있다. 탐욕 알고리즘의 실행속도는 O(n^2)시간. 코드로 구현해보자.states_needed = new Set([\"mt\", \"wa\", \"or\", \"id\", \"nv\", \"ut\", \"ca\", \"az\"])//set은 리스트와 비슷한데 중복을 허용하지 않는다.// 방송국마다 전파되는 주가 다른다. 해시테이블을 사용.stations = {}stations[\"kone\"] = new Set([\"id\", \"nv\", \"ut\"])stations[\"ktwo\"] = new Set([\"wa\", \"id\", \"mt\"])stations[\"kthree\"] = new Set([\"or\", \"nv\", \"ca\"])stations[\"kfour\"] = new Set([\"nv\", \"ut\"])stations[\"kfive\"] = new Set([\"ca\", \"az\"])// 방문한 방송국 목록final_stations = new Set();while (states_needed.size &gt; 0) { //states_needed이 빌 때까지 best_station = null; //아직 방송되지 않은 주 중에서 가장 많은 주를 커버하고 있는 방송국 states_covered = new Set(); // 이미 방송된 주 for(let ele in stations) { // stations중에서 covered = (union(states_needed, stations[ele])) if(covered.size &gt; states_covered.size) { //많은 주에 방송이 되는 방송국을 찾는다 best_station = ele; states_covered = (covered); } } states_needed = (array_diff(states_needed, states_covered)); //아직 방송이 되지 않은 주에서 해당 방송국이 방송되는 주를 뺀다. final_stations.add(best_station) //방송국리스트에 추가.}console.log(final_stations)function union(a, b) {a = [...a], b=[...b];var tmp={}, res=[];for(var i=0;i&lt;a.length;i++) tmp[a[i]]=1;for(var i=0;i&lt;b.length;i++) tmp[b[i]] +=1;for(var k in tmp) if(tmp[k] ==2 ) res.push(k);return new Set(res);}function array_diff(a, b) { a = [...a], b=[...b]; var tmp={}, res=[]; for(var i=0;i&lt;a.length;i++) tmp[a[i]]=1; for(var i=0;i&lt;b.length;i++) { if(tmp[b[i]]) delete tmp[b[i]]; } for(var k in tmp) res.push(k); return new Set(res);} NP-완전 문제집단 커버링 문제를 해결하려면 가능한 모든 집합을 계산해야한다.이전에 나왔던 외판원 문제도 마찬가지였다.가능한 모든 경로 가운데 최단 경로를 찾기 위해서는 가능한 모든 경로를 계산해야한다(n!). 집단 커버링 문제와 외판원 문제의 공통점!모든 가능한 경우를 다 따져서 최단/최소를 구해야 한다는 것!이런 문제를 NP-완전 문제 NP-complete-problem이라고 한다. 어떤 문제가 NP-완전 문제인지 알 수 있는 방법은?NP-완전 문제인지 파악할 수 있는 쉬운 방법은 없다!!! 다만 몇가지 참고사항이 있다. 1. 항목이 적을 때는 빠르다가 항목이 늘어나면 갑자기 느려진다. 2. &quot;X의 모든 조합&quot;이라고 하면 보통 NP-완전 문제 3. 더 작은 하위 문제로 변환할 수 없어서 X의 가능한 모든 버전을 계산해야한다면 아마도 NP-완전 문제 4. 문제가 수열을 포함하고 풀기 어려우면 NP-완전 문제 5. 만약 문제에 집합이 있고 풀기 어려우면 NP-완전 문제 6. 문제를 집합커버링 문제나 외판원 문제로 재정의할 수 있다면 명백하게 NP-완전 문제8장에서 배운내용1. 탐욕 알고리즘은 전역 최적화를 목표로 하지만, 실제로는 국소 최적화를 한다. 2. NP-완전 문제는 빠른 해답이 알려져 있지 않다. 3. 만약 NP-완전 문제가 주어지면 근사 알고리즘을 쓰는 것이 최선. 4. 탐욕 알고리즘은 작성하기도 쉽고, 빠르기 때문에 좋은 근사 알고리즘.","link":"/2018/05/13/Programming/Algorithm/greedy-algorithm/"},{"title":"너비 우선 탐색(breadth-first-search)","text":"너비 우선 탐색을 사용하면 두 항목간의 최단 경로를 찾을 수 있다. 체커 게임에서 가장 적은 수로 승리할 수 있는 방법을 계산하는 인공지능 맞춤법 검사기(실제 단어에서 가장 적은 개수의 글자를 고쳐서 올바른 단어를 만드는 방법을 찾는다.) 여러분의 네트워크에서 가장 가까운 의사 선생님을 찾기 그래프가 뭘까?X축과 Y축을 가지고 있는 그래프가 맨 먼저 떠올랐다. 하지만 여기서 말하는 그래프가 그 그래프는 아니다! 그래프란 항목들이 서로 어떻게 연결되어 있는지를 모형화한 것!! 그래프는 정점과 간선으로 이루어져 있다.정점은 여러 개의 다른 정점과 이어질 수가 있고, 바로 이어진 정점을 이웃neighbor라고 한다. 위의 그림에서 보면, 알레스는 라마에게 돈을 빚지고 있다.라마와 아디트, 라마와 톰, 톰과 아디트는 서로 이웃이고 알렉스와 아디트는 이웃이 아니다. 너비 우선 탐색너비 우선 탐색은 그래프를 대상으로 하는 다른 종류의 탐색 알고리즘이다.이 알고리즘을 통해 다음 두 가지 질문에 대답할 수 있다. 정점 A에서 정점 B로 가는 경로가 존재하는가?정점 A에서 정점 B로 가는 최단 경로는 무엇인가? 예를 들어서,내 페이스북 친구 중에서 망고 판매상을 찾는 방법은? 먼저 내 친구들 중 망고판매상이 있는지 찾아본다. 내 친구들 중에 없으면 내 친구의 친구목록을 뒤져서 찾는다. 내 친구의 친구 중에도 없으면 내 친구의 친구의 친구목록을 뒤진다. 이런 식으로 망고 판매상을 찾을 때까지 네트워크를 탐색하면 된다! 이러한 알고리즘을 너비 우선 탐색 최단 경로만약 망고 판매상을 하는 나와 가장 가까운 친구를 찾으려면?위의 탐색 순서를 잘 지키면 되겠지!!!내 친구 중에서 망고 판매상이 있으면 굳이 내 친구의 친구목록을 뒤질 필요가 없다. 큐망고 판매상을 찾기 위한 리스트는 “큐”라는 자료구조에 담기는데, “큐”는 마치 버스 정류장 대기줄과 같다.먼저 줄 선 사람이 먼저 버스를 타는 것과 마찬가지로,망고 판매상 탐색리스트에 먼저 들어온 내 친구목록을 먼저 탐색하고 그 다음 내 친구의 친구목록을 탐색하게 된다. 큐는 선입선출(먼저 들어온 것이 먼저 나가고)스택은 후입선출(나중에 들어온 것이 먼저 나간다) 그래프의 구현코드로 그래프를 구현해보자.“ 여러분 -&gt; 밥” 과 같은 관계를 어떻게 표현할까?우리가 앞에서 공부했던 관계를 표시하는 자료구조, 해시테이블을 이용하면 되겠다! graph = {};graph[\"you\"] = [\"alice\", \"bob\", \"claire\"]; graph[&quot;you&quot;]라고 하면 여러분의 모든 이웃을 알 수 있다. 위의 그래프를 코드로 표현해보면, graph = {};graph[\"you\"] = [\"alice\", \"bob\", \"claire\"];graph[\"bob\"] = [\"anuji\", \"peggy\"];graph[\"claire\"] = [\"thom\", \"jonny\"];graph[\"alice\"] = [\"peggy\"];graph[\"peggy\"] = [];graph[\"jonny\"] = [];graph[\"anuji\"] = [];graph[\"thom\"] = []; 돌발퀴즈! 키/값 쌍들을 넣을 때 순서는 중요할까? 중요하지 않다. 해시 테이블은 순서를 가지지 않는다!! 위의 그래프에서 보면, 아누지, 페기, 조니, 톰은 이웃이 없다. 이들을 향하는 화살표는 있어도 이들에게서 다른 이로 나가는 화살표는 없다.이처럼 방향을 가지는 그래프를 방향 그래프directed graph, 방향을 가지지 않는 것을 무방향 그래프undirected graph. 만약, 페기 -&gt; 앨리스, 앨리스 -&gt; 페기 이면 앨리스 - 페기 라고 표현할 수 있고 페기와 앨리스는 서로 이웃이라고 말한다. 알고리즘의 구현정리해보면 아래의 그림과 같다. // concat() : 배열합치기// shift() : 배열의 앞부분에서 데이터를 삭제person_is_seller = (name) =&gt; name[name.length - 1] == \"m\" //사람 이름이 m으로 끝나면 망고판매상이다graph = {};graph[\"you\"] = [\"alice\", \"bob\", \"claire\"];graph[\"bob\"] = [\"anuji\", \"peggy\"];graph[\"claire\"] = [\"thom\", \"jonny\"];graph[\"alice\"] = [\"peggy\"];graph[\"peggy\"] = [];graph[\"jonny\"] = [];graph[\"anuji\"] = [];graph[\"thom\"] = [];search_queue = [];searched = [];search = (name) =&gt; { search_queue = graph[name]; while(search_queue.length &gt; 0) { person = search_queue[0]; search_queue.shift(); if(searched.indexOf(person) &lt; 0) { // 이전에 확인하지 않은 사람만 확인 if (person_is_seller(person)) { console.log(`${person} 망고상이다.`) return true; } else { search_queue = search_queue.concat(graph[person]) searched.push(person); // 확인한 사람 추가. } console.log(\"search_queue, searched\",search_queue, searched) } } return false;}search(\"you\");//결과search_queue, searched [ 'bob', 'claire', 'peggy' ] [ 'alice' ]search_queue, searched [ 'claire', 'peggy', 'anuji', 'peggy' ] [ 'alice', 'bob' ]search_queue, searched [ 'peggy', 'anuji', 'peggy', 'thom', 'jonny' ] [ 'alice', 'bob', 'claire' ]search_queue, searched [ 'anuji', 'peggy', 'thom', 'jonny' ] [ 'alice', 'bob', 'claire', 'peggy' ]search_queue, searched [ 'peggy', 'thom', 'jonny' ] [ 'alice', 'bob', 'claire', 'peggy', 'anuji' ]thom 망고상이다. 실행시간망고 판매상을 찾기 위해서 네트워크 전체를 탐색한다는 것은 모든 정점을 따라 움직인다는 뜻! 실행시간은 최소한 O(간선의 개수)! 그리고, 탐색할 사람을 저장하는 큐도 있다. 여기에는 상수시간, O(1)시간이 걸린다. 이걸 모든 사람에게 적용하면 O(사람의 수)! 따라서 너비 우선 탐색은 O(사람의 수 + 간선의 수), O(V+E)라고 표현한다. 6장에서 배운 내용1. 너비 우선 탐색은 A에서 B로 가는 경로가 있는지 알려준다. 2. 만약 경로가 존재한다면 최단 경로도 찾아준다. 3. 만약 X까지의 최단 경로를 찾는 문제가 있다면 그 문제를 그래프로 모형화해보자. 그리고 너비 우선 탐색으로 문제를 풀자. 4. 방향 그래프는 화살표를 가지며, 화살표 방향으로 관계를 가진다. 5. 무방향 그래프는 화살표가 없고, 둘 간의 상호관계를 나타낸다. 6. 큐는 선입선출 7. 스택은 후입선출 8. 탐색 목록에 추가된 순서대로 사람을 확인해야 한다. 그래서 탐색목록은 큐가 되어야 한다. 그렇지 않으면 최단 경로는 구할 수 없다. 9. 누군가를 확인한 다음에는 두 번 다시 확인하지 않도록 해야한다. 그렇지 않으면 무한반복이 될 수도 있다.","link":"/2018/05/02/Programming/Algorithm/breadth-first-search/"},{"title":"해시 - 베스트앨범","text":"문제스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다.장르 내에서 많이 재생된 노래를 먼저 수록합니다.장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다.노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요. 제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다.풀이과정장르를 key로 하고 고유번호 id와 재생된 횟수 playCount를 프로퍼티로 가지는 객체를 value로 셋팅한다.각 장르별로 재생횟수의 합을 reduce메소드를 사용해서 구하고 재생횟수의 합이 큰순으로 정렬한다.각 장르별로 2곡씩, 만약 장르에 속한 곡이 하나라면 하나의 곡만 배열 answer에 담아준다. 나의 풀이function solution(genres, plays) { var answer = [] const items = {} genres.forEach((genre, i) =&gt; { if (items[genre]) { items[genre].push({ id: i, playCount: plays[i] }) } else { items[genre] = [{ id: i, playCount: plays[i] }] } }) const values = Object.values(items) // order by sum values.sort((a, b) =&gt; { const sumOfB = b.reduce((a, b) =&gt; a + b.playCount, 0) const sumOfA = a.reduce((a, b) =&gt; a + b.playCount, 0) return sumOfB - sumOfA }) values.forEach(value =&gt; { value.sort((a, b) =&gt; b.playCount - a.playCount) answer.push(value[0].id) if (value.length &gt; 1) { answer.push(value[1].id) } }) return answer} 이번에 정리해야할 것reduce메소드의 정확한 용법const sumOfB = b.reduce((a, b) =&gt; a.playCount + b.playCount, 0) 처음에 위와 같이 짰다가 에러가 발생했다. const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue// reducer함수의 첫번째 매개변수는 accumlator(지금까지의 합)이다.// 위에서 playCount의 합을 구하는 것은 아래와 같이 되어야 한다.const sumOfB = b.reduce((a, b) =&gt; a + b.playCount, 0)// 그러면 a에 초기값 0이 셋팅된 후, 그 다음 playCount를 더한 값이 a가 되고...배열b를 전부 다 돌 때까지 반복 [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce pushpush() 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다. [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/push","link":"/2019/11/26/Programming/Algorithm/hash-bestalbum/"},{"title":"[백준] 탐욕 알고리즘 핵심유형 문제 풀이","text":"핵심 유형 문제는 접근하기가 좀 어려웠다. 문제를 해결할 알고리즘을 찾아내기가 어려웠다. 스스로 문제당 1시간정도를 풀어본 후 못 푼 문제들은 서칭을 통해 해결법을 찾았다. 좀 더 탐욕 알고리즘 문제를 많이 접해보고 풀어보고해서 문제 해결능력을 키워야할 것 같다. 2212 문제https://www.acmicpc.net/problem/2212 첫째 줄에 센서의 개수 N(1&lt;=N&lt;=10,000), 둘째 줄에 집중국의 개수 K(1&lt;=K&lt;=1000)가 주어진다.셋째 줄에는 N개의 센서의 좌표가 한 개의 정수로 N개 주어진다. 각 좌표 사이에는 빈 칸이 하나 이상 있으며, 좌표의 절댓값은 1,000,000 이하이다. 이 문제는 문제이해 조차도 못했던 문제다. 센서들을 오름차순으로 정렬하고최대 k개의 영역으로 나누는 것이 문제의 핵심이다.각 센서들 사이의 거리를 구하고거리가 먼 순서대로 k-1개를 제거.남은 거리의 합을 구하면 정답이다. function solution(inputString) { const input = inputString.split(\"\\n\") const n = Number(input[0]) const k = Number(input[1]) const points = input[2] .split(\" \") .map(a =&gt; +a) .sort((a, b) =&gt; a - b) const diffs = [] if (k &lt; n) { for (let i = 0; i &lt; points.length - 1; i++) { const diff = points[i + 1] - points[i] diffs.push(diff) } diffs.sort((a, b) =&gt; b - a) for (let index = 0; index &lt; k - 1; index++) { diffs[index] = 0 } } const sum = diffs.reduce((a, b) =&gt; a + b, 0) console.log(sum)}solution(`621 6 9 3 6 7`) 1461 문제https://www.acmicpc.net/problem/1461 음수 / 양수 모음으로 나눠서 M개씩 책을 옮긴다.가장 먼거리 묶음은 마지막에 옮긴다. (0으로 돌아올 필요가 없으므로)=&gt; 이게 이 문제풀이의 메인 아이디어이다. function solution(inputString) { const input = inputString.split(\"\\n\") const conditions = input[0].split(\" \").map(a =&gt; +a) const n = conditions[0] // 옮겨야하는 책 const m = conditions[1] // 최대 한꺼번에 들 수 있는 책개수 const points = input[1].split(\" \").map(a =&gt; +a) const positives = points.filter(a =&gt; a &gt; 0).sort() const negatives = points.filter(a =&gt; a &lt; 0).sort((a, b) =&gt; a - b) let distance = 0 console.log(positives, negatives) // 그룹핑을 먼저 해볼까 // 한꺼번에 옮길 수 있는 책끼리 묶는다. let groups = [] for (let i = 0; i &lt; positives.length; i++) { if (i % m === 0) { groups.push(positives[i]) } } for (let i = 0; i &lt; negatives.length; i++) { if (i % m === 0) { groups.push(negatives[i]) } } console.log(groups) groups = groups.map(a =&gt; Math.abs(a)).sort((a, b) =&gt; b - a) const max = groups[0] distance = groups.reduce((a, b) =&gt; a + b * 2, 0) distance -= max console.log(distance)}// 가장 먼거리 묶음은 마지막에 (0으로 돌아올 필요가 없으므로)// 음수 / 양수 모음으로 나눠서 M개씩// =&gt; 메인 아이디어solution(`7 2-37 2 -6 -39 -29 11 -28`) 1781 문제https://www.acmicpc.net/problem/1781 처음에는 명시된 deadline까지 풀 수 있는 문제들 중 가장 컵라면을 많이 주는 것을 선택하고,비는 타이밍에 아직 데드라인 지나기 전인 것들을 풀면 컵라면을 더 받을 수 있다라는 아이디어로 구현을 해보았다. 자료구조 Map을 이용해서 데드라인을 key로 하고 얻을 수 있는 컵라면의 갯수를 배열로 value를 셋팅한 뒤, 그것들 중 가장 큰 값을 더하는 식으로 로직을 짰다. 이런 식으로 구현을 하니 아래의 예에서 틀린 값을 도출했다. 내가 짠 로직으로는 deadline 3에서 컵라면 8개 받는 경우를 선택하게 되는데최적해의 경우, deadline 3에서 deadline이 4일까지인 컵라면을 18개 받을 수 있는 문제를 풀고, deadline 4에서 컵라면 12개를 받을 수 있는 문제를 푸는 게 더 많은 컵라면을 받을 수 있게 된다. 95 54 64 123 84 182 102 51 71 14 function solution(inputString) { const input = inputString.split(\"\\n\") const n = Number(input[0]) const pairs = input .slice(1) .map(a =&gt; a.split(\" \").map(a =&gt; +a)) .sort((a, b) =&gt; a[0] - b[0]) let count = 0 let deadlineObj = new Map() // 데드라인 : [받을 수 있는 컵라면 수] for (let i = 0; i &lt; pairs.length; i++) { let elem = pairs[i] if (deadlineObj.get(elem[0])) { deadlineObj.get(elem[0]).push(elem[1]) } else { deadlineObj.set(elem[0], [elem[1]]) } } // 데드라인이 같은 것들 중 보상이 제일 큰 것으로 선택 for (let i = 0; i &lt; n; i++) { if (deadlineObj.get(i + 1)) { let cups = deadlineObj.get(i + 1) let max = Math.max(...cups) let maxIndex = cups.indexOf(max) cups.splice(maxIndex, 1) count += max } } for (let i = 0; i &lt; deadlineObj.size; i++) { // 매핑이 안된 데드라인이 있으면 if (!deadlineObj.get(i + 1)) { deadlineObj.forEach(function(v, k) { // 아직 데드라인이 지나지 않은 것 중에 가장 큰 값으로 if (i + 1 &lt; k) { count += Math.max(...v) } }) } } console.log(count) solution(`95 54 64 123 84 182 102 51 71 14`)} 서칭을 통해 새로운 방법을 찾았다.컵라면의 갯수를 배열 q에 넣는데, 이 배열의 크기가 데드라인 날을 초과하는 경우 최소 원소를 제거하는 식으로 알고리즘을 구현하면 위의 풀이에서 막혔던 예제도 최적해를 구할 수 있게 된다. function solution(inputString) { const input = inputString.split(\"\\n\") const pairs = input .slice(1) .map(a =&gt; a.split(\" \").map(a =&gt; +a)) .sort((a, b) =&gt; a[0] - b[0]) const q = [] // 컵라면의 갯수를 배열 q에 넣는데, 이 배열의 크기가 데드라인을 초과하는 경우 최소원소를 제거한다. let count = 0 for (let i = 0; i &lt; pairs.length; i++) { const elem = pairs[i] q.push(elem[1]) if (elem[0] &lt; q.length) { // 최소 원소 제거 q.sort((a, b) =&gt; a - b) q.splice(0, 1) } } count = q.reduce((a, b) =&gt; a + b, 0) console.log(count)}solution(`71 91 1002 3002 993 1005 1005 999`)solution(`95 54 64 123 84 182 102 51 71 14`)","link":"/2020/01/28/Programming/Algorithm/greedy-core/"},{"title":"해시 테이블(hash table)","text":"가장 유용한 기본 자료구조의 하나인 해시 테이블(hash table)에 대해 공부해보자.이번 장에서는 해시 테이블의 구현방법, 충돌, 해시 함수 등에 대해 배운다.해시 테이블의 내부 구조에 대해 알고 있으면 해시 테이블의 성능을 분석하는 데 도움이 된다. 해시 함수의 소개식료품 가게에서 장부를 통해 상품의 가격을 알 수 있다고 치면,장부가 정렬되지 않은 채로 적혀있다면 일일이 단순 탐색으로 찾아야 하므로 O(n)시간이 걸리고, 정렬이 되어 있다면 이진 탐색으로 O(log n)시간이 걸릴 것이다. 만약, 물건의 값을 다 외우고 있는 사람이 있다면? 물건 이름만 대면 즉시 상품의 가격을 알 수 있을거다. (빅오표기법으로 실행시간을 나타내면 O(1)) 식료품 가게에서 모든 상품의 가격을 알고 있는 점원!!이 사람이 바로 “해시 함수”라고 할 수 있다!! 해시 함수 책에 나온 설명에 의하면 해시 함수는 문자열을 받아서 숫자를 반환하는 함수.위키백과에 따르면 해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 1.해시 함수에는 일관성이 있어햐 한다. 만약 “apple”을 넣었을 때 “4”를 반환한다면 “apple”을 넣을 때마다 반환되는 값은 항상 “4”이어야 한다. 그렇지 않으면 해시 함수로서의 역할을 할 수 없다. 2.다른 단어가 들어가면 다른 숫자가 나와야 한다. 어떤 단어를 넣어도 “1”만 나온다면 좋은 해시 함수가 아니다. 가장 좋은 경우는 서로 다른 단어에 대해 모두 서로 다른 숫자가 나와야 한다. 해시 함수를 통해 각 제품의 가격이 담길 인덱스를 반환받아서 그 위치에 제품 가격을 넣어보자.제품 가격을 담고 있는 해시 테이블을 만들어보면 아래와 같다. const book = {};book[\"apple\"] = 0.67book[\"milk\"] = 1.49book[\"avocado\"] = 1.49console.log(book);//{ apple: 0.67, milk: 1.49, avocado: 1.49 }console.log(book[\"avocado\"]);//1.49 해시 함수와 배열을 합치면 해시 테이블이라는 자료 구조를 얻을 수 있다.배열과 리스트는 직접 메모리를 할당하지만, 해시 테이블은 해시 함수를 사용해서 더 총명하게 어디에 원소를 저장할지 결정한다. 해시 테이블은 해시 맵(hash maps), 맵(maps), 딕셔너리(dictionary), 연관 배열(associative arrays)라고도 불린다. 해시 테이블은 속도가 빠르다!해시 테이블은 키(key)와 값(value)를 가진다.위의 예에서 보면 book[“avocado”]을 통해 바로 아보카도의 가격을 알 수가 있다. 탐색이 필요없다! 해시 테이블을 사용하는 예 해시 테이블로 조회하기 휴대폰의 전화번호부를 생각해보면,사람의 이름과 그 사람에 관련된 전화번호를 추가한다.사람 이름을 입력하면 그 이름과 관련된 전화번호를 알려준다. 해시 테이블이 유용할 때 어떤 것을 다른 것과 연관시키고자 할 때 무언가를 찾아보고자 할 때 중복된 항목을 방지하기 투표소에서 어떤 사람이 투표를 했는가 안 했는가를 판단하기 위해서 배열이나 리스트를 사용하면 긴 목록을 뒤져봐야하지만, 이름을 해시 테이블에 저장하면 해시 테이블에 이름이 있는지, 없는지 즉시 알려준다. voted = {};check_voter = (name) =&gt; { if(voted[name]) console.log(\"이미 투표함\"); else { voted[name] = true; console.log(\"아직 투표전\"); }}check_voter(\"tom\") //아직 투표전check_voter(\"mike\") //아직 투표전check_voter(\"mike\") //이미 투표함 해시 테이블을 캐시로 사용하기캐싱은 작업 속도를 올리는 일반적인 방법이다. 모든 대형 웹사이트는 캐싱을 사용한다.그리고 그 자료는 바로 해시 테이블에 저장된다.캐싱된 자료가 있으면 그 자료를 전송하고 없으면 서버에 요청하는 식으로 사용. 해시 테이블의 장점 어떤 것과 다른 것 사이의 관계를 모형화할 수 있다. 중복을 막을 수 있다. 서버에 작업을 시키지 않고 자료를 캐싱할 수 있다. 충돌해시 테이블의 성능을 이해하려면 우선 충돌에 대해 이해해야 한다. 만약 인덱스 0 위치에 apple의 가격이 할당되어 있었는데 avocado의 가격을 또 넣게 되면… apple의 가격을 덮어쓰게 된다. 이러한 충돌을 해결하기 위해서는 여러가지 방법이 있는데 가장 간단한 방법은 같은 공간에 여러 개의 키를 연결하는 연결 리스트로 만들어 넣는 것! 하지만 위와 같은 해시 테이블 구조에서 만약 A로 시작하는 과일만 엄청나게 많을 경우…결국 linked list를 탐색하는 것과 비슷해져 해시 테이블이 느려지겠다. 해시 함수는 정말 중요하다. 이상적으로는 해시 함수는 키를 해시 테이블 전체에 고르게 할당해야 한다. 만약 연결 리스트가 길어지면 해시 테이블의 속도도 느려진다. 하지만 좋은 해시 함수가 있다면 그런 일은 발생하지 않는다. 성능해시 테이블의 성능을 높히기 위해서는 충돌을 피해야 한다. 그렇기 위해서는 아래와 같은 조건이 필요. 낮은 사용률 좋은 해시 함수 - 해시 테이블의 사용률(load factor) = (해시 테이블에 있는 항목의 수)/(해시 테이블에 있는 공간의 수) - 좋은 해시 함수란? 배열에 값을 고루 분포시키는 함수!!5장에서 배운 내용사실 직접 해시 테이블을 구현할 일은 거의 없을거다. 우리가 사용하는 프로그래밍 언어들이 구현되어 있는 해시 테이블을 제공하기 때문이다.평균적인 경우에 해시 테이블의 성능은 상수 시간이다. 해시 테이블은 속도가 빠르고 자료를 여러 가지로 모형화할 수 있기 때문에 아주 강력한 자료 구조이다! 1. 해시 테이블은 해시 함수와 배열을 결합해서 만든다. 2. 충돌은 나쁘다. 충돌을 줄이는 해시 함수가 있어야 한다. 3. 해시 테이블은 정말 빠른 탐색, 삽입, 삭제 속도를 가진다. 4. 해시 테이블은 어떤 항목과 다른 항목의 관계를 모형화하는 데 좋다. 5. 사용률이 0.7보다 커지면 해시 테이블을 리사이징할 때이다. 6. 해시 테이블은 (웹 서버등에서) 데이터를 캐싱하는 데도 사용된다. 7. 해시 테이블은 중복을 잡아내는 데도 뛰어나다.","link":"/2018/04/29/Programming/Algorithm/hashtable/"},{"title":"[백준] 탐욕 알고리즘 기본 문제 풀이","text":"국소 최적해locally optimal solution를 찾음으로써 최종적으로는 전역 최적해globally optimal solution를 구하게 된다. 이것이 탐욕 알고리즘의 핵심이다. 왜 이름이 탐욕 알고리즘일까 궁금했는데 한번에 뙇!! 이해가 되는 설명글을 발견했다. 예를 들어, 지금은 초코파이를 먹을 수 있지만, 10분 후면 랍스타를 먹을 수 있다.그리디 알고리즘의 경우에는 현재에 최선을 다하기 때문에 초코파이를 먹어버리는 느낌이라고 할 수 있다.그리하여 이름이 탐욕 알고리즘이라고 불리는 것이다.전체를 고려하지 않고 그때그때 더 좋아보이는 쪽을 선택하기 때문에 최종적으로는 그 선택이 최적이라고 확신할 수 없다. (문제에 따라 최적이라고 확신할 수도 있다.)(출처: https://mygumi.tistory.com/121 [마이구미의 HelloWorld]) 탐욕 알고리즘은 문제를 풀기위한 기본적인 알고리즘을 떠올리면 그대로 코드로 구현하면 해결되는 문제가 많다. 기본적인 문제부터 풀어보자. 5585 문제https://www.acmicpc.net/problem/5585 가장 기본적인 탐욕알고리즘이다.화폐단위가 큰 것부터 잔돈을 거슬러주면 최적의 해를 구할 수 있다. function solution(inputString) { const total = Number(inputString) let change = 1000 - total const changes = [500, 100, 50, 10, 5, 1] let count = 0 changes.forEach(element =&gt; { const currCount = parseInt(change / element) change -= currCount * element count += currCount }) console.log(count)}solution(`380`) 1439 문제https://www.acmicpc.net/problem/1439 // 처음 시도한 방법 -&gt; 실패function solution(input) { // 다솜이가 할 수 있는 행동은 S에서 연속된 하나 이상의 숫자를 잡고 모두 뒤집는 것이다. // 그러므로 연속된 0, 1의 갯수를 센다. // 0, 1 중에 작은 값만큼 뒤집으면 문자를 통일할 수 있다. const items = { 0: 0, 1: 0 } for (let i = 1; i &lt; input.length + 1; i++) { const element = input[i] ? input[i] : \"\" // 이전 문자와 현재의 문자가 다를 경우, // 이전문자가 0, 새로운 문자 1 이면 // 연속된 0 count를 +1 해준다. if (input[i - 1] != element) { items[input[i - 1]] += 1 } } console.log(Math.min(...Object.values(items)))}solution(`0001100`)// 문자열을 0, 1로 만든다.// 0, 1별로 연속된 문자열을 갯수를 센다function solution2(input) { let count0 = 0 // 전부 0으로 바꾸는 경우 let count1 = 0 // 전부 1로 바꾸는 경우 if (input[0] == \"1\") { count0 += 1 } else { count1 += 1 } for (let i = 1; i &lt; input.length; i++) { if (input[i] != input[i - 1]) { // 다음수가 1로 바뀌는 경우 if (input[i] == \"1\") { count0 += 1 } else { // 다음수가 0으로 바뀌는 경우 count1 += 1 } } } // 두 케이스 중에 작은 값을 출력한다. console.log(Math.min(count0, count1))} 2012 문제https://www.acmicpc.net/problem/2012 처음에 접근한 방법은 기대점수를 오름차순으로 정렬한 후, 중복된 기대등수와 기대등수에 나오지 않은 등수의 차이의 합을 구하는 방법으로 접근했다. 다른 테스트케이스에 걸렸는지 틀렸다! 그냥 단순히 기대 등수를 오름차순으로 정렬한 후, 실제 등수와 비교한 값의 차이의 합을 구해주니 문제가 해결되었다. function solution(inputString) { const inputs = inputString.split(\"\\n\").map(a =&gt; +a) const n = inputs[0] const scores = inputs.slice(1).sort() const occupied = new Array(n).fill(null).map(a =&gt; false) const notMatched = [] const notMatchedIndex = [] let dissatisf = 0 console.log(scores) // 처음 등수를 차지하는 사람이 그 등수를 갖는다. scores.forEach(element =&gt; { if (!occupied[element - 1]) { occupied[element - 1] = true } else { // 매치되지 않은 기대등수 모음 notMatched.push(element) } }) occupied.forEach((element, index) =&gt; { if (!element) { // 매치되지 않은 실제 등수 모음 notMatchedIndex.push(index + 1) } }) // 매치되지 않은 것들간의 차이 합 notMatched.forEach((elem, i) =&gt; { dissatisf += Math.abs(elem - notMatchedIndex[i]) }) console.log(dissatisf)}// 기대 등수를 오름차순으로 정렬한 후, 실제 등수와 비교한 값의 차이의 합function solution2(inputString) { const inputs = inputString.split(\"\\n\").map(a =&gt; +a) const scores = inputs.slice(1).sort() let dissatisf = 0 console.log(scores) scores.forEach((elem, i) =&gt; { dissatisf += Math.abs(elem - i - 1) }) console.log(dissatisf)}solution2(`515312`) 1092 문제https://www.acmicpc.net/problem/1092 function solution(inputstring) { const inputs = inputstring.split(\"\\n\") const n = Number(inputs[0]) const cranes = inputs[1] .split(\" \") .map(a =&gt; +a) .sort((a, b) =&gt; b - a) const box = Number(inputs[2]) const boxes = inputs[3] .split(\" \") .map(a =&gt; +a) .sort((a, b) =&gt; b - a) // 박스 옮겼는지 안 옮겼는지 체크 const checked = new Array(box).fill(undefined).map(a =&gt; false) // 각 크레인이 현재 옮겨야하는 박스 번호 const positions = new Array(n).fill(undefined).map(a =&gt; 0) let time = 0 let count = 0 if (boxes[0] &gt; cranes[0]) { time = -1 count = box } while (true) { if (count === box) { break // 박스 다옮김 } // 매 분마다 모든 크레인에 대하여 옮길 수 있는 박스를 선택하여 옮기도록 한다. for (let i = 0; i &lt; cranes.length; i++) { while (positions[i] &lt; box) { if (!checked[positions[i]] &amp;&amp; cranes[i] &gt;= boxes[positions[i]]) { checked[positions[i]] = true positions[i] += 1 count += 1 break } positions[i] += 1 } } time += 1 } console.log(time)}solution(`36 8 952 5 2 4 7`)// 처음 시도한 접근function solutions2(inputstring) { const inputs = inputstring.split(\"\\n\") const n = Number(inputs[0]) // 내림차순 정렬 const cranes = inputs[1] .split(\" \") .map(a =&gt; +a) .sort((a, b) =&gt; b - a) const box = Number(inputs[2]) // 내림차순 정렬 const boxes = inputs[3] .split(\" \") .map(a =&gt; +a) .sort((a, b) =&gt; b - a) // 박스 무게가 크레인이 들 수 있는 무게보다 크면 -1 if (boxes[0] &gt; cranes[0]) { time = -1 boxes = [] } let time = 0 while (boxes.length &gt; 0) { for (let i = 0; i &lt; cranes.length; i++) { // 첫번째박스가 크레인이 들 수 있으면 들고 아니면 다음번 턴으로 넘긴다. if (boxes[0] &lt;= cranes[i]) { boxes.splice(0, 1) } } time++ } console.log(time)}","link":"/2020/01/21/Programming/Algorithm/greedy-basic/"},{"title":"해시 - 위장","text":"문제스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다.예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름얼굴 동그란 안경, 검정 선글라스상의 파란색 티셔츠하의 청바지겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 1. clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 2. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 3. 같은 이름을 가진 의상은 존재하지 않습니다. 4. clothes의 모든 원소는 문자열로 이루어져 있습니다. 5. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 &apos;\\_&apos; 로만 이루어져 있습니다. 6. 스파이는 하루에 최소 한 개의 의상은 입습니다.풀이과정2차원 배열 clothes을 받아서 Object의 프로퍼티를 이용해서 key, value값을 세팅헸다.의상종류를 key로 하고 의상 이름을 배열에 추가하여 value로 했다.의상종류별로 선택할 수 있는 경우의 수가 의상갯수 + 1 (입지않을 경우의 수 추가)가 된다. 그러므로 의상종류 별로 경우의 수를 구해 곱한 다음 의상을 하나도 걸치지 않았을 경우 1를 빼주면 된다. 나의 풀이function solution(clothes) { var answer = 1 const obj = {} clothes.forEach(element =&gt; { if (obj[element[1]]) { obj[element[1]].push(element[0]) } else { obj[element[1]] = [element[0]] } }) var objKeyArr = Object.keys(obj) for (let i = 0; i &lt; objKeyArr.length; i++) { const value = obj[objKeyArr[i]].length answer = (value + 1) * answer } return answer - 1}","link":"/2019/11/25/Programming/Algorithm/hash-camouflage/"},{"title":"해시테이블 구현","text":"제일 간단한 형태의 해시테이블을 코드로 구현해보면 아래와 같다. 해시테이블의 크기를 임의로 10이라고 설정. 가장 간단한 해시테이블 구현class HashTable { constructor() { this.storageLimit = 10 this.table = new Array(this.storageLimit) } // data -&gt; index getHash(data) { let hash = 0 for (let i = 0; i &lt; data.length; i++) { /* charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수 */ hash += data.charCodeAt(i) } console.log(\"hash\", hash) return hash % this.storageLimit } /* data 와 value를 넣으면, 해당 data에 대한 key를 찾아서 해당 key에 대응하는 해쉬주소에 value를 저장 */ add(data, value) { const index = this.getHash(data) this.table[index] = value } get(data) { const index = this.getHash(data) return this.table[index] } remove(data) { const index = this.getHash(data) delete this.table[index] }}const hashTable = new HashTable()hashTable.add(\"john\", \"111222333\")hashTable.add(\"dave\", \"222333444\")hashTable.add(\"stella\", \"333444555\")hashTable.add(\"mike\", \"444555666\")console.log(hashTable.table)/* [ &lt;1 empty item&gt;, '111222333', '444555666', &lt;2 empty items&gt;, '333444555', '222333444', &lt;3 empty items&gt; ] */ 해시테이블의 장단점해시테이블은 (충돌이 없다고 가정할 경우) 읽기, 쓰기에 대한 시간복잡도가 O(1)로 데이터 저장/읽기 속도가 매우 빠르다. 그래서 검색 속도도 빠르고 데이터의 중복 확인도 쉽다.반면 일반적으로 저장공간이 좀 더 많이 필요하다는 단점이 있다. 또 해시충돌이 있을 경우 이를 해결하기 위한 별도의 자료구조가 필요하다는 점도 단점이다. 해시테이블의 주요 용도 검색이 많이 필요한 경우 저장, 삭제, 읽기가 빈번한 경우 캐쉬 구현시 (중복 확인이 쉽기 때문) 해시테이블의 가장 큰 문제는 충돌(Collision)의 경우다. 해시충돌을 어떻게 해결할 것인가? 충돌이 일어나면, 링크드 리스트라는 자료 구조를 사용해서, 링크드 리스트로 데이터를 추가로 뒤에 연결시켜서 저장하는 방식으로 해결을 해보았다.위의 코드에서 add, get, remove 함수를 변형했다. 해시충돌 해결한 해시테이블 구현class HashTable { constructor() { this.storageLimit = 10 this.table = new Array(this.storageLimit) } // data -&gt; index getHash(data) { let hash = 0 for (let i = 0; i &lt; data.length; i++) { // charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수 hash += data.charCodeAt(i) } return hash % this.storageLimit } // data 와 value를 넣으면, 해당 data에 대한 key를 찾아서, 해당 key에 대응하는 해쉬주소에 value를 저장 add(data, value) { const index = this.getHash(data) // 이미 해당 index에 데이터 존재 if (this.table[index]) { for (let i = 0; i &lt; this.table[index].length; i++) { if (this.table[index][i][0] === data) { this.table[index][i][1] = value return } } this.table[index].push([data, value]) } else { this.table[index] = [[data, value]] } } get(data) { const index = this.getHash(data) if (this.table[index]) { for (let i = 0; i &lt; this.table[index].length; i++) { if (this.table[index][i][0] === data) { return this.table[index][i][1] } } return null } else { return null } } remove(data) { const index = this.getHash(data) if (this.table[index].length === 1 &amp;&amp; this.table[index][0][0] === data) { delete this.table[index] } else { for (let i = 0; i &lt; this.table[index].length; i++) { if (this.table[index][i][0] === data) { this.table[index].splice(i, 1) } } } }}const hashTable = new HashTable()// 일부러 충돌이 나는 data를 입력했다. evad, davehashTable.add(\"evad\", \"111222333\")hashTable.add(\"dave\", \"222333444\")hashTable.add(\"stella\", \"333444555\")hashTable.add(\"mike\", \"444555666\")console.log(hashTable.table)/* [ &lt;2 empty items&gt;, [ [ 'mike', '444555666' ] ], &lt;2 empty items&gt;, [ [ 'stella', '333444555' ] ], [ [ 'evad', '111222333' ], [ 'dave', '222333444' ] ], &lt;3 empty items&gt; ] */console.log(hashTable.get(\"dave\"))// 222333444hashTable.remove(\"evad\")console.log(hashTable.table)/* [ &lt;2 empty items&gt;, [ [ 'mike', '444555666' ] ], &lt;2 empty items&gt;, [ [ 'stella', '333444555' ] ], [ [ 'dave', '222333444' ] ], &lt;3 empty items&gt; ] */ 시간 복잡도일반적인 경우(Collision이 없는 경우)는 O(1)최악의 경우(Collision이 모두 발생하는 경우)는 O(n)해쉬 테이블의 경우, 일반적인 경우를 기대하고 만들기 때문에, 시간 복잡도는 O(1) 이라고 말할 수 있다. 만약 해시테이블의 사이즈를 크게하면 충돌이 일어날 가능성이 줄어든다. 대신 공긴의 효율성이 떨어지겠지만.저장할 데이터의 크기에 따라 적당한 해시테이블의 사이즈를 셋팅하는 것도 중요하겠다. 검색에서 해쉬 테이블의 사용 예16개의 배열에 데이터를 저장하고, 검색할 때 O(n)16개의 데이터 저장공간을 가진 위의 해쉬 테이블에 데이터를 저장하고, 검색할 때 O(1) 이렇게 자바스크립트로 해시테이블을 구현해봤다.이제 해시테이블 관련한 문제를 많이 풀어봐야겠다!","link":"/2019/12/25/Programming/Algorithm/hash-table-implement/"},{"title":"스택/큐 - 쇠막대기","text":"문제여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다. - 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다. - 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다. - 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다.아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다. (a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 &apos;()&apos;으로 표현합니다. 또한 모든 &apos;()&apos;는 반드시 레이저를 표현합니다. (b) 쇠막대기의 왼쪽 끝은 여는 괄호 &apos;(&apos;로, 오른쪽 끝은 닫힌 괄호 &apos;)&apos;로 표현됩니다.위 예의 괄호 표현은 그림 위에 주어져 있습니다.쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다. 쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요. 제한사항 arrangement의 길이는 최대 100,000입니다. arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다.풀이 과정어떻게 풀어야할지 감이 안잡혀 시간을 꽤나 쓴 문제다. 열린괄호와 닫힌괄호 사이에 있는 숫자의 합에 +1을 한 것이 절단한 쇠막대기의 갯수다. 일단 레이저를 뜻하는 ()을 1로 치환하고 forEach문을 돌리기 위해 split(“”)을 통해 배열로 만든다.forloop을 돌면서 ) 을 만나면 역순으로 forloop을 안에서 한번 더 돌린다.1을 만나면 num에 더해준다. 작은 forloop을 돌 때마다 num+1한 값을 answer에 더한다.( 을 만나면 forloop을 빠져나온다. 이미 카운트한 ( 을 str[j] = &quot;|&quot;와 같이 다른 문자로 치환해서 재카운트되지 않도록 한다. 이 문제가 왜 스택/큐 파트로 분류되어 있는지는 잘 모르겠다. 나의 풀이function solution(arrangement) { var answer = 0 const str = arrangement.replace(/\\(\\)/g, 1).split(\"\") console.log(str) const data = [] str.forEach((s, i) =&gt; { if (s === \")\") { // 가장 가까운 ( 을 찾아서 없애기 let num = 0 for (let j = i - 1; j &gt; -1; j--) { if (str[j] === \"1\") { num += Number(str[j]) } else if (str[j] === \"(\") { str[j] = \"|\" break } } answer += num + 1 } }) return answer}","link":"/2019/12/02/Programming/Algorithm/iron-rod/"},{"title":"[LeetCode] insertion-sort-list","text":"문제삽입정렬을 이용해서 링크드리스트를 정렬하세요.출처 - https://leetcode.com/problems/insertion-sort-list/ Algorithm of Insertion Sort:삽입 정렬을 반복하여 반복 할 때마다 하나의 입력 요소를 사용하고 정렬 된 출력 목록을 늘립니다.각 반복에서 삽입 정렬은 입력 데이터에서 하나의 요소를 제거하고 정렬 된 목록 내에서 속하는 위치를 찾아 삽입합니다.입력 요소가 남아 있지 않을 때까지 반복됩니다. Example 1: Input: 4-&gt;2-&gt;1-&gt;3 Output: 1-&gt;2-&gt;3-&gt;4 Example 2: Input: -1-&gt;5-&gt;3-&gt;4-&gt;0 Output: -1-&gt;0-&gt;3-&gt;4-&gt;5풀이 과정주어진 링크드리스트를 배열로 만들어 삽입 정렬 알고리즘을 통해 정렬한 후 배열을 다시 링크드리스트로 만들어 리턴했다.accept는 되었지만… 문제에서 주어진 조건대로 풀지 않았다. 링크드 리스트 그 자체에서 삽입 정렬을 통해 정렬된 링크드리스트를 리턴할 수 있도록 다시 시도해봐야겠다. 나의 풀이/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var insertionSortList = function(head) { let node = head let array = [] while (node) { array.push(node.val) node = node.next } const len = array.length // 두번째인덱스부터 for (let i = 1; i &lt; len; i++) { for (let j = i - 1; j &gt;= 0; j--) { if (array[j] &gt; array[j + 1]) { // swap const temp = array[j] array[j] = array[j + 1] array[j + 1] = temp } } } let answerList = null let answerNode = null for (let i = 0; i &lt; len; i++) { if (answerList) { while (answerNode.next) { answerNode = answerNode.next } answerNode.next = new ListNode(array[i]) } else { answerList = new ListNode(array[i]) answerNode = answerList } } return answerList}","link":"/2019/12/30/Programming/Algorithm/insertion-sort-list/"},{"title":"해시 - 완주하지 못한 선수","text":"앞으로 2달동안 하루에 하나씩이라도 알고리즘 문제를 풀어보자.알고리즘 문제는 프로그래머스에서 얻었다. (https://programmers.co.kr/learn/challenges?tab=algorithm_practice_kit) 1. 문제마라톤에 참여한 선수들 중 단 한명의 선수를 제외하고 모두 마라톤을 완주했다. 마라톤 참여선수 배열 participant과 마라톤 완주선수 배열 completion이 주어졌을 때, 완주하지 못한 선수 한명을 return하는 Solution 함수를 작성하시오. 제한사항 1. 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. 2. completion의 길이는 participant의 길이보다 1 작습니다. 3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 4. 참가자 중에는 동명이인이 있을 수 있습니다.2. 풀이과정participant 배열과 completion 배열을 각각 오름차순으로 정렬한 후 차례대로 이름을 비교해 다른 이름이 발견되면 그 이름의 선수가 마라톤을 완주하지 못한 선수다. 처음에는 participant의 배열을 돌리는데 forEach를 사용하려고 했다. function solution(participant, completion) { var answer = \"\" participant.sort() completion.sort() participant.forEach((item, i) =&gt; { if (item !== completion[i]) { answer = item // 이름이 다른 경우를 발견하고 forEach문을 빠져나오기 return } }) return answer} 위와 같이 코드를 작성하니 participant = [mislav, stanko, mislav, ana]completion = [stanko, ana, mislav] 일 경우에 예외가 발생했다. 그 이유는 forEach문은 중간에 멈출 수가 없다. 그래서 첫번째로 일치하지 않는 mislav 이름을 찾고도 그다음 forloop이 진행되어 answer에 stanko가 담겨 테스트를 통과하지 못했다. [참고]https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach 예외를 던지지 않고는 forEach()를 중간에 멈출 수 없습니다. 중간에 멈춰야 한다면 forEach()가 적절한 방법이 아닐지도 모릅니다. 그래서 forEach대신에 find 메서드를 사용했다. find() 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다. 3. 내가 작성한 코드function solution(participant, completion) { var answer = \"\" participant.sort() completion.sort() answer = participant.find((item, i) =&gt; { return item !== completion[i] }) return answer} 엇, 그런데 해시문제인데 해시를 사용하지 않았다…","link":"/2019/11/24/Programming/Algorithm/hash-no-completion/"},{"title":"[LeetCode] DP 문제 모음","text":"LeetCode에 있는 다이내믹 프로그래밍 문제들을 풀어보았다. 53. Maximum SubarrayGiven an integer array nums, find the contiguous subarray (containing at least one number) which has the largest sum and return its sum. Example: Input: [-2,1,-3,4,-1,2,1,-5,4],Output: 6Explanation: [4,-1,2,1] has the largest sum = 6. Follow up:If you have figured out the O(n) solution, try coding another solution using the divide and conquer approach, which is more subtle. https://leetcode.com/problems/maximum-subarray/ 연속하는 부분 수열의 합 중 가장 큰 합을 리턴하는 문제다.배열 dp에 각 index까지의 부분 수열의 합 중 가장 큰 값을 담아서 그중 가장 큰 값을 리턴하면 된다. /** * @param {number[]} nums * @return {number} */var maxSubArray = function(nums) { const n = nums.length const dp = JSON.parse(JSON.stringify(nums)) for (let i = 1; i &lt; n; i++) { // 해당 index의 값, 이전까지의 합에 해당 index의 값을 더한 값 중 큰 값을 dp[i]에 셋팅한다. dp[i] = Math.max(dp[i], dp[i - 1] + dp[i]) } console.log(dp) return Math.max(...dp)}","link":"/2020/02/07/Programming/Algorithm/leetcode-dp/"},{"title":"[LeetCode] largest-number","text":"문제양의 정수가 리스트로 주어졌을 때, 그 숫자들을 조합해서 만들 수 있는 가장 큰 수를 리턴하시오. Example 1: Input: [10,2] Output: &quot;210&quot; Example 2: Input: [3,30,34,5,9] Output: &quot;9534330&quot;Note: The result may be very large, so you need to return a string instead of an integer. 출처 - https://leetcode.com/problems/largest-number/ 풀이 과정sort함수의 custom comparer를 작성하는 문제이다. 처음에 이 문제에 접근했을 때는 일일이 정수의 첫째자리 비교, 둘째자리 비교를 해서 큰 순서대로 나열하려고 했으나그런 식으로는 답을 도출하기가 어려웠다. sort함수로 크기 비교를 할 때, 앞 뒤 숫자 조합(조합할 때는 문자열로 조합하고, 숫자형으로 변형 후 비교해야한다.) 중 큰 것이 앞으로 오도록 정렬한다.“00”의 경우를 예외처리하고 정렬된 배열을 join(&quot;&quot;) 함수를 통해 하나의 문자열로 합친 후 리턴하면 된다. 나의 풀이/** * @param {number[]} nums * @return {string} */var largestNumber = function(nums) { nums.sort((a, b) =&gt; Number(&quot;&quot;+b+a) - Number(&quot;&quot;+a+b) ) return Number(nums.join(&quot;&quot;)) === 0 ? &quot;0&quot; : nums.join(&quot;&quot;)};","link":"/2020/01/04/Programming/Algorithm/largest-number/"},{"title":"[LeetCode] Maximum Number of Balloons","text":"문제문자열 text가 주어졌을 때, text의 문자를 사용해서 단어 “balloon”을 만들 수 있는 만큼 만들려고 한다.각 문자는 최대 한번만 쓸 수 있다. 최대 몇 개의 balloon을 만들 수 있는지 리턴하세요. Example 1:Input: text = “nlaebolko”Output: 1 Example 2:Input: text = “loonbalxballpoon”Output: 2 Example 3:Input: text = “leetcode”Output: 0 Constraints: 1 &lt;= text.length &lt;= 10^4 text consists of lower case English letters only.출처 - https://leetcode.com/problems/maximum-number-of-balloons 풀이과정balloon의 각 문자열을 key로 하고 value=0으로 셋팅한 balloonObj를 만든다.text의 길이만큼 forloop을 돌면서 balloonObj의 key와 동일한 문자열이 있으면 value를 +1 해준다. balloonObj의 key를 배열로 뽑아내서 key가 l, o 이면 value를 1/2해준다.balloon을 만드는데 l, o는 두개씩 필요하기 때문. 이제 balloonObj의 value값 중 가장 작은 값을 골라 리턴을 하면 우리가 찾는 주어진 text를 이용해 단어 balloon을 만들 수 있는 최대값이다. 나의 풀이/** * @param {string} text * @return {number} */var maxNumberOfBalloons = function(text) { const balloonString = \"balloon\" const balloonObj = {} for (let i = 0; i &lt; balloonString.length; i++) { balloonObj[balloonString[i]] = 0 } for (let j = 0; j &lt; text.length; j++) { if (balloonObj[text[j]] === 0 || balloonObj[text[j]]) { balloonObj[text[j]] += 1 } } const keys = Object.keys(balloonObj) keys.forEach(key =&gt; { if (key === \"l\" || key === \"o\") { balloonObj[key] = Math.floor(balloonObj[key] / 2) } }) console.log(balloonObj) const values = Object.values(balloonObj) return Math.min(...values)}","link":"/2019/12/16/Programming/Algorithm/maximum-number-of-balloons/"},{"title":"코딜리티 MinMaxDivision","text":"코딜리티에서 이분탐색문제 중 MinMaxDivision을 풀어보았다. (문제 출처 https://app.codility.com/programmers/lessons/14-binary_search_algorithm/min_max_division/) 문제를 요약해보면 정수 N개로 이루어진 배열 A를 K조각으로 나눌 때의 부분 배열의 최대합 중 최소값을 구하라는 것이다. N and K are integers within the range [1..100,000];M is an integer within the range [0..10,000];each element of array A is an integer within the range [0..M]. 아이고, 두야… 이 문제로 2시간 가까이 보낸 것 같다. 결국 100%까지는 구현 못하고 91%까지 통과했다. 일단 여기까지 진행된 내용을 기록에 남긴다. 이 문제를 풀 핵심 아이디어는 부분 배열의 합이 될 수 있는 최소값 row = 0, 최대값 high = 배열 A의 총합 을 기준으로 중간값 mid를 구하고, mid를 부분 배열의 최대합으로 하는 부분 배열을 k 개 만들 수 있는지 체크한다. A배열의 부분 배열을 k만큼 만들 수 있거나, k보다 적게 만들 수 있으면mid를 작게해봐야함 -&gt; high를 줄여야한다.반대의 경우 mid를 높여야하므로 row = mid + 1이런 식으로 row &lt; high이면 계속 반복한다. 통과하지 못한 케이스를 보면 제출한 답이 정답과 1씩 차이가 난다… 엣지케이스 처리를 잘못해 준 것 같다. 다시 살펴봐야겠다… function solution(K, M, A) { const sum = A.reduce((a, b) =&gt; a + b, 0) const n = A.length let row = 0, high = sum, mid while (row &lt; high) { mid = parseInt((row + high) / 2) // console.log(row, high) // console.log(\"새로운 mid\", mid) let kCnt = 0 let tempSum = 0 let arrLen = 0 // mid보다 작은 합으로 구성가능한 갯수 세기 for (let i = 0; i &lt; A.length; i++) { if (A[i] &gt; mid) { // 불가능한 최소합, mid 크게, row를 크게 row = mid + 1 break } if (kCnt == K) { break } tempSum += A[i] if (tempSum == mid) { kCnt++ arrLen++ tempSum = 0 } else if (tempSum &gt; mid) { kCnt++ // 이전인덱스로 i-- tempSum = 0 } else { // tempSum &lt; mid arrLen++ continue } } if (arrLen == n) { if (kCnt &lt;= K) { // 최소값을 탐색하기 위해서 더 낮은 mid high = mid } else { row = mid + 1 } } else if (arrLen &lt; n) { // mid up row up row = mid + 1 } else { high = mid } } // console.log(\"answer\", row, mid) return row}// solution(3, 5, [2, 1, 5, 1, 2, 2, 2])// solution(1, 10, [4, 3, 2, 5, 6, 6, 4, 9])solution(2, 10, [4, 4])// ! 맨 마지막 값이 0인 케이스...// solution(1, 10000, [0, 10000, 0])// !10000","link":"/2020/03/06/Programming/Algorithm/minmaxdivision/"},{"title":"링크드 리스트 구현","text":"자료구조를 공부하는 중에 링크드 리스트의 개념이 잘 와닿지 않아 자바스크립트로 링크드 리스트를 구현해봤다. 겨우겨우 구현을 해봤는데 여전히 많이 헷갈린다. (도식화 이미지 정리 필요) class Node { constructor(data) { this.data = data this.next = null }}class LinkedList { constructor() { this._length = 0 this._head = null } // append(데이터): 리스트의 맨 끝에 데이터를 추가한다. append(data) { const item = new Node(data) let node = this._head if (node) { while (node.next) { node = node.next } node.next = item } else { this._head = item } this._length++ } // removeAt(위치): 해당 위치에 있는 데이터를 삭제한다. removeAt(index) { // index가 유효한 값인지 일단 먼저 체크 if (index &gt; -1 &amp;&amp; index &lt; this._length) { let node = this._head let prev = null // 헤드를 삭제하는 경우라면, 그 다음 값을 헤드로 셋팅 if (index == 0) { this._head = node.next this._length-- } else { // 삭제하려는 index-1 값을 찾아서 next를 그 다음 next 값으로 let i = 0 while (i &lt; index) { prev = node node = node.next i++ } prev.next = node.next this._length-- } return node.data } else { return null } } // indexOf(데이터): 해당 데이터의 인덱스를 반환한다. 존재하지 않을 경우 결과 값은 -1이다. indexOf(data) { let curr = this._head let index = 0 while (curr.next) { if (curr.data === data) { return index } curr = curr.next index++ } return -1 } // remove(데이터): 데이터를 삭제한다. remove(item) { let curr = this._head if (!this._head) return \"빈 리스트입니다\" // head일경우 if (curr.data === item) { this._head = curr.next this._length-- } else { while (curr.next) { if (curr.next.data === item) { curr.next = curr.next.next this._length-- break } curr = curr.next } } } // insert(위치, 데이터): 해당 위치에 데이터를 삽입한다. insert(index, item) { // index가 유효한 값인지 일단 먼저 체크 if (index &gt; -1 &amp;&amp; index &lt;= this._length) { let curr = this._head const newNode = new Node(item) let i = 0 // 헤드로 if (index === 0) { this._head = newNode this._head.next = curr this._length++ } else { // 추가하려는 index-1 값을 찾아서 let i = 0 let prev = null while (i &lt; index) { prev = curr curr = curr.next i++ } let nextTemp = prev.next prev.next = newNode newNode.next = nextTemp this._length++ } } else { return null } } // isEmpty(): 데이터가 하나도 없다면 true를, 그 외엔 false를 반환한다. isEmpty() { if (this._length === 0) return true return false } //size(): 데이터 개수를 반환한다. 배열의 length 프로퍼티와 비슷하다. size() { return this._length }} 실행시켜보면 const linked = new LinkedList()linked.append(1)linked.append(2)linked.append(3)linked.append(4)linked.append(5)console.log(linked)/* LinkedList { _length: 5, _head: Node { data: 1, next: Node { data: 2, next: [Node] } }} */linked.insert(3, 7)console.log(JSON.stringify(linked))/* {\"_length\":6,\"_head\":{\"data\":1,\"next\":{\"data\":2,\"next\":{\"data\":3,\"next\":{\"data\":7,\"next\":{\"data\":4,\"next\":{\"data\":5,\"next\":null}}}}}}} */console.log(linked.remove(4))console.log(JSON.stringify(linked))/* {\"_length\":5,\"_head\":{\"data\":1,\"next\":{\"data\":2,\"next\":{\"data\":3,\"next\":{\"data\":7,\"next\":{\"data\":5,\"next\":null}}}}}} */console.log(linked.indexOf(4))/* -1*/","link":"/2019/12/07/Programming/Algorithm/linked-list/"},{"title":"[LeetCode] Middle of the Linked List","text":"문제값이 존재하는 단방향 링크드리스트의 head값이 주어졌을 때, 링크드리스트의 중간 노드를 리턴하시오. 만약 2개의 중간노드가 있다면 두번째 값을 리턴하세요. 출처 - https://leetcode.com/problems/middle-of-the-linked-list/ 풀이 과정링크드리스트는 길이는 리스트를 전부 순회해야지만 알 수 있다.리스트 순회를 통해 리스트의 길이를 알아내고 그 길이의 중간값을 구한다.다시 리스트를 순회해서 그 중간노드를 리턴하면 된다. 나의 풀이/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var middleNode = function(head) { let node = head let length = 1 while (node.next) { node = node.next length++ } let n = Math.floor(length / 2) node = head for (let i = 0; i &lt; n; i++) { node = node.next } return node} 추천 방식내가 전혀 떠올리지 못한 방법 중에 릿코드에서 추천한 2개의 포인터를 이용한 방법이 있다.링크드리스트를 순회를 slow pointer와 그것보다 2배빠른 fast pointer 두 개의 포인터로 하면 fast pointer가 리스트의 마지막에 닿는 순간에 slow pointer는 리스트의 중간에 위치하게 된다. var middleNode = function(head) { let slow, fast = head while (fast &amp;&amp; fast.next) { slow = slow.next fast = fast.next.next } return slow}","link":"/2019/12/08/Programming/Algorithm/middle-of-linkedlist/"},{"title":"스택/큐 - 다리를 지나는 트럭","text":"문제트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다. ※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다. 예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과시간 / 다리를 지난 트럭 / 다리를 건너는 트럭 / 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] []따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 1. bridge_length는 1 이상 10,000 이하입니다. 2. weight는 1 이상 10,000 이하입니다. 3. truck_weights의 길이는 1 이상 10,000 이하입니다. 4. 모든 트럭의 무게는 1 이상 weight 이하입니다.풀이과정다리를 건너고 있는 트럭의 배열을 passing_trucks, 이미 다리를 건넌 트럭의 배열을 passed_trucks이라 정의한다.passing_trucks배열을 forEach문으로 돌면서 truck.count가 bridge_length와 같으면 해당 트럭을 passing_trucks 배열에서 제거해주고 아니면 truck.count++한다.passing_trucks의 weight의 합이 다리가 견딜 수 있는 무게 weight를 넘지 않으면 다리에 트럭을 하나 더 보낸다.이 과정을 passed_trucks배열의 크기가 처음 대기트럭 배열의 크기와 같아질 때까지 반복한다. while문을 반복할 때마다 answer++한다. passing_trucks배열에서 제거해 줄 때 실수했던 부분이처음에는 passing_trucks.splice(index, 1) 이렇게 바로 배열에서 제거했더니 원본 배열 자체가 변경되어 처음 passing_trucks의 길이만큼 forEach문을 충분히 돌지 못했다.그래서 forEach문을 돌 때는 truck.count === bridge_length인 트럭의 인덱스만 저장해뒀다가 forEach문이 끝난 뒤에 passing_trucks에서 제거해주었다. 나의 풀이function solution(bridge_length, weight, truck_weights) { let answer = 0 const passing_trucks = [] const passed_trucks = [] const len = truck_weights.length while (passed_trucks.length &lt; len) { // 브릿지를 다 지났는지 체크 아니면 +1 let passedTruckIndex = null passing_trucks.forEach((truck, index) =&gt; { if (truck.count === bridge_length) { //passing_trucks.splice(index, 1) passedTruckIndex = index passed_trucks.push(truck) } else { truck.count++ } }) if (passedTruckIndex !== null) { passing_trucks.splice(passedTruckIndex, 1) } // 트럭이 더 올라올 수 있으면 passing_trucks에 추가 const first = truck_weights[0] if (sumPassingTrucksWeights(passing_trucks) + first &lt;= weight) { const item = { weight: truck_weights.shift(), count: 1 } passing_trucks.push(item) } answer++ } return answer}function sumPassingTrucksWeights(passing_trucks) { const sum = passing_trucks.reduce((a, b) =&gt; { return a + b.weight }, 0) return sum}","link":"/2019/12/01/Programming/Algorithm/passed-trucks/"},{"title":"스택/큐 - 프린터","text":"문제일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다. 2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다. 3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다.내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 제한사항 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다. 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다. location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다.풀이과정처음에 문제해석을 잘못했다.첫번째 프린트보다 중요도가 큰 게 있으면 바로 중요도가 가장 높은 것을 프린트하는 줄 알고 const index = array.indexOf(biggerOne)array.splice(index, 1) 로 가장 중요도가 높은 프린트물을 배열에서 제거했다. 원래 문제의 조건은 가장 첫번째 프린트물이 가장 중요도가 높지않을 경우, 제일 끝으로 push한다이다.알고리즘 문제를 풀면서 문제의 규칙, 조건들을 잘못 해석하지 않고 제대로 파악하는 것이 중요하겠다. 일단 priorities배열에 같은 중요도의 프린트물도 있으니까 구분을 짓기 위해index와 중요도값을 가지는 data를 맵핑한 배열을 만든다.priorities의 요소 하나하나씩 비교하는 경우의 수 (len * (len - 1))만큼 forloop을 돌린다.첫 번째 요소보다 중요도가 높은 것이 있으면 배열에 shift메소드를 사용해서 첫 요소를 제거하고 push를 통해 제일 마지막에 넣어준다. 그리고 첫번째 요소보다 더 중요도가 높은 것이 없다면 shift를 사용해 배열에서 제거해주고 answer값을 +1해준다. 만약 제거된 아이템이 내가 찾으려던 아이템과 동일하면 forloop을 나온다. 나의 풀이function solution(priorities, location) { var answer = 0 const newpriorities = priorities.map((data, index) =&gt; { return { data, index } }) const myItem = newpriorities[location] const len = newpriorities.length for (let i = 0; i &lt; (len * (len - 1)) / 2; i++) { let firstItem = newpriorities[0] const biggerOne = newpriorities.find(priority =&gt; priority.data &gt; firstItem.data) if (biggerOne) { newpriorities.shift() newpriorities.push(firstItem) } else { newpriorities.shift() answer++ if (firstItem.data === myItem.data &amp;&amp; firstItem.index === myItem.index) { break } } } return answer}","link":"/2019/11/29/Programming/Algorithm/printer/"},{"title":"선택 정렬(selection-sort)","text":"01. 메모리가 동작하는 방법메모리에 무언가를 저장해야 할 때마다 컴퓨터에게 공간의 요청!그러면 컴퓨터는 무언가를 저장할 수 있는 주소를 알려준다. 만약 여러 개의 원소를 저장해야 한다면 배열과 리스트라는 두 가지 방법 중 하나를 사용해야 한다. 02. 배열과 연결 리스트배열 : 여러 개의 원소를 나란히 저장.만약 원소 3개를 가진 배열에 새로운 원소를 하나 추가하려는데 만약 바로 옆자리가 없다면, 컴퓨터에게 4개의 자리가 있는 다른 메모리 공간을 요청하고 4개의 원소를 그 자리로 옮긴다. 연결된 리스트 : 여러 개의 원소를 메모리의 어느 곳에나 둘 수 있다.각 원소에는 목록의 다음 원소에 대한 주소가 저장되어 있다.마치 보물찾기처럼… 첫번째 주소에 가면 “다음 원소는 주소 123에 있다”고 알려주고 주소 123을 찾아가면 “다음 원소는 주소 654에 있다” 이렇게 알려주는 것처럼. 연결된 리스트를 사용하면 원소를 추가하는 일이 쉽다. 그냥 메모리의 아무 곳에나 원소를 넣고, 그 주소를 바로 앞의 원소에 저장해두면 된다. 특정원소를 바로 읽으려면…?!!배열은 모든 원소의 주소를 다 알고 있어서 특정위치의 원소를 바로 읽을 수 있다.연결된 리스트의 경우, 마지막 원소를 읽고싶으면 첫번째 원소부터 차례로 읽어 그 다음 주소를 알아내고, 그 다음을 찾아가고…이렇게해서 마지막 원소를 읽을 수가 있다. 리스트의 가운데 삽입하기에는…?!!리스트의 가운데, 어떤 원소를 삽입할 때는 연결된 리스트를 사용하면 좋다.리스트는 이전 원소가 무엇을 가리키는지 바꾸기만 하면 되니까!!배열같은 경우는 추가된 원소 그 다음에 오는 모든 원소의 위치를 바꿔야한다. 자리가 모자르다면 새로운 장소에 배열의 처음부터 끝까지 옮겨놓아야하니까… 매우 불편하다 삭제할때는…?!!삭제할 때에도 마찬가지로 리스트가 낫다!이전 원소가 가리키는 위치만 바꾸면 되니까!!!배열은 원소 하나만 삭제하고 싶어도 그 뒤에 오는 모든 원소를 다 옮겨야한다. 어떤 자료구조가 더 많이 쓰일까…?!!물론 경우에 따라 다르겠지만 보통 임의 접근이 가능한 배열이 더 자주 쓰인다.배열의 읽기 속도가 빠른 이유는 배열에서는 임의 접근이 가능하기 때문이지요! 배열과 리스트의 연산에 대한 실행시간을 표로 나타내보면 배열에서 읽기는 임의 접근으로 바로 읽을 수 있으니까 O(1),삽입, 삭제의 경우 n개의 원소를 모두 옮겨야하는 경우도 있으므로 O(n)리스트에서 읽기는 n번 만큼 읽어야만 n의 위치를 알 수 있으므로 O(n),삽입, 삭제의 경우 맨처음과 맨마지막 원소에 대해서만 바로 접근하여 추가 혹은 삭제 가능하므로 그 경우에만 O(1)*O(n)시간은 목록의 모든 원소를 한 번씩 건드려야 한다는 뜻! 03. 선택정렬무작위로 정렬된 음악리스트를 많이 들은 순으로 정렬하는 방법은…?!!리스트의 모든 항목을 살펴보고, 많이 들은 순대로 정렬하는 방법!처음에는 n개의 항목을 점검하고 그 다음에는 n-1, n-2, …, 2, 1 로 줄어든다.평균적으로 1/2 _ n번 점검!n _ (1/2 *n) -&gt; 상수는 무시되므로 실행시간은 O(n^2)!! 선택정렬은 깔끔한 알고리즘이지만 빠르지 않다…퀵정렬의 경우 O(n log n) 시간밖에 걸리지 않는다. 파이썬 예제 -&gt; 자바스크립트로 변환해보기findSmallest = (arr) =&gt; { let smallest = arr[0]; let smallest_index = 0; for(let i = 1; i&lt; arr.length; i++) { if(arr[i] &lt; smallest) { smallest = arr[i]; smallest_index = i; } } return smallest_index;}selectionSort = (arr) =&gt; { const newArr = []; for(let i = 0; arr.length; i++) { const smallest_index = findSmallest(arr); const splice = arr.splice(smallest_index, 1); newArr.push(splice[0]); } return newArr;}console.log(selectionSort([5, 3, 6, 2, 10])); 2장에서 배운 내용1. 컴퓨터 메모리는 거대한 서랍장과 같다. 2. 여러 개의 항목을 저장하고 싶을 때는 배열이나 리스트를 사용하세요. 3. 배열을 쓰면 모든 항목을 이웃하는 위치에 저장한다. 4. 리스트를 쓰면 모든 항목이 흩어지지만, 각 항목은 다음 항목의 주소를 저장하고 있다. 5. 배열은 읽기가 빠르다. 6. 연결 리스트는 삽입과 삭제가 빠르다. 7. 배열의 모든 원소는 같은 자료형(예를 들면, 모두 정수형이거나 모두 실수형)이어야 한다.","link":"/2018/04/12/Programming/Algorithm/selection-sort/"},{"title":"힙(Heap) 구현","text":"힙 (Heap) 이란?힙: 데이터에서 최대값과 최소값을 빠르게 찾기 위해 고안된 완전 이진 트리(Complete Binary Tree)완전 이진 트리: 노드를 삽입할 때 최하단 왼쪽 노드부터 차례대로 삽입하는 트리 힙을 사용하는 이유배열에 데이터를 넣고, 최대값과 최소값을 찾으려면 O(n) 이 걸림이에 반해, 힙에 데이터를 넣고, 최대값과 최소값을 찾으면, 𝑂(𝑙𝑜𝑔𝑛) 이 걸림(이진트리이므로 depth가 깊어질수록 탐색해야하는 노드가 50%씩 줄어든다.)우선순위 큐와 같이 최대값 또는 최소값을 빠르게 찾아야 하는 자료구조 및 알고리즘 구현 등에 활용됨 힙 (Heap) 구조힙은 최대값을 구하기 위한 구조 (최대 힙, Max Heap) 와, 최소값을 구하기 위한 구조 (최소 힙, Min Heap) 로 분류할 수 있음 힙은 다음과 같이 두 가지 조건을 가지고 있는 자료구조임 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 같다. (최대 힙의 경우) 최소 힙의 경우는 각 노드의 값은 해당 노드의 자식 노드가 가진 값보다 크거나 작음 완전 이진 트리 형태를 가짐 힙과 이진 탐색 트리의 공통점과 차이점공통점: 힙과 이진 탐색 트리는 모두 이진 트리임차이점: 힙은 각 노드의 값이 자식 노드보다 크거나 같음(Max Heap의 경우)이진 탐색 트리는 왼쪽 자식 노드의 값이 가장 작고, 그 다음 부모 노드, 그 다음 오른쪽 자식 노드 값이 가장 큼힙은 위와 같은 조건이 없다.힙의 왼쪽 및 오른쪽 자식 노드의 값은 오른쪽이 클 수도 있고, 왼쪽이 클 수도 있음이진 탐색 트리는 탐색을 위한 구조, 힙은 최대/최소값 검색을 위한 구조 중 하나로 이해하면 됨 힙 구현 원리힙 삽입 (Max Heap의 경우) 먼저 삽입된 데이터는 완전 이진 트리 구조에 맞추어, 최하단부 왼쪽 노드부터 채워진다. 채워진 노드 위치에서, 부모 노드보다 값이 클 경우, 부모 노드와 위치를 바꿔주는 작업을 반복함 (swap) 힙 제거 (Max Heap의 경우)힙에서 삭제의 경우는 루트 노드를 삭제하는 것이다. 힙의 용도 자체가 최대값, 최소값을 루트 노드에 위치하도록 해서 최대값과 최소값을 바로 꺼낼 수 있도록 하는 것이다. 루트 노드 삭제, 가장 마지막으로 추가한 노드를 루트 노드로 이동 새로운 루트 노드를 자식노드들과 비교하면서, root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복함 (swap) 힙 구현힙은 일반적으로 배열을 사용해서 구현한다.배열은 인덱스가 0번부터 시작하지만, 힙 구현의 편의를 위해, root 노드 인덱스 번호를 1로 지정하면, 구현이 좀더 수월하다. 부모 노드 인덱스 번호 = parseInt(자식 노드 인덱스 번호 / 2) 왼쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2 오른쪽 자식 노드 인덱스 번호 = 부모 노드 인덱스 번호 * 2 + 1 class Heap { constructor() { // 편의를 위해 0은 0으로 채워주고 루트 노드는 this._array[1]에 넣어줬음. this._array = [0] } // 상위노드와 바꿔야하는지 판단하는 함수 moveUp(insertedIndex) { if (insertedIndex &lt;= 1) { return false } else { const parentIndex = parseInt(insertedIndex / 2) if (this._array[insertedIndex] &gt; this._array[parentIndex]) { return true } else { return false } } } insert(data) { this._array.push(data) let insertedIndex = this._array.length - 1 // 부모노드와 값 비교 while (this.moveUp(insertedIndex)) { const parentIndex = parseInt(insertedIndex / 2) // 부모노드와 바꾸기 const temp = this._array[insertedIndex] this._array[insertedIndex] = this._array[parentIndex] this._array[parentIndex] = temp // 비교할 노드 인덱스 변경 insertedIndex = parentIndex } return true } moveDown(poppedIndex) { const leftChildIndex = poppedIndex * 2 const rightChildIndex = poppedIndex * 2 + 1 // 1. 왼쪽 자식노드가 없으면 더이상 내려갈 데가 없다. 끝~~ if (leftChildIndex &gt;= this._array.length) { return false } // 2. 왼쪽 자식노드는 있고, 오른쪽 자식노드는 없다. // 왼쪽노드 비교해서 swap결정 else if (rightChildIndex &gt;= this._array.length) { if (this._array[poppedIndex] &lt; this._array[leftChildIndex]) { return true } else { return false } } // 3. 두 자식노드 둘다 있을 경우, // 3-1. 자식노드끼리 먼저 비교, 더 큰 자식노드 찾아서 // 3-2. 더 큰 자식노드와 부모노드를 비교해서 swap else { if (this._array[leftChildIndex] &gt; this._array[rightChildIndex]) { if (this._array[poppedIndex] &lt; this._array[leftChildIndex]) { return true } else { return false } } else { if (this._array[poppedIndex] &lt; this._array[rightChildIndex]) { return true } else { return false } } } } /* 보통 삭제는 최상단 노드 (root 노드)를 삭제하는 것이 일반적임힙의 용도는 최대값 또는 최소값을 root 노드에 놓아서, 최대값과 최소값을 바로 꺼내 쓸 수 있도록 하는 것임 */ pop() { // 1. 루트 노드를 삭제 // 2. 다시 트리의 균형을 맞추는 것 // 가장 마지막에 추가한 노드) 를 root 노드로 이동 // root 노드의 값이 child node 보다 작을 경우, // root 노드의 child node 중 가장 큰 값을 가진 노드와 root 노드 위치를 바꿔주는 작업을 반복함 (swap) if (this._array.length &lt;= 1) { return null } // 편의를 위해 0은 0으로 채워주고 루트 노드는 this._array[1]에 넣어줬음. const returnedData = this._array[1] // 마지막 노드를 루트노드로 옮기기 this._array[1] = this._array[this._array.length - 1] this._array.splice(this._array.length - 1, 1) let poppedIndex = 1 while (this.moveDown(poppedIndex)) { const leftChildIndex = poppedIndex * 2 const rightChildIndex = poppedIndex * 2 + 1 if (rightChildIndex &gt;= this._array.length) { if (this._array[poppedIndex] &lt; this._array[leftChildIndex]) { // swap const temp = this._array[poppedIndex] this._array[poppedIndex] = this._array[leftChildIndex] this._array[leftChildIndex] = temp poppedIndex = leftChildIndex } } // 3. 두 자식노드 둘다 있을 경우, // 3-1. 자식노드끼리 먼저 비교, 더 큰 자식노드 찾아서 // 3-2. 더 큰 자식노드와 부모노드를 비교해서 swap else { if (this._array[leftChildIndex] &gt; this._array[rightChildIndex]) { if (this._array[poppedIndex] &lt; this._array[leftChildIndex]) { // swap const temp = this._array[poppedIndex] this._array[poppedIndex] = this._array[leftChildIndex] this._array[leftChildIndex] = temp poppedIndex = leftChildIndex } } else { if (this._array[poppedIndex] &lt; this._array[rightChildIndex]) { // swap const temp = this._array[poppedIndex] this._array[poppedIndex] = this._array[rightChildIndex] this._array[rightChildIndex] = temp poppedIndex = rightChildIndex } } } } return returnedData }}const heap = new Heap()heap.insert(15)heap.insert(8)heap.insert(10)heap.insert(5)heap.insert(4)heap.insert(20)console.log(heap._array)/* [ 0, 20, 8, 15, 5, 4, 10 ] */heap.pop()console.log(heap._array)/* [ 0, 15, 8, 10, 5, 4 ] */","link":"/2019/12/26/Programming/Algorithm/heap-implement/"},{"title":"버블 정렬 vs 선택 정렬 vs 삽입 정렬","text":"sorting이란, 데이터가 주어졌을 \b때 이를 정해진 순서대로 나열하는 것이다. 대표적인 sorting 알고리즘인 버블 정렬과 선택 정렬 그리고 삽입 정렬의 차이점을 알아보고 직접 구현해보자. 버블 정렬두 인접한 데이터를 비교해서, 앞에 있는 데이터가 뒤에 있는 데이터보다 크면, 자리를 바꾸는 정렬 알고리즘 function bubblesort(data) { const len = data.length for (let i = 0; i &lt; len - 1; i++) { let isChanged = false // 앞, 뒤 데이터 비교하는 과정이 len-1-i 번만큼 반복 for (let j = 0; j &lt; len - 1 - i; j++) { if (data[j] &gt; data[j + 1]) { // swap const temp = data[j] data[j] = data[j + 1] data[j + 1] = temp isChanged = true } } // swap이 한번도 일어나지 않았다면 이미 정렬된 상태 if (!isChanged) { break } } return data}const sorted = bubblesort([34, 23, 6, 2, 3, 7, 8, 12])console.log(sorted)/* [ 2, 3, 6, 7, 8, 12, 23, 34 ] */ 선택 정렬 최소값을 선택 해당 최소값을 데이터 맨 앞에 위치한 값과 교체 맨 앞의 위치를 뺀 나머지 데이터를 동일한 방법으로 반복 function selectionsort(data) { const len = data.length // 기준 let stand for (let i = 0; i &lt; len - 1; i++) { stand = i let lowest = stand // 기준을 제외한 배열중에서 가장 작은 값을 찾는다. for (let j = i + 1; j &lt; len; j++) { if (data[lowest] &gt; data[j]) { lowest = j } } const temp = data[stand] data[stand] = data[lowest] data[lowest] = temp } return data}const sorted = selectionsort([34, 23, 6, 2, 3, 7, 8, 12])console.log(sorted) 삽입 정렬특정 자리에 삽입해서 배열을 정렬한다! 두번째 인덱스(key라고 하자)에 있는 데이터를 선택한다. key의 바로 앞에 있는 데이터(B)부터 비교해서, key의 값이 더 작으면 B값과 key의 값을 swap 이 과정을 key의 value &lt; B이 될 때까지 반복. function insertionsort(data) { const len = data.length // 2번째 index부터 시작 for (let i = 1; i &lt; len; i++) { // 기준 index-1 인 요소의 데이터와 비교 for (let j = i - 1; j &gt;= 0; j--) { if (data[j] &gt; data[j + 1]) { //swap const temp = data[j] data[j] = data[j + 1] data[j + 1] = temp } else { break } } } return data}const sorted = insertionsort([34, 11, 5, 23, 6, 2, 3, 7, 8, 12])console.log(sorted) 이 세가지 정렬 모두 for문을 중첩해서 두번 돈다. 시간복잡도는 O(n^2)이 된다.만약 이미 정렬이 되어 있는 배열이라면 O(n)이다.","link":"/2019/12/29/Programming/Algorithm/sort-implement/"},{"title":"퀵 정렬 & 병합정렬 구현","text":"퀵정렬과 병합정렬은 분할정복 알고리즘을 이용한 대표적인 정렬방법이다.분할정복 알고리즘은 재귀용법을 사용한다. (동적프로그래밍에서는 메모이제이션 활용)자, 퀵정렬과 병합정렬을 구현해보자. 퀵정렬정렬 알고리즘의 꽃이라고 불리는 퀵정렬~!!! 기준점(pivot)을 정한다. 기준점보다 작은 데이터는 왼쪽(left), 큰 데이터는 오른쪽(right)로 분할한다. 각각의 왼쪽, 오른쪽 배열을 재귀용법을 사용해서 다시 동일 함수를 호출하여 위 작업을 반복한다.이때 함수는 왼쪽(left) + 기준점(pivot) + 오른쪽(right) 을 리턴한다. const quicksort = list =&gt; { if (list.length &lt; 2) return list // 기준점 const pivot = list[0] const left = [] const right = [] for (let i = 1; i &lt; list.length; i++) { if (pivot &gt; list[i]) { left.push(list[i]) } else { right.push(list[i]) } } return [...quicksort(left), pivot, ...quicksort(right)]}const result = quicksort([10, 3, 7, 2])console.log(\"result\", result) 병합정렬 길이가 1인 배열로 나눠질 때까지 분할한다. 값을 비교해가며 병합한다. const mergesplit = list =&gt; { if (list.length == 1) return list const mid = parseInt(list.length / 2) const left = mergesplit(list.slice(0, mid)) const right = mergesplit(list.slice(mid)) return merge(left, right)}const merge = (left, right) =&gt; { const merged = [] let leftIndex = 0, rightIndex = 0 // case 1 : left, right 남아있을 때, while (left.length &gt; leftIndex &amp;&amp; right.length &gt; rightIndex) { if (left[leftIndex] &gt; right[rightIndex]) { merged.push(right[rightIndex]) rightIndex++ } else { merged.push(left[leftIndex]) leftIndex++ } } // case 2 : left 만 남이있을 때 while (left.length &gt; leftIndex) { merged.push(left[leftIndex]) leftIndex++ } // case 3 : right 만 남아있을 때 while (right.length &gt; rightIndex) { merged.push(right[rightIndex]) rightIndex++ } console.log(\"merged\", merged) return merged}mergesplit([6, 1, 4, 8, 89, 2]) 시간복잡도단계는 보통 log n 번만큼 만들어진다. (원배열이 반으로 나눠지므로)각 단계별로 합병할 때 비교가 n번 일어난다.따라서, 시간 복잡도 O(n) * O(log n) = O(n log n) 퀵정렬의 경우, 최악일 때는 O(n^2) : 계속해서 pivot이 최대값이나 최소값으로 선택되는 경우, 단계가 n 번 생긴다.","link":"/2020/01/04/Programming/Algorithm/quicksort-mergesort-implement/"},{"title":"[LeetCode] Sort Colors","text":"문제Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue. Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively. Note: You are not suppose to use the library’s sort function for this problem. Example: Input: [2,0,2,1,1,0] Output: [0,0,1,1,2,2]Follow up: A rather straight forward solution is a two-pass algorithm using counting sort.First, iterate the array counting number of 0’s, 1’s, and 2’s, then overwrite array with total number of 0’s, then 1’s and followed by 2’s.Could you come up with a one-pass algorithm using only constant space? 출처 : https://leetcode.com/problems/sort-colors/ 풀이과정처음에 생각난 풀이 방법은 추가적인 공간 필요없이 그 자리에서 배열을 정렬할 수 있는 버블 정렬 or 선택 정렬 or 삽입 정렬이 떠올랐다. 하지만 이 정렬들은 배열은 2회 순회를 하므로 문제의 조건과는 맞지 않았다. 최소값을 선택해 배열을 정렬하는 선택 정렬을 응용해서 배열의 첫번째 값을 low, 마지막 값을 high로 초기화한 후, 배열을 돌면서 0과 만나면 low과 swap하고, 2를 만나면 high와 swap 한다.문제의 배열은 빨강, 하양, 파랑과 대응되는 0, 1, 2 만을 원소로 가지므로 가능한 풀이방법이다. 나의풀이/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */// 선택정렬로 풀이var sortColors = function(nums) { const len = nums.length let stand, small for (let i = 0; i &lt; len - 1; i++) { stand = i small = i for (let j = i + 1; j &lt; len; j++) { if (nums[small] &gt; nums[j]) { small = j } } // swap const temp = nums[small] nums[small] = nums[stand] nums[stand] = temp } return nums}var sortColors = function(nums) { let low = 0 let high = nums.length - 1 for (let i = 0; i &lt;= high; ) { if (nums[i] === 0) { // low 바꾸기 const temp = nums[i] nums[i] = nums[low] nums[low] = temp low++ i++ } else if (nums[i] === 2) { // high 바꾸기 const temp = nums[i] nums[i] = nums[high] nums[high] = temp high-- } else { i++ } } return nums}","link":"/2020/01/02/Programming/Algorithm/sort-colors/"},{"title":"[LeetCode] Rotate List","text":"문제링크드리스트가 주어졌을 때, k만큼 오른쪽으로 이동해라. 이 때 k는 음이 아닌 수. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation: rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation: rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL출처 - https://leetcode.com/problems/rotate-list/ 풀이 과정처음 생각했던 방법은 링크드리스트의 마지막요소의 전 요소를 찾은 후, 그 요소의 next를 null로 만들고 마지막 요소를 새로운 head로 만드는 방식이었다. 하지만 이렇게 할 경우, [1,2,3] k=2000000 이런 인풋에서는 시간초과오류가 났다.실행시간이 N(n * k), n=length of list이다.이 방법이 아니라 새로운 방법으로 풀어야 했다. var rotateRight = function(head, k) { let last = head let newFirst = null // 빈 리스트일경우, 리스트 크기가 1일 경우는 제외 if (head &amp;&amp; head.next) { while (k) { last = findBeforeLastItem(head) newFirst = last.next newFirst.next = head last.next = null head = newFirst k-- } } return head}// 마지막 전 원소 찾기const findBeforeLastItem = last =&gt; { while (last.next &amp;&amp; last.next.next) { last = last.next } return last} 릿코드 디스커스에서 circular linked list를 이용하면 쉽게 풀 수 있다는 글을 보고 원형연결리스트를 만들어보았다. 이 때, tail값을 미리 저장해둔다.원형연결리스트를 만들면서 리스트의 길이(len)도 체크한다. k만큼 rotate을 했을 때의 tail의 next는 새로운 head가 되고, tail.next = null로 할당해주면 다시 선형 linked list가 된다. k가 len보다 커지면 똑같은 연산이 반복되므로 나머지 연산을 이용해 반복을 줄인다.k % len 우리가 현재 찾는 값은 rotate했을 때의 tail값이다.let n = len - (k % len) 이 계산식을 통해 구해진 n번 만큼 tail을 이동하면 구할 수 있다. 결과값으로 구해진 tail의 next값이 리턴할 링크드 리스트의 head이고, tail.next는 다시 null로 세팅한다. 이렇게 계산하면 실행시간은 N(n)이 되겠다. 원형연결리스트를 이용하면 문제가 풀린다는 힌트를 얻고도 문제를 해결하는 데 꽤 많이 시간을 쏟았다.let n = len - (k % len)이 계산식을 도출해내기까지 생각이 많이 필요했다.리스트 길이 이상으로 rotate을 하면 반복이 되므로 나머지연산(k % len)으로 반복횟수를 줄이고, tail을 찾는 것이기 때문에 (k % len)번이 아니라 len - (k % len)번 while문을 돌려야 한다. 나의 풀이var rotateRight = function(head, k) { let node = head let tail = head let len = 0 // 빈 리스트 제외 if (node) { len++ while (node.next) { node = node.next len++ } // circlular linked list 만들기 tail = node tail.next = head let n = len - (k % len) while (n) { tail = tail.next n-- } head = tail.next tail.next = null return head } else { return node }}","link":"/2019/12/10/Programming/Algorithm/rotate-list/"},{"title":"[LeetCode] Unique Number of Occurrences","text":"문제정수 배열이 주어질 때, 배열의 각 값의 출현 횟수가 유니크한 경우에만 true를 리턴하는 함수를 작성하세요. Example 1:Input: arr = [1,2,2,1,1,3]Output: trueExplanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2:Input: arr = [1,2]Output: false Example 3:Input: arr = [-3,0,1,-3,1,1,1,-3,10,0]Output: true Constraints: 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000출처 - https://leetcode.com/problems/unique-number-of-occurrences/ 풀이과정일단 각 숫자별로 출현횟수를 obj에 담고, obj의 값만 배열로 만든다.출현횟수 배열을 돌면서 출현횟수 값이 똑같은 경우가 있는지를 filter 함수를 통해 dup에 담고 dup.length &gt; 1 하다면 동일한 출현횟수가 있는 경우이므로 false를 리턴, 아니면 true를 리턴한다. 나의 풀이/** * @param {number[]} arr * @return {boolean} */var uniqueOccurrences = function(arr) { let obj = {} for (let i = 0; i &lt; arr.length; i++) { const value = arr[i] if (obj[value]) { obj[value] += 1 } else { obj[value] = 1 } } const list = Object.values(obj) let ret = true for (let i = 0; i &lt; list.length; i++) { const dup = list.filter(item =&gt; item === list[i]) if (dup.length &gt; 1) { ret = false break } } return ret}","link":"/2019/12/14/Programming/Algorithm/unique-number-of-occurrences/"},{"title":"정렬 - H-index","text":"문제H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명 이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다.풀이과정논문 배열을 인용횟수 내림차순으로 정렬한다.i번째 논문이 인용된 횟수 &gt;= i+1인 케이스의 최대값을 찾아내면 된다~! 논문인용 배열이 [0, 0, 0] 인 경우 결과값은 0이 나와야 한다.정렬후 첫번째 값이 0인 케이스를 예외처리 해주었다. sorted[i] &gt;= i + 1가 아닌 경우를 발견하면 무의미하게 for문을 돌지 않고 바로 break하도록 했다. 처음에는 오름차순으로 정렬해서[0, 1, 3, 5, 6] i번째 논문의 인용횟수 === i+1인 케이스를 찾을려고 했는데 [22, 42] =&gt; 2일 경우 예외가 발생했다.입출력 예제의 경우처럼 i번째 논문의 인용횟수 === i+1인 케이스도 있지만 그렇지 않은 경우도 있을 수 있다는 걸 캐치하지 못했었다. 나의 풀이function solution(citations) { var answer = 0 const sorted = citations.sort((a, b) =&gt; b - a) const len = sorted.length if (sorted[0] === 0) { return answer } for (let i = 0; i &lt; len; i++) { if (sorted[i] &gt;= i + 1) { answer = i + 1 } else { break } } return answer}","link":"/2019/11/27/Programming/Algorithm/sort-h-index/"},{"title":"동적계획법 - 타일 장식물","text":"문제대구 달성공원에 놀러 온 지수는 최근에 새로 만든 타일 장식물을 보게 되었다. 타일 장식물은 정사각형 타일을 붙여 만든 형태였는데, 한 변이 1인 정사각형 타일부터 시작하여 마치 앵무조개의 나선 모양처럼 점점 큰 타일을 붙인 형태였다. 타일 장식물의 일부를 그리면 다음과 같다. 그림에서 타일에 적힌 수는 각 타일의 한 변의 길이를 나타낸다. 타일 장식물을 구성하는 정사각형 타일 한 변의 길이를 안쪽 타일부터 시작하여 차례로 적으면 다음과 같다. [1, 1, 2, 3, 5, 8, .]지수는 문득 이러한 타일들로 구성되는 큰 직사각형의 둘레가 궁금해졌다. 예를 들어, 처음 다섯 개의 타일이 구성하는 직사각형(위에서 빨간색으로 표시한 직사각형)의 둘레는 26이다. 타일의 개수 N이 주어질 때, N개의 타일로 구성된 직사각형의 둘레를 return 하도록 solution 함수를 작성하시오. 제한 사항 N은 1 이상 80 이하인 자연수이다.풀이 과정N개의 타일로 구성된 직사각형의 둘레는 N변과 N-1변을 각각 2배 해주면 구할 수 있다.[1, 1, 2, 3, 5, 8, .] 정사각형 타일 한 변의 길이를 나열한 배열의 모습을 보면 피보나치 수열의 모습과 동일하다.그래서 처음에는 피보나치 함수를 아래와 같이 만들었더니 효율성 검사를 통과하지 못했다. function fibonacci(n) { if (n &lt; 2) { return 1 } else { return fibonacci(n - 1) + fibonacci(n - 2) }} n=5의 경우를 보면, fibonacci(5) = fibonacci(4) + fibonacci (3) -&gt; fibonacci(2) + fibonacci(3) + fibonacci(2) + fibonacci(1) -&gt; fibonacci(1) + fibonacci(1) + fibonacci(2) + fibonacci(1) + fibonacci(1) + fibonacci(1) + fibonacci(1)이렇게 동일한 계산이 반복된다는 것을 알 수 있다.이미 계산된 값에 대해서는 다시 재계산이 일어나지 않도록 메모이제이션*을 했다.이전에 계산된 값이 있으면 그 값을 가져다 쓰도록 코드를 수정했다. (*메모이제이션은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술) 나의 풀이const memo = []function solution(N) { return 2 * (fibonacci(N) + fibonacci(N - 1))}function fibonacci(n) { if (n &lt; 2) { return 1 } else if (memo[n]) { return memo[n] } else { return (memo[n] = fibonacci(n - 1) + fibonacci(n - 2)) }}","link":"/2019/12/03/Programming/Algorithm/tile-ornaments/"},{"title":"브라우저 동작 원리","text":"대부분의 프로그래밍 언어는 운영체제 OS 위에서 실행되지만 웹 애플리케이션의 자바스크립트는 브라우저에서 HTML, CSS와 함께 실행된다. 그러므로 브라우저의 동작 원리를 이해하면 보다 효율적으로 자바스크립트 프로그래밍을 할 수 있다. 브라우저의 핵심 기능은 사용자가 원하는 웹페이지를 서버에 요청하고, 서버의 응답을 받아 브라우저에 표시하는 것이다. 이것을 중요 렌더링 경로(Critical Rendering Path) 라고 부른다. 간단하게 나타내면 서버에서 응답으로 받은 HTML 데이터를 파싱한다. HTML 파싱 결과로 DOM tree를 만든다. 파싱하는 중에 CSS 파일 링크를 만나면 CSS 파일을 요청해서 받아온다. CSS 파일을 파싱해서 CSSOM tree를 만든다. DOM 과 CSSOM 를 결합해서 렌더 트리를 만든다.렌더 트리에는 페이지를 렌더링하는 데 필요한 노드만 포함 참고: visibility: hidden은 display: none과 다르다. 전자는 요소를 보이지 않게 만들지만, 이 요소는 여전히 레이아웃에서 공간을 차지한다.(즉, 비어 있는 상자로 렌더링됨). 반면, 후자(display: none)는 요소가 보이지 않으며 레이아웃에 포함되지도 않도록 렌더링 트리에서 요소를 완전히 제거한다. 그리고, head 태그도 화면에 보이지 않는 요소이므로 렌더 트리에서는 제외된다. 렌더트리를 기반으로 각각의 화면의 어디에 위치할 것인지 레이아웃을 그린다. 픽셀을 화면에 페인트한다. 위 과정은 모두 렌더링 엔진이 담당한다. 반면에 자바스크립트는 렌더링 엔진이 아닌 자바스크립트 엔진이 처리한다. HTML 파서가 script 태그를 만나면, 자바스크립트 코드를 실행하기 위해 DOM 생성 프로세스를 중지하고 자바스크립트 파일을 로드하고 파싱하여 실행한다. 자바 스크립트 실행이 완료되면 다시 DOM 생성을 재개한다. 왜냐하면 JavaScript는 DOM 구조 전체를 바꿀 수 있는 document.write() 메서드와 같은 것을 사용해 문서의 모양을 변경할 수 있기 때문이다. 이렇듯 브라우저는 동기적으로 HTML, CSS, Javascript를 처리한다. 그래서 script 태그에 따라 블로킹이 발생하므로 script 태그를 어디에 두느냐가 중요하다. 보통 script 태그는 body 요소의 가장 아래에 두는 것이 좋다. 그래야 HTML 파싱이 블로킹되지 않는다. 그리고 DOM이 완성되지 않은 상태에서 javascript가 DOM을 조작해서 에러가 발생할 위험도 없앨 수 있다. 블로킹을 막는 또다른 방법으로는 script 태그에 async 속성이나 defer 속성을 추가할 수 있다. 이 속성이 있으면 브라우저가 비동기적으로 혹은 HTML 파싱을 완료 후에 JavaScript 코드를 로딩하고 실행하도록 하면서 HTML 파싱을 막지 않는다. 스타일 시트는 DOM 트리를 변경하지 않기 때문에 문서 파싱을 기다리거나 중단할 이유가 없다. 참고로 하위 리소스(subresource) 로딩 웹 사이트는 일반적으로 이미지, CSS, JavaScript와 같은 외부 리소스를 사용한다. 이러한 파일은 네트워크나 캐시에서 로딩해야 한다. DOM을 구축하기 위해 파싱하는 동안 이런 리소스를 만날 때마다 메인 스레드가 하나하나 요청할 수도 있을 것이다. 하지만 속도를 높이기 위해 프리로드(Preload) 스캐너가 동시에 실행된다. HTML 문서에 &lt;img&gt; 또는 &lt;link&gt; 와 같은 태그가 있으면 프리로드 스캐너는 HTML 파서가 생성한 토큰을 확인하고 브라우저 프로세스의 네트워크 스레드에 요청을 보낸다. [참고] https://d2.naver.com/helloworld/59361https://www.youtube.com/watch?v=DuSURHrZG6I 객체 모델 생성https://developers.google.com/web/fundamentals/performance/critical-rendering-path/constructing-the-object-model?hl=ko 렌더링 트리https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=ko 렌더러 프로세스의 내부 동작 https://d2.naver.com/helloworld/5237120 https://poiemaweb.com/js-browser","link":"/2020/02/25/Programming/Basic/browser-process/"},{"title":"[LeetCode] top-k-frequent-elements","text":"문제빈 배열이 아닌 정수 배열이 주어졌을 때, 가장 많이 등장한 요소 k개를 가지는 배열로 리턴하세요. Example 1:Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2] Example 2:Input: nums = [1], k = 1Output: [1]Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements.Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 출처 - https://leetcode.com/problems/top-k-frequent-elements/ 풀이과정일단 주어진 배열을 forloop으로 돌면서 numsObj에 요소별로 frequency 값을 셋팅한다. { 1: 3, 2: 2, 3: 1} 빈 배열 buckets을 선언한다.frequency를 index로 하고 값으로 numsObj의 key를 배열 형태로 넣어준다. 마지막으로 buckets배열을 뒤에서부터 돌면서 가장 frequency가 높은 값을 answer배열에 넣어준다.answer배열의 크기가 k가 되면 결과값을 리턴한다. 시간 복잡도는 O(n)이므로 조건에 맞는다.(frequency가 겹치는 경우가 거의 없다고 가정하면. 혹은 frequency가 겹치는 경우가 있어도 n값보다는 훨씬 작은 수이기 때문에 무시한다.) 나의 풀이/** * @param {number[]} nums * @param {number} k * @return {number[]} */var topKFrequent = function(nums, k) { let answer = [] let numsObj = {} nums.forEach(item =&gt; { if (numsObj[item]) { numsObj[item]++ } else { numsObj[item] = 1 } }) const keys = Object.keys(numsObj) buckets = [] for (let i = 0; i &lt; keys.length; i++) { const freq = numsObj[keys[i]] if (buckets[freq]) { buckets[freq].push(keys[i]) } else { buckets[freq] = [keys[i]] } } for (let i = buckets.length - 1; i &gt; -1; i--) { if (buckets[i]) { for (let j = 0; j &lt; buckets[i].length; j++) { answer.push(Number(buckets[i][j])) if (answer.length === k) { break } } } if (answer.length === k) { break } } return answer}","link":"/2019/12/24/Programming/Algorithm/top-k-frequent-elements/"},{"title":"[LeetCode] Wiggle Sort 2","text":"문제Given an unsorted array nums, reorder it such that nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]…. Example 1: Input: nums = [1, 5, 1, 1, 6, 4] Output: One possible answer is [1, 4, 1, 5, 1, 6]. Example 2: Input: nums = [1, 3, 2, 2, 3, 1] Output: One possible answer is [2, 3, 1, 3, 1, 2].Note:You may assume all input has valid answer. Follow Up:Can you do it in O(n) time and/or in-place with O(1) extra space? 출처 - https://leetcode.com/problems/wiggle-sort-ii/ 풀이 과정이 문제의 정렬 조건은 nums[0] &lt; nums[1] &gt; nums[2] &lt; nums[3]....이다.즉, 짝수index의 값보다 홀수index의 값이 크도록 정렬하는 것이다. 처음에 시도했던 방법은 인접한 first, second 값을 비교해서 first가 짝수일 때와 홀수일 때를 구분한 후 각 케이스에 맞게 요소들을 swap하는 방식이었다. 인접한 두 요소가 같은 경우 배열의 맨 끝에서부터 추적한 high 값을 찾아서 swap 했는데… 이 방법은 몇몇 케이스에는 맞았지만, 올바른 해답은 아니었다.조건에 맞게 기껏 잘 정렬해놓은 배열을 그 다음 요소를 정렬하면서 흐트러트리는 격이었다. 두 번째로 생각한 방법은 입력받은 배열을 일단 정렬한 후 중간값을 기준으로 값이 큰 배열과 값이 작은 배열로 나눈다.이제 배열을 재정렬하는데, index값이 짝수이면 값이 작은 배열에서 값을 가져오고, 홀수이면 값이 큰 배열에서 값을 가져온다. 나의 풀이/** * @param {number[]} nums * @return {void} Do not return anything, modify nums in-place instead. */// 첫번째 시도했던 방법var wiggleSort = function(nums) { const len = nums.length for (let j = 0; j &lt; len - 1; j++) { for (let i = 0; i &lt; len - 1; i++) { let high = len - 1, first = i, second = i + 1 if (i % 2 === 0) { // second 가 더 커야함 if (nums[first] &gt; nums[second]) { // swap swap(nums, first, second) } else if (nums[first] === nums[second]) { // second보다 큰 high를 찾아서 swap while (nums[high] &lt;= nums[second]) { high-- } console.log(\"high\", high, first, second) // high값과 second값을 swap swap(nums, high, second) } } else { // first가 더 커야함 if (nums[first] &lt; nums[second]) { swap(nums, first, second) } else if (nums[first] === nums[second]) { // second보다 작은 high를 찾아서 swap while (nums[high] &gt;= nums[second]) { high-- } console.log(\"홀수 high\", high, first, second) // high값과 second값을 swap swap(nums, high, second) } } } }}const swap = (nums, first, second) =&gt; { const temp = nums[first] nums[first] = nums[second] nums[second] = temp}// 최종 accepted된 풀이var wiggleSort = function(nums) { // 1. 정렬 const sorted = nums.sort((a, b) =&gt; b - a) // 2. 중간값, 중간값보다 큰 배열, 중간값보다 작은 배열로 나누기 const mid = parseInt(nums.length / 2) const highs = nums.slice(0, mid) const lows = nums.slice(mid) // 3. i 가 짝수이면 작은값배열에서, 홀수이면 큰값 배열에서 for (let i = 0; i &lt; nums.length; i++) { if (i % 2 === 0) { nums[i] = lows[i / 2] } else { nums[i] = highs[parseInt(i / 2)] } }}","link":"/2020/01/04/Programming/Algorithm/wiggle-sort-2/"},{"title":"스택/큐 - 탑","text":"문제수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다. 송신 탑(높이) 수신 탑(높이)5(4) 4(7)4(7) 2(9)3(5) 2(9)2(9) -1(6) -맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요. 제한 사항 heights는 길이 2 이상 100 이하인 정수 배열입니다. 모든 탑의 높이는 1 이상 100 이하입니다. 신호를 수신하는 탑이 없으면 0으로 표시합니다.풀이과정위 문제에서 어떻게 스택과 큐의 자료구조를 사용해야할 지 몰라 일단 생각나는대로 풀어봤다. heights를 forloop안에 i번보다 앞에 있는 요소들과 비교하는 forloop을 한번 더 돌렸다. heights[j] &gt; heights[i]인 케이스가 있으면 그 때의 j+1값을 푸시했고, 해당 사항이 없으면 0을 푸시했다. 나의 풀이function solution(heights) { var answer = [] for (let i = 0; i &lt; heights.length; i++) { for (let j = i - 1; j &gt;= 0; j--) { if (heights[j] &gt; heights[i]) { answer.push(j + 1) break } } if (answer.length !== i + 1) { answer.push(0) } } return answer}","link":"/2019/11/28/Programming/Algorithm/tower/"},{"title":"for문, foreach문, for~in문, for~of문 차이점","text":"for문, foreach문, forin문, forof문 차이점for문의 가독성을 좀 더 좋게 하기 위해서 foreach가 나왔지만 아래와 같은 문제가 있었다. foreach You can’t break out of this loop using a break statement or move to the next iteration with continue.(break로 loop를 빠져나오지 못하고, continue로 그다음 반복으로 이동하지 못함) You can’t return from the enclosing function using a return statement.(return을 사용해 해당 function을 마무리하지 못함) for~inObject 프로퍼티를 반복하기 위해 만들어졌다.물론 array를 반복시킬 수도 있다.index값이 string형이므로 주의가 필요하다. ImportantIf you are expecting a number but in fact have a string this can cause problems, for example “1” + “2” is the string “12” and not the number 3. for~ofES6부터 forof구문 사용가능하다.forof구문에서는 break, continue, return을 모두 사용할 수 있다.현재 사용가능한 가장 간결한 방법이다!","link":"/2018/05/13/Programming/Basic/for-foreach-forin-forof/"},{"title":"크로스 도메인 이슈 해결하기","text":"동일 출처 정책 Same Origin Policy(SOP)이란? 같은 출처에 있는 리소스만 접근할 수 있도록 제한하는 보안정책이다. XMLHttpRequest 나 Fetch api 호출로 데이터를 요청하는 경우에 적용되고 이미지나 css, 동적으로 로드되는 스크립트에는 적용되지 않는다. (단, 웹폰트는 예외) 동일한 출처라는 것은 아래의 규칙을 따른다. 만약 나의 api서버를 외부 웹서비스에서 막 접근해서 가져다 쓴다면 보안상으로도 이슈가 있고 트래픽 과부하 문제도 발생할 수 있다. 따라서 이런 행위를 차단하기 위해 동일한 도메인이 아니면 아래처럼 크로스 도메인 이슈를 발생시킨다. 다음과 같은 에러 메시지가 나면 서버에서 CORS 허용을 해줘야 한다. Failed to load &lt;요청하려는 api 주소&gt;: No ‘Access-Control-Allow-Origin’ header is present on the requested resource. Origin ‘&lt;오리진 주소&gt;’ is therefore not allowed access. 1. 서버의 CORS 허용Cross-Origin Resource Sharing 정책은 추가적인 http 헤더를 사용해 브라우저에게 현재 동작하고 있는 웹 애플리케이션이 다른 출처에서 온 리소스를 액세스 권한이 있는지 알려준다. 사용자 데이터 상에서 부수 효과를 일으킬 수 있는 HTTP 요청 메서드에 대해, 특히 GET 이외의 메소드에 대해 스펙은 브라우저가 요청을 preflight(사전 전달)하도록 강제한다. 이는 HTTP OPTIONS(https://developer.mozilla.org/ko/docs/Web/HTTP/Methods/OPTIONS) 요청 메서드를 이용해 서버로부터 지원 중인 메서드들을 내려 받은 뒤, 서버에서 approval(승인) 시에 실제 HTTP 요청 메서드를 이용해 실제 요청을 전송하는 것을 말합니다. 서버들은 또한 클라이언트에게 (Cookie와 HTTP Authentication 데이터를 포함하는) “credentials”이 요청과 함께 전송되어야 하는지를 알려줄 수도 있습니다. 1 -1. 모든 요청 허용preflight 요청을 받기 위해 OPTIONS 메소드를 추가한다. 헤더에 아래 내용들을 포함시키면 된다. Access-Control-Allow-Origin: *Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONSAccess-Control-Max-Age: 3600Access-Control-Allow-Headers: Origin,Accept,X-Requested-With,Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers,Authorization 1-2. 선별적 허용클라이언트의 헤더값을 보고 서버에서 응답헤더에 해당 출처를 허용하는 걸 담아주면 된다. 1-2-1 클라이언트 요청 헤더Origin요청을 보내는 페이지의 출처(도메인) Access-Control-Request-Method실제 요청하려는 메소드,실제 요청이 있을 때 사용될 HTTP 메소드 (https://developer.mozilla.org/ko/docs/Web/HTTP/Methods)를 서버에 알리기 위한 preflight 요청을 보낼 때 사용된다. Access-Control-Request-Headers실제 요청에 포함되어 있는 헤더명,실제 요청이 있을 때 사용될 HTTP 헤더를 서버에 알리기 위한 preflight 요청을 보낼 때 사용된다. 1-2-2 서버의 응답 헤더Access-Control-Allow-Origin허용할 출처 Access-Control-Allow-Credentials클라이언트 요청이 쿠키를 통해서 자격 증명을 해야 하는 경우에 true.true를 응답 받은 클라이언트는 실제요청시 서버에서 정의된 규격의 인증값이 담긴 쿠키를 같이 보내야 한다. Access-Control-Allow-Headers요청을 허용하는 헤더.실제 요청을 만들 때 사용될 수 있는 HTTP 헤더를 나타내는 preflight 요청에 대한 응답으로 사용. Access-Control-Expose-Headers클라이언트 요청에 포함되어도 되는 사용자 정의 해더.헤더의 이름을 나열하여 어떤 헤더가 응답의 일부로 노출될 수 있는지를 나타낸다. Access-Control-Max-Age클라이언트에서 preflight의 요청 결과를 캐시하는 시간(초) Access-Control-Allow-Methods요청을 허용하는 메소드.기본값은 GET,POST이며 클라이언트에서는 헤더 값에 해당하는 메서드일 경우에만 실제 요청을 시도하게 된다.preflight 요청에 대한 응답으로 리소스에 접근할 때 허용되는 메소드를 명시. [참고] http://sjh836.tistory.com/93https://ko.wikipedia.org/wiki/%EB%8F%99%EC%9D%BC-%EC%B6%9C%EC%B2%98_%EC%A0%95%EC%B1%85#cite_note-1 2. 앵귤러에서 CORS 허용하기추가적으로 localhost에서 우리 서비스 api 서버로 요청을 보냈을 때 제대로 응답을 받으려면 앵귤러의 root 디렉토리에 proxy.conf.json파일을 생성해야한다. { \"/*\" : { \"target\" : \"서버api주소\", \"secure\" : false, \"logLevel\" : \"debug\" }} 그리고 로컬에서 테스트할 때 npm start 명령어를 사용하면 바로 저 설정파일이 적용되도록 package.json파일을 수정해주면 된다. { \"scripts\" : { \"start\" : \"ng serve --proxy-config proxy.conf.json\" }} [참고] https://juristr.com/blog/2016/11/configure-proxy-api-angular-cli/","link":"/2018/05/29/Programming/Basic/cors/"},{"title":"else if문과 switch문의 차이점","text":"else if문과 switch문의 차이점if문은 branch statement, switch문은 jump statement에 기반을 두고 있다. 즉, if문은 조건이 만족하면 실행/만족하지 않으면 무시 (실행을 할 것이냐 말것이냐?)switch문은 입력된 값을 보고 특정 위치로 점프 (어떤 코드를 실행할 것이냐?) branch statement : 레지스터 2개를 비교해서(혹은 레지스터와 상수를 비교해서) 특정 메모리 번지로 이동할 것이냐 말것이냐?를 결정jump statement : 즉시 특정 메모리 번지로 이동하는 기능 else if 문과 switch 문의 차이점은, 순차적으로 모든 if 문을 도느냐. 아니면 해당하는 case 로 바로 가서 불필요한 연산을 줄이느냐의 차이이다. var regimnet = 3;if (regiment == 1) { ...} else if (regiment == 2) { ...} else if (regiment == 3) { // 앞 1,2 를 거쳐 3으로 온다. ...}switch (regiment) { case 1: ... case 2: ... case 3: // 3으로 바로 온다. ...}","link":"/2018/05/09/Programming/Basic/elseif-vs-switch/"},{"title":"화살표 함수(arrow-function)와 function 차이점","text":"function에서 this는 함수 자신을 나타내고, 화살표함수는 this를 따로 변경하지 않는다.(원래 나타내던 this를 그대로 쓴다) 앵귤러의 ts파일에서의 this는 컴포넌트 인스턴스를 의미한다. 앵귤러에서 가끔 function을 이용해야할 경우, 컴포넌트 인스턴스의 변수들을 참조하려면 let _this = this를 이용하면 된다. dismissModal() { let _this = this; $(function() { $(\"#myModal\").on(\"hidden.bs.modal\", function() { _this.userPwd = \"\"; _this.userEmail = \"\"; }); });} function안에서 this를 그냥 쓰면, this는 function 자체를 나타내기 때문에 userPwd과 userEmail이 undefined되었다는 에러가 뜬다. 그래서 let _this = this를 이용해 컴포넌트 인스턴스를 _this에 담아서 function 내부에서 컴포넌트 인스턴스를 참조할 수 있도록 하면 된다.","link":"/2018/05/15/Programming/JavaScript/arrow-function/"},{"title":"매개변수(parameter)와 인수(argument)의 차이","text":"매개변수(parameter)와 인수(argument)의 차이 매개변수(parameter)는 함수 서명 괄호부에 정의하여 함수 내에서 사용하는 변수를,인수(argument)는 호출자(caller)가 함수를 호출할 때 매개변수에 전달하는 값을 가리킨다!","link":"/2018/05/16/Programming/Basic/parameter-argument/"},{"title":"Array - pop, push, shift, unshift","text":"자바스크립트 array method를 정리해보자자바스크립트에는 배열에 아이템을 추가/삭제할 수 있는 4가지 메소드를 제공한다. pop()배열에서 마지막 요소를 제거하고 그 요소를 반환한다.만약 빈 배열에 pop()을 호출하면, undeifined를 반환한다.원본배열 자체가 변한다. const fruits = [\"banana\", \"apple\", \"grape\", \"pineapple\"]const popped = fruits.pop()console.log(popped) // pineappleconsole.log(fruits) // [\"banana\", \"apple\", \"grape\"] push()배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환한다.pop()과 마찬가지로 원본배열이 바뀐다. const animals = [\"pigs\", \"goats\", \"sheep\"]const count = animals.push(\"cows\")console.log(count) // 4console.log(animals) // (4) [\"pigs\", \"goats\", \"sheep\", \"cows\"]animals.push(\"chickens\", \"cats\", \"dogs\") // 7 shift()배열에서 첫번째 요소를 제거하고, 제거된 요소를 반환한다. 원본배열 자체가 변한다.0 번째 위치의 요소를 제거하고 연이은 나머지 값들의 위치를 한칸씩 앞으로 당긴다.만약 빈 배열에 shift()를 호출하면 undefined 리턴. const fruits = [\"banana\", \"apple\", \"grape\", \"pineapple\"]const firstItem = fruits.shift()console.log(firstItem) // bananaconsole.log(fruits) // (3) [\"apple\", \"grape\", \"pineapple\"] unshift()새로운 요소를 배열의 맨 앞쪽에 추가하고 새로운 길이를 반환한다. 원본배열이 바뀐다. const fruits = [\"banana\", \"apple\", \"grape\", \"pineapple\"]fruits.unshift(\"mango\", \"tangerine\")// 6console.log(fruits)// (6) [\"mango\", \"tangerine\", \"banana\", \"apple\", \"grape\", \"pineapple\"] [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/pop","link":"/2019/12/01/Programming/JavaScript/array-method/"},{"title":"호이스팅이란?","text":"내가 알고 있는 호이스팅은 var로 선언한 변수는 최상단으로 끌어올려진다.그래서 선언하기 전에도 미리 사용할 수 있는 것처럼 보인다.하지만 변수 선언 후 변수 사용이라는 규칙을 깨면서 정확히 어디서 이슈가 발생하는지 파악하기 힘들 수가 있다. 그래서 ES6부터 let, const로 선언된 변수는 호이스팅이 안 된다.변수나 함수를 사용하기 전에 미리 선언하고 값을 할당해야만 사용할 수 있다.코드를 순차적으로 실행하게 되므로 보다 직관적으로 코드를 이해할 수 있다. 여기까지가 내가 알고 있는 호이스팅의 전부다. 이직을 위해 인터뷰 준비를 하면서 좀 더 자세히 호이스팅에 대해 알아보고 정리를 해보았다. 호이스팅 정의hoist 라는 단어의 사전적인 의미는 끌어올리기 lift something up이다. var 로 선언된 모든 변수들은 호이스트된다.중요한 것은 여기서 최상단으로 호이스팅되는 것은 변수의 선언이다. 변수가 함수 내에서 정의되었을 경우, 함수의 최상단으로 변수의 선언이 호이스팅되고, 함수 바깥에서 정의되었을 경우, 전역 컨텍스트의 최상위로 선언이 호이스팅된다. var x = function() { console.log(y) // undefined : 선언은 했지만, 값이 할당되지 않았다. //=&gt; 호이스팅 때문에 변수의 선언이 함수의 맨 윗쪽으로 끌어올려짐 var y = 1} 위의 코드를 실제 동작하는 방식대로 변경하면 var x = function() { var y // 변수의 선언 호이스팅 console.log(y) y = 1 // 값의 할당은 원래 위치에서} 선언문은 항상 자바스크립트 엔진 구동시 가장 먼저 해석하므로 호이스팅되고, 할당하는 것은 런타임 과정에서 이루어지기 때문에 호이스팅되지 않는다. foo()function foo() { console.log(\"hello\")} 함수 선언문으로 정의한 함수는 자바스크립트 엔진에 의해 전체 코드의 맨 위로 호이스팅되므로 정의한 위치에 상관없이 함수를 사용할 수 있다.아래와 같이 함수를 함수 리터럴(함수 표현식)로 할당하는 구조에서는 호이스팅되지 않는다.bar()이 실행될 때에는 아직 변수 bar에 담긴 것이 함수인지 모르므로 bar()를 실행하면 bar is not a function라고 에러가 발생한다. bar() // bar is not a functionvar bar = function() { console.log(\"world\")} funcion foo() {} 와 var foo = function(){} 사이에서 foo 사용의 차이에 대해 설명function foo() {} 는 함수선언식!!! 자바스크립트 엔진에게 내가 함수다!!! 바로 알려준다 그래서 호이스팅 된다 ⇒ 함수의 선언 위치에 상관없이 foo함수를 사용할 수 있다. var foo = function(){} 는 함수 표현식!!! 자바스크립트 엔진이 변수 foo의 선언을 호이스팅하지만 foo에 함수가 할당되는 것은 런타임시, 함수는 호이스팅되지 않는다. 함수 실행 전에 반드시 함수를 정의해줘야한다. 함수 정의 전에 함수를 실행하려고 하면 foo is not function 이라는 에러가 뜬다. [참고]https://www.youtube.com/watch?v=7tGmS2SPxBo","link":"/2020/02/25/Programming/JavaScript/hoisting/"},{"title":"타입스크립트에서 interface와 class의 차이점","text":"타입스크립트에서 interface와 class의 차이점노마드 코더의 typechain 강의를 듣던 중 타입스크립트에서 인터페이스와 클래스의 차이점에 대해 설명하는 부분의 해석이 되지 않아(리스닝 부족…) 블로그로 정리하게 되었다. https://toddmotto.com/classes-vs-interfaces-in-typescript의 글을 번역했다. Classes vs Interfaces in TypeScript클래스와 인터페이스는 객체지향 프로그래밍에서 뿐만 아니라 타입스크립트에서 타입체크를 쉽게해주는 편리한 도구다. 클래스는 동일한 구성(속성 및 메소드)을 공유하는 객체를 만들 수 있는 blueprint다. 인터페이스는 객체를 설명하는 관련 속성 및 메소드의 그룹이지만 구현이나 초기화는 제공하지 않는다. 두 구조 모두 객체가 어떻게 생겼는지 정의하기 떄문에 두 개 모두 타입스크립트에서 변수의 타입을 체크하는 용으로 쓰일 수 있다. 클래스나 인터페이스 중 무엇을 사용할지는 사용케이스에 따라 다르다. 타입 체크만 하는 경우, 새로운 인스턴스를 생성하거나, 아니면 둘다 해야하거나에 따라.클래스를 사용하면 타입을 체크하고 구현(인스턴스 생성)까지 할 수 있지만 인터페이스를 통해서는 할 수 없다. 각 구조에서 우리가 얻을 수 있는 것을 제대로 이해하면 코드를 향상시키고 개발자 경험을 향상시킬 수 있다. Using Typescript classES6부터 class를 사용할 수 있다. 타입스크립트는 타입체크와 정적 프로퍼티같은 추가 기능으로 자바스크립트 클래스를 향상시킨다. 우리 코드를 자바스트립트로 트랜스파일할 때마다 모든 클래스 코드를 transpiled 파일에 보관한다는 것을 의미한다. 그러므로, 클래스는 트랜스파일된 자바스크립트에서도 존재한다. 우리는 클래스를 객체팩토리로 사용한다. 클래스는 객체가 어떻게 보여야하고 어떻게 행동하는지에 대해 정의한 다음 클래스 프로퍼티를 초기화하고 메소드를 정희함으로써 구현한다. 그러므로 클래스의 인스턴스를 생성할 때, 우리는 실행할 수 있는 메소드와 정의된 프로퍼티를 가진 객체를 얻는다. PizzaMaker라는 클래스를 보자. class PizzaMaker { static create(event: { name: string; toppings: string[] }) { return { name: event.name, toppings: event.toppings }; }} PizzaMaker는 간단한 클래스다. create라는 정적 메소드가 있다. 이 클래스의 인스턴스를 생성하지 않고도 create 메소드를 사용할 수 있다. 우리는 클래스에 직접 메소드를 호출한다. Array.from같이. const pizza = PizzaMaker.create({ name: 'Inferno', toppings: ['cheese', 'peppers'],});console.log(pizza);// Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] } 그런 다음, PizzaMaker.create()는 클래스가 아닌 인수로 전달된 객체로부터 정의된 name, topping 프로퍼티를 가진 새로운 객체를 리턴한다. 만약 정적 메소드가 아니었다면, PizzaMaker 인스턴스를 생성한 후에 create메소드를 사용할 수 있다. class PizzaMaker { create(event: { name: string; toppings: string[] }) { return { name: event.name, toppings: event.toppings }; }}const pizzaMaker = new PizzaMaker();const pizza = pizzaMaker.create({ name: 'Inferno', toppings: ['cheese', 'peppers'],});console.log(pizza);// Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] } 위와 같이 하면 정적 메소드를 사용했던 것과 동일한 결과를 얻을 수 있다. 클래스의 인스턴스가 있든 없든 타입스크립트 클래스를 사용할 수 있다는 점에서 매우 유연하다. 정적 프로퍼티와 메소드를 추가하면 싱글톤으로 동작하도록 할 수 있다. 반대의 경우에는 팩토리처럼 동작하게 한다. 타입스크립트에서 유티크한 특징은 타입체크를 위해 클래스를 사용할 수 있다는 것이다. Pizza가 어떻게 생겼는지 정의한 클래스를 선언해보자. class Pizza { constructor(public name: string, public toppings: string[]) {}} Pizza클래스의 정의를 보면, 생성자의 인수에서 우리는 클래스 프로퍼티를 정의하는 편리한 방법을 사용할 수 있다. 타이핑을 절약할 수 있다. Pizza는 이름과 토핑 프로퍼티를 가진 객체를 생성할 수 있다. const pizza = new Pizza('Inferno', ['cheese', 'peppers']);console.log(pizza);// Output: Pizza { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] } Pizza 클래스의 인스턴스라는 것을 보여주는 것 외에는 new Pizza(…)와 PizzaMaker.create(…)의 결과는 동일하다. 두가지 모두 동일한 구조를 산출한다. 그래서 우리는 Pizza클래스를 타입체크용으로 PizzaMaker.create(…)의 인수로 사용할 수 있다. class Pizza { constructor(public name: string, public toppings: string[]) {}}class PizzaMaker { static create(event: Pizza) { return { name: event.name, toppings: event.toppings }; }} 위와 같이 하면 PizzaMaker를 좀 더 선언적으로 만들었고 읽기 쉽게 만들었다. 뿐만아니라, 피자에 정의된 똑같은 객체구조를 다른 곳에서 사용할 필요가 있다면, 저렇게 함으로써 우리는 이동가능한 구조를 가진다. Pizza 의 정의를 export해서 앱 내의 모든 곳에서 접근할 수 있다. Pizza를 클래스로 사용하는 것은 우리가 피자를 정의하고 인스턴스를 생성하기 원한다면 좋지만, 만약 Pizza의 구조를 정의하기 원하지만 인스턴스를 생성할 필요가 없을 때는 interface를 사용하는 것이 편리하다. Using Typesript interface클래스와 달리 인터페이스는 Typescript 컨텍스트 내에만 존재하는 가상구조이다. typescript컴파일러는 타입체크 목적으로만 인터페이스를 사용한다. 자바스크립트로 트랜스파일 된 후에는 코드에서 인터페이스는 사라진다. 클래스는 프로퍼티 초기화와 메소드구현을 제공함으로써 팩토리나 싱글톤을 정의할 수 있었던 반면, 인터페이스는 객체의 프로퍼티를 정의하는 단순히 구조계약이다. 어떻게 구현하든, 어떻게 인터페이스에 정의된 프로퍼티를 초기화하든 인터페이스와 관련이 없다. Pizza 클래스를 어떻게 Pizza 인터페이스로 변환하는지 보자. interface Pizza { name: string; toppings: string[];}class PizzaMaker { static create(event: Pizza) { return { name: event.name, toppings: event.toppings }; }} Pizza가 클래스이든 인터페이스이든, PizzaMaker 클래스의 타입체크를 위해 사용되기 때문에, Pizza를 인터페이스로 리펙토링하는 것은 PizzaMaker 클래스의 본문에 전혀 영향을 미치지 않는다. Pizza 인터페이스가 name, toppings 프로퍼티를 어떻게 나열하고 PizzaMaker에 어떻게 타입을 제공하는지 관찰해보라. 또 바뀐부분은, Pizza 인스턴스를 더이상 생성할 수 없다. Using Typesript class vs using Typescript interfacePizza를 인터페이스로 선언하면 타입체크는 할 수 있지만 인스턴스를 생성할 수 없다. 이렇게 되면 코드를 명확하게 하고 가독성을 향상시킬 수 있는 기회를 놓치게 된다. PizzaMaker.create()는 피자처럼 보이는 객체를 반환하는데 이것을 Pizza로 반환하면 더 이해하기 쉽지 않을까? 다시 Pizza를 클래스로 만들어서 피자 인스턴스를 반환해보자. class Pizza { constructor(public name: string, public toppings: string[]) {};}class PizzaMaker { static create(event: Pizza) { return new Pizza(event.name, event.toppings); }}const pizza = PizzaMaker.create({ name: 'Inferno', toppings: ['cheese', 'peppers'] }; Conclusion커스텀 객체를 생성할 필요가 있으면서 타입체크의 이점을 얻으려면 클래스를 사용하고,인스턴스를 생성하지 않을 경우에는 인터페이스를 사용할 수 있는데, (트랜스파일된 자바스크립트에서는) 코드를 생성하지 않으면서 “가상”으로 타입체크를 할 수 있다. 인터페이스와 클래스 모두 객체의 구조를 정의하고 경우에 따라 서로 교환해서 사용할 수 있다. 다양한 클래스 간에 구조정의를 공유해야할 경우, 우리는 인터페이스에서 구조를 정의한다. 그리고 각 클래스에서 인터페이스를 구현할 수 있다. 이것이 바로 타입스크립트의 힘이고, 엄청 유연하다. 타입스크립트는 포괄적인 객체지향 설계과 다양한 타입체크 기능을 제공한다.","link":"/2018/05/18/Programming/JavaScript/interface-vs-class-in-typescript/"},{"title":"clipboard.js 문자열 복사 에러 해결","text":"문제 상황clipboard.js 라이브러리를 사용해서 문자열을 복사하는데 특정 경우에 아래와 같은 에러가 떴다. ERROR DOMException: Failed to execute ‘querySelector’ on ‘Document’: ‘#1Aivvfv3etgiaVvSqSFNrGoFAyyxLbHyWL1’ is not a valid selector. &lt;input type=\"text\" [value]=\"address.addr\" id=\"{{ address.addr + 1 }}\" /&gt;&lt;button type=\"button\" (click)=\"copyAddr(address.addr)\" id=\"copyWalletAddr\" attr.data-clipboard-target=\"#{{ address.addr + 1 }}\" data-clipboard-action=\"copy\"&gt;&lt;/button&gt; 해결 방법attr.data-clipboard-target 속성을 통해, 해당 id의 input value를 복사한다.id 값은 숫자로 시작할 수 없다.지갑주소가 숫자로 시작해서 버그가 발생했다.지갑주소 앞에 “wallet”이라는 문자열을 추가해줌으로써 해결했다. &lt;input type=\"text\" [value]=\"address.addr\" id=\"{{ 'wallet' + address.addr + 1 }}\" /&gt;&lt;button type=\"button\" (click)=\"copyAddr(address.addr)\" id=\"copyWalletAddr\" attr.data-clipboard-target=\"#{{'wallet' + address.addr + 1 }}\" data-clipboard-action=\"copy\"&gt;&lt;/button&gt;","link":"/2018/08/10/Programming/JavaScript/clipboardjs-error/"},{"title":"자바스크립트에서 실행 컨텍스트란?","text":"https://tylermcginnis.com/ultimate-guide-to-execution-contexts-hoisting-scopes-and-closures-in-javascript/에 있는 내용을 번역해보았다. 실행 컨텍스트를 통해 Hoisting, Scopes, Closures를 이해해보자! 자바스크립트 언어를 이해하는데 가장 중요하고 기본적인 컨셉은 바로 “Execution Context” 실행 컨텍스트를 이해하는 것이다. 실행 컨텍스트를 잘 이해하면 호이스팅, 스코프 체인, 클로저를 이해하기 쉬울 것이다. 실행 컨텍스트라는 게 정확히 뭘까? 이해를 쉽게 하기 위해서 우리가 어떻게 소프트웨어를 만드는 지 살펴보자. 소프트웨어 작성 전략 중 하나는 코드를 여러 조각으로 나누는 것이다. 이런 조각들은 functions, modules, packages 등등으로 불린다. 이렇게 분리하는 이유는 단 하나, 프로그램의 복잡성을 분리하고 관리하기 위해서이다. 이제 코드를 작성하는 입장말고 코드를 해석하는 자바스크립트 엔진 관점에서 생각해보자. 코드 해석의 복잡성을 관리하기 위해서 코드를 부분 부분으로 나누는 같은 전략을 사용할 수 있을까? 코드를 작성할 때와 마찬가지로 말이다. YES! 그렇게 할 수 있고, 그렇게 나누어진 조각들을 Execution Context 라고 한다. functions, modules, packages 가 코드 작성의 복잡성을 관리할 수 있게 해주는 것처럼 실행 컨텐스트도 자바스크립트 엔진이 코드의 해석과 실행의 복잡성을 관리할 수 있게 해주는 것이다. 이제 우리는 실행 컨텍스트의 목적을 알았다. 다음 질문은 어떻게 실행 컨텍스트가 생성되고 어떤 요소들로 구성되어 있는가이다. 자바스크립트 엔진이 코드를 실행할 때 처음으로 생성되는 첫 실행 컨텍스트는 Global Execution Context 라고 한다. 처음에 이 실행 컨텍스트는 두 가지로 구성되어 있다. global object this 라는 변수 (this는 브라우저에서 자바스크립트를 실행하는 경우 window, Node 환경에서는 global 이 된다. ) 아무런 코드가 없어도 Global Execution Context는 window, this 두 가지 요소를 가진다. 가장 기본적인 형태의 글로벌 실행 컨텍스트이다. 자 이제 코드를 작성해보자. 위 두 이미지의 차이점을 알 수 있겠는가? 핵심은 실행 컨텍스트에는 두 개의 단계(생성단계, 실행단계)가 있다는 것과 각 단계는 고유한 역할이 있다는 것이다. 글로벌 실행 컨텍스트 실행 단계에서 자바스크립트 엔진은 global object를 생성 this 변수 object를 생성 변수와 함수를 위한 메모리공간 확보 선언식 함수를 메모리에 배치하면서 변수 선언에 기본값 undefined를 할당 아직까지 자바스크립트 엔진이 코드를 한 줄씩 읽고 실행하는 실행단계가 아니다. 아래의 gif를 보면 생성 단계와 실행 단계의 흐름을 파악할 수 있을거다. 생성단계동안 window, this 가 생성되고, 변수가 선언되고 (name, handle) 기본값으로 undefined가 할당된다. 그리고 선언식 함수 getUser는 메모리에 전부 올라간다. 실행단계에 접어들면, 자바스크립트 엔진이 코드를 한줄씩 실행한다. 그리고 진짜 값을 이미 메모리에 있는 변수에 할당하다. 생성단계와 실행단계 개념을 좀 더 명확히 하기 위해서 생성단계 전과 실행단계 후에 로그를 찍어보자. console.log(\"name: \", name) // undefinedconsole.log(\"handle: \", handle) // undefinedconsole.log(\"getUser :\", getUser) // [Function: getUser]var name = \"Tyler\"var handle = \"@tylermcginnis\"function getUser() { return { name: name, handle: handle }}console.log(\"name: \", name) // Tylerconsole.log(\"handle: \", handle) // @tylermcginnisconsole.log(\"getUser :\", getUser) // [Function: getUser] 자바스크립트 엔진이 코드를 한 줄씩 해석하기 시작했을 때는 이미 생성단계가 발생한 이후다. 그래서 위에서 봤듯이, 변수들이 선언되고 undefined로 초기화됐고, 선언식 함수는 함수 전체가 메모리에 올라간 상태다. 생성단계에서 변수의 선언시 undefined로 값이 초기화되는 것을 Hoising 이라고 한다. 여기까지 이해했다면 호이스팅에 대해 모든 것을 이해한거다. 이제 또다른 실행 컨테스트를 배워보자. 글로벌 실행 컨테스트와 거의 동일하다. 바로 함수 실행 컨텍스트! 함수가 호출될 때마다 생성된다. 이것이 핵심이다! 글로벌 실행 컨텍스트가 생성되는 시점은 오직 자바스크립트 엔진이 처음으로 코드 해석을 시작할 때이고, 함수 실행 컨텍스트는 함수가 호출될 때마다!!!!이다. 그러면 글로벌 실행 컨텍스트와 함수 실행 컨텍스트는 뭐가 다르냐? 함수 실행 컨텍스트가 생성될 때마다 자바스크립트 엔진은 arguments object 를 생성 this 변수 object를 생성 변수와 함수를 위한 메모리공간 확보 선언식 함수를 메모리에 배치하면서 변수 선언에 기본값 undefined를 할당 global object를 생성하는 게 아니라 arguments object를 생성하는 부분만 다르고 나머지는 동일하다. 이제 위의 코드에서 getUser함수를 호출해보자. 위에서 말한대로 getUser 함수를 호출하면 새로운 실행 컨텍스트가 생성된다. getUser 함수 실행 컨텍스트의 생성단계에서 자바스크립트 엔진은 arguments object와 this object를 생성한다. 현재 getUser 함수에 내부 변수가 없기 때문에 자바스크립트 엔진은 메모리공간 확보나 변수 선언에서 호이스트를 할 필요가 없다. getUser 함수가 실행을 마치고 난 후에 시각화 화면에서 사라지는 걸 확인할 수 있을거다. 실제로 자바스크립트 엔진은 실행 스택 (콜스택이라고도 알려진)이라고 부르는 걸 만든다. 함수가 호출되면 새로운 실행 컨텍스트가 생성되어 실행 스택에 추가된다. 생성단계와 실행단계를 통해 함수 실행이 완료되면 실행 스택에서 제거된다. 자바스크립트는 싱글스레드(한번에 한가지 작업만 할 수 있다)이므로 이를 시각화하기 좋다. 함수가 호출되면 실행 컨텍스트가 실행 스택에 쌓였다가 실행을 마치면 실행 스택에서 제거되는 것을 볼 수 있다. 그렇다면, 로컬 변수는 어떻게 작동하는 걸까? 로컬 변수를 가지는 함수로 바꿔서 테스트해보자. 살펴봐야할 몇가지가 있다. 첫번째로 전달된 인자는 해당 함수의 실행 컨텍스트에 로컬 변수로 추가된다. 위의 예에서는 handle 이라는 변수가 글로벌 실행 컨텍스트(handle 변수가 여기에 정의되었으므로)와 함수 실행 컨텍스트(인자로 전달되었으므로) 둘다에 존재한다. 두번재는 함수 내부에서 정의된 변수는 함수 실행 컨텍스트 내부에서만 존재한다. getURL 함수에서 twitterURL 변수를 정의했으므로 getURL 함수 실행 컨텍스트 내부에 존재한다. 글로벌 실행 컨텍스트에는 없다. 당연해 보이지만, 이 부분은 다음 주제인 스코프의 기본이다. 변수가 접근가능한 범위라는 식으로 스코프의 정의에 대해서 이미 들어봤을 거다. MDN에서 스코프를 “현재 실행 컨텍스트” 라고 정의한다. 우리는 실행 컨텍스트에 대해서 생각한 것과 비슷한 방식으로 스코프 혹은 변수가 접근 가능한 범위를 생각할 수 있다. 아래의 코드에서 어떤 값이 찍힐 지 알아보자. function foo() { var bar = \"Declared in foo\"}foo()console.log(bar) 글로벌 실행 컨텍스트의 생성단계에서 global object, this object가 생성되고 foo함수가 메모리 위에 올라간다. 실행단계에서는 별다른 과정이 실행되지 않는다. foo 함수가 호출되면 함수 실행 컨텍스트가 생성되고 생성단계에서 arguments object, this object가 생성되고 변수 bar가 선언되면서 undefined로 초기화된다. foo 함수 실행 컨텍스트의 실행단계에서 bar에 실제 값이 할당된다. foo 함수 실행을 마치면 실행 스택에서 실행 컨텍스트가 사라진다. console.log(bar)를 실행할 시점에 글로벌 실행 컨텍스트에는 bar에 대한 정보가 없다. Uncaught ReferenceError: bar is not defined 에러가 로그에 찍힌다. What this shows us is that variables created inside of a function are locally scoped. 이를 통해 함수 내부에서 생성된 변수는 local scope를 가진다는 것이다. 이 말은 함수 실행 컨텍스트가 실행 스택에서 제거되고 나서는 그 변수에 접근할 수 없다는 것이다. (하지만 예외 상황이 있다. 이 부분은 뒤에서) 아래 코드에서 어떤 값이 콘솔 로그에 찍히는지 예상해보자. function first() { var name = \"Jordyn\" console.log(name)}function second() { var name = \"Jake\" console.log(name)}console.log(name) // undefinedvar name = \"Tyler\"first() // Jordynsecond() // Jakeconsole.log(name) // Tyler 위 결과를 통해 우리는 각 새로운 실행 컨텍스트가 고유한 변수환경을 가지고 있다고 생각할 수 있다. 같은 이름의 변수가 다른 실행 컨텍스트에 있다고 하더라도 자바스크립트 엔진은 현재의 실행 컨텍스트를 먼저 찾아본다. 그렇다면 만약 현재의 실행 컨텍스트에 해당 변수가 존재하지 않는다면? 자바스크립트 엔진은 변수의 값을 찾는 것을 멈출까? 아래의 코드를 봐보자. var name = \"Tyler\"function logName() { console.log(name)}logName() // Tyler logName 함수 실행 컨텍스트에 변수 name이 없으므로 not defined 에러가 날 거라고 예상했을 수도 있다. 하지만 그것은 잘못됐다. 자바스크립트 엔진은 함수 실행 컨텍스트에서 로컬 변수를 찾지 못하면 가장 가까운 부모 실행 컨텍스트에 그 변수가 있는지 찾는다. 이 loopup chain은 글로벌 실행 컨텍스트에 도달할 때까지 계속된다. 위의 예에서는 글로벌 실행 컨텍스트에 변수 name이 있어서 그 값이 출력된다. 로컬 실행 컨텍스트에 변수가 없는 경우, 자바스크립트 엔진이 부모 실행 컨텍스트를 하나씩 차례대로 확인하는 프로세스를 Scope Chain 이라고 한다. 우리는 위에서 함수 내부에서 생성된 변수는 내부에서만 접근 가능하고 (대부분의 경우) 함수 실행 컨텍스트가 실행 스택에서 제거되면 그 변수에 접근할 수 없다고 배웠다. 하지만 예외적인 경우가 있다. 바로 다른 함수의 안에 중첩된 함수가 있는 경우이다. 이 경우에 부모 함수의 실행 컨텍스트가 실행 스택에서 제거되었더라도 자식 함수는 부모 함수의 스코프에 여전히 접근할 수 있다. makeAdder 함수 실행 컨텍스트가 실행 스택에서 제거되고 나서, 위의 gif를 보면 Closure Scope 를 생성하는 것을 확인할 수 있다. 클로저 스코프 내에 makeAdder 함수 실행 컨텍스트에 있던 것과 동일한 변수 환경이 있다. 이것이 발생한 이유는 다른 함수 안에 중첩된 함수가 있기 때문이다. 위 예에서는 makeAdder 함수 안에 inner 함수가 중첩되어 있다. 그래서 inner 함수는 makeAdder함수의 변수 환경을 가지는 클로저를 생성한다. makeAdder 함수 실행 컨텍스트가 실행 스택에서 제거되고 나서도 closure scope가 생성되었기 때문에 inner 함수는 스코프 체인을 통해 변수 x에 접근할 수 있는 것이다. 짐작할 수 있듯이, 자식 함수가 부모 함수의 변수 환경을 closing하는(묶어서 갖고 있는) 컨셉을 클로저라고 부른다.","link":"/2020/02/28/Programming/JavaScript/execute-context/"},{"title":"NodeJS에서 import 구문 사용하기","text":"NodeJS는 아직 CommonJS 기반 모듈 시스템을 사용하기 때문에 ES6의 import나 export와 같은 키워드는 디폴트로 지원하지 않는다. CommonJS가 제공하는 require방식이 아니라 import키워드를 사용하고 싶다면 아래와 같은 작업이 필요한데, 바벨을 통해 ES6문법으로 작성된 js파일을 ES5 문법으로 변환해주는 작업을 해줘야한다. 1. 필요한 모듈 설치// babel/cli는 터미널에서 커맨드를 입력해서 Babel을 사용할 때 필요한 모듈yarn add babel-cli --dev// 프리셋은 버전별로 필요 플러그인들을 모아놓은 세트//babel-preset-env 은 그런 프리셋과 플러그인들을 모아 관리하고 있는 모듈yarn add babel-preset-env --devyarn add babel-preset-stage-3 --dev 2. 프로젝트 루트 위치에 바벨 설정 파일 (.babelrc) 생성// 곧 표준으로 받아들여질 stage-3에 있는 문법을 기준으로 트랜스파일 하겠다고 바벨에서 알려준다.{ \"presets\": [\"env\", \"stage-3\"]} 3. package.json 에 scripts 추가{ \"scripts\": { \"start\": \"babel-node index.js\" }, \"devDependencies\": { \"babel-cli\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"babel-preset-stage-3\": \"^6.24.1\" }} 위와 같이 작성 후 yarn start를 하면 index.js 파일이 표준 자바스크립트 문법으로 컴파일되어 실행된다.","link":"/2019/12/07/Programming/JavaScript/nodejs-babel/"},{"title":"스터디 - 재사용 가능한, 모듈적인 코드로 - 두번째","text":"지난 글에 이어서 함수 파이프라인을 합성문제를 더 작고 단순한 하위문제들로 쪼갠 다음 이것들을 다시 조합해서 해결하는 방안을 찾는 능력의 중요성! 함수형 프로그램의 목표는 합성을 유도하는 필요한 자료구조를 얻는 것 함수 합성: 서술과 평가를 구분함수 합성이란 한마디로 복잡한 작업을 한데 묶어 간단한 작업으로 쪼개는 과정람다JS 함수 R.compose로 두 순수함수를 합성하는 예제 const R = require(\"ramda\")const _ = require(\"lodash\")const str = `We can only see a short distance ahead but we can see plenty there that needs to be done.`const explode = str =&gt; str.split(/\\s+/)const count = arr =&gt; arr.lengthconst countWords = R.compose(count, explode)console.log(\"countWords(str)\", countWords(str)) 흥미로운 사실은 countWords를 실행하기 전에는 아무 평가도 하지 않는다는 점합성이 끝나면 해당 인수(countWords에 전달하는 인수)를 받아 호출되기를 기다리는 또다른 함수가 반환된다.함수의 서술부와 평가부를 분리하는 함수합성의 미학! 합성은 함수의 출력과 입력을 연결하여 진정한 함수 파이프라인을 완성한다. // compose 구현부function compose(/* 함수 */) { let args = arguments let start = args.length - 1 // compose는 실제 인수를 넣고 호출한 또다른함수를 출력 return function() { let i = start // 전달된 인수를 넣고 동적으로 함수를 적용 let result = args[start].apply(this, arguments) while (i--) // 이전 단계 반환값을 다시 인수로 넣고 그다음함수를 계속 반복 result = args[i].call(this, result) return result }} const trim = str =&gt; str.replace(/\\s*|\\s$/g, \"\")const nomarlize = str =&gt; str.replace(/\\-/g, \"\")const validLength = (param, str) =&gt; str.length === paramconst checkLengthSsn = _.partial(validLength, 9)const clearInput = R.compose(nomarlize, trim)const isValidSsn = R.compose(checkLengthSsn, clearInput)console.log(\"clearInput(` 444-44-444`)\", clearInput(` 444-44-444`))console.log(\"isValidSsn(` 444-44-444`)\", isValidSsn(` 444-44-444`)) 이런 개념을 바탕으로 단순한 함수들을 조합해서 전체 프로그램을 구축하는 것. 합성은 결합 가능한 연산 conjunctive operation 이라서 논리 AND 연산자로 원소를 합칠 수 있다. 함수형 라이브러리로 합성람다JS 같은 함수형 라이브러리는 처음부터 커링을 염두에 두고 모든 함수를 구성했기 때문에 파이프라인으로 합성하면 함수를 다용도로 활용할 수 있다. const students = [\"Rosser\", \"Turing\", \"Kleene\", \"Church\"]const grades = [80, 100, 90, 99]// 가장 똑똑한 학생 구하기const smartestStudent = R.compose(R.head, R.pluck(0), R.reverse, R.sortBy(R.prop(1)), R.zip)const ret = smartestStudent(students, grades)console.log(\"ret\", ret)// 알기 쉽게 함수 별칭을 사용const first = R.headconst getName = R.pluck(0)const reverse = R.reverseconst sortByGrade = R.sortBy(R.prop(1))const combine = R.zipR.compose(first, getName, reverse, sortByGrade, combine) 순수/분순 함수 다루기불순한 impure한 코드는 실행 후 부수효과가 드러나고 외부 디펜던시 탓에 구성함수의 스코프 바깥에서 데이터에 접근할 수 밖에 없다.실세계에서는 순수/불순한 코드가 섞여있을 수 밖에 없으므로 양쪽을 확실하게 구분하고 가급적 불순코드를 (가장 좋게는 단일함수로) 격리하는 방법을 찾아야한다. // 커링 및 합성을 응용한 showStudent 프로그램const findObject = R.curry((db, id) =&gt; { // 리팩터링한 find() 메서드는 저장소 객체를 매개변수로 받기 때문에 합성하기 쉽다 const obj = find(db, id) if (obj === null) { throw new Error(`IDrk [${id}]인 객체는 없습니다`) } return obj})// students 객체 저장소를 가리키게 하여 findObject를 부분평가하면 결국 findStudent라는 새함수가 생성const findStudent = findObject(DB(\"students\"))const csv = ({ ssn, firstname, lastname }) =&gt; `${ssn}, ${firstname}, ${lastname}`const append = R.curry((elementId, info) =&gt; { document.querySelector(elementId).innerHTML = info return info})const showStudent = R.compose(append(\"#student-info\"), csv, findStudent, normalize, trim)showStudent(\"4444-4444\") 무인수 프로그래밍R.compose(first, getName, reverse, sortByGrade, combine)기존의 함수 선언과 달리 자신의 구성함수의 매개변수를하나도 드러내지 않는다.compose또는 pipe 함수를 사용하면 인수를 선언할 필요가 없기 때문에 간결하면서도 선언적인 무인수 코드를 작성할 수 있다. 무인수스타일코드이 함수들이 어떤 형식의 인수를 받는지, 전체 표현식 안에서 어떻게 연결되는지 아무 선언도 하지 않는다. const runProgram = R.pipe(R.map(R.toLower), R.uniq, R.sortBy(R.identity))const ret = runProgram([ \"Functional\", \"Programming\", \"CUrry\", \"Memoization\", \"Partial\", \"Curry\", \"Programming\"])console.log(\"ret\", ret) 함수 조합기로 제어흐름을 관리조건 로직을 구사하거나 다수의 함수를 차례로 실행하는 경우, 애플리케이션의 제어흐름을 관리하는 데 유용한 유틸리티 조합기 - 함수 또는 다른 조합기 같은 기본 장치를 조합하여 제어로직처럼 작동시킬 수 있는 고계함수, 조합기는 대부분 함수형 프로그램이 잘 흘러가도록 조정하는 일이 주임무라 자신의 변수를 선언하거나 비즈니스 로직을 두진않는다.compose, pipe이외에도 종류가 많지만 자주 쓰는 것들 정리해보면 항등(identity)주어진 인수와 똑같은 값을 반환하는 함수identity :: (a) -&gt; a 탭(tap)코드 추가 없이 void 함수(로깅이나 파일/HTML 페이지 쓰기 등)를 연결하여 합성할 때 유용. 자신을 함수에 넘기고 자신을 돌려받는다.tap :: (a -&gt; *) -&gt; a -&gt; a 선택(alternation) - OR-조합기alt 조합기는 함수 호술시 기본 응답을 제공하는 단순 조건 로직을 수행함수2개를 받아 false, null, undefined가 아닌 값이 있으면 첫 번째 함수의 결과를, 그렇지 않으면 두번째 함수의 결과를 반환. 순차열(sequence) - S-조합기함수 순차열의 순회, 2개 또는 더 많은 함수를 인수로 받아, 동일한 값에 대해 각 함수를 차례로 실행하는 또다른 함수를 반환.이 조합기를 이용하면 서로 연관되어 있지만 독립적인 일련의 연산을 수행할 수 있다. 포크(fork) 또는 조인(join)포크 조합기는 하나의 자원을 두가지방법으로 처리후 그 결과를 다시 조합한다.하나의 조인 함수와 주어진 입력을 처리할 종단함수 2개를 받는다. 함수형 프로그래밍은 불변성, 순수성이 기본 원리이므로 프로그램을 구성하는 함수의 모듈성과 재사용성을 세세하게 조절할 수 있다. 자바스크립트에서는 함수를 이용해서 모듈을 구현할 수 있다고 했는데 마찬가지로 전체 모듈을 합성하고 재사용하는 일도 얼마든지 가능하다 이장에서 배운 기법들로 순수함수를 추상하여 합성 가능한 형태로 만드는 게 목적이다.","link":"/2019/04/25/Programming/JavaScript/study-modular-code-2/"},{"title":"스터디 - 재사용 가능한, 모듈적인 코드로","text":"이번에 정리할 내용은 Chapter 4. 재사용 가능한, 모듈적인 코드로! 이 장의 내용 함수 체인과 함수 파이프라인 비교 함수형 라이브러리 람다JS 소개 커링, 부분 적용, 함수 바인딩 개념 탐구 함수 합성으로 모듈적인 프로그램 제작 함수 조합기로 프로그램의 흐름을 개선 모듈성은 프로그램을 더 작고 독립적인 부분으로 나눌 수 있는 정도를 뜻한다. 모듈적 프로그램modular program은 자신을 구성하는 부속들로부터 자신의 의미를 도출할 수 있다는 점에서 뚜렷이 구분된다. 이들 부속품은 다른 시스템에 그대로 또는 더 쪼개서 통합할 수 있는 재사용 가능한 컴포넌트다. 이러한 코드는 생산성을 높일 뿐만 아니라 코드 유지보수성 및 가독성을 향상시키는데 도움이 된다. 3장에서는 하나의 래퍼 객체를 중심으로 단단히 결합된 메서드 체인으로 문제를 해결했다. 4장에서는 함수 합성을 통해 느슨하게 결합된 파이프라인을 만들고, 보다 유연한 독립적인 컴포넌트를 만들어보자. 이렇게 하려면 먼저 코드를 적정 수준으로 추상해야한다. 이 때 람다JS라는 함수형 프레임워크의 도움을 받아 부분 평가 및 합성 같은 주요 함수형 기법을 어떻게 구사하는지 살펴보자. 메서드 체인 대 함수 파이프라인3장에서는 메서드 체인으로 함수를 연결했다. 파이프라이닝은 함수를 연결하는 또다른 기법이다.함수란 입력 형식과 출력 형식 간의 수학적인 매핑을 뜻한다. [참고]함수형 커뮤니티에서는 하스켈 언어 표기법을 많이 쓴다.&lt;function-name&gt; :: &lt;inputs&gt; -&gt; &lt;outputs&gt; 함수 체이닝과 파이프라이닝을 이해하려면 함수를 형식 간의 매핑으로 바라봐야한다. 메서드를 체이닝 (단단한 결합, 제한된 표현성) 함수 파이프라인을 배열 (느슨한 결합, 유연성) 메소드를 여럿 체이닝map, filter 함수는 배열을 넘겨받아 새 배열을 돌려준다고 했다. _.chain(names) // 뒤에 점(.)을 붙여 로대시JS의 다른 메서드를 호출 .filter(isValid) .map(s =&gt; s.replace(/_/, \" \")) .uniq() .map(_.startCase) .sort() .value() 명령형에 비해 구조적으로도 향상됐고, 가독성도 좋아졌다. 하지만 로대시JS가 제공하는 연산만 쓸 수 있기 때문에 다른 (또는 직접 만든) 라이브러리 함수를 쉽게 연결할 수 없다. 고수준에서 보면 배열 메서드의 순차열은 아래와 같다. 여기서 체인을 끊어버리고 독립적인 함수열을 자유롭게 배열할 수 있으면 좋겠다.(우리가 만든 메서드나 다른 라이브러리의 메서드를 자유롭게 연산 과정에 추가할 수 있으면 좋겠다.) 그래서 함수 파이프라인이 필요한 것이다. 함수를 파이프라인에 나열함수형 프로그래밍에서는 메서드 체이닝의 한계에서 벗어나, 출신에 관계없이 어떤 함수라도 유연하게 결합할 수 있다. 파이프라인pipeline이란 한 함수의 출력이 다음 함수의 입력이 되게끔 느슨하게 배열한, 방향성directional 함수 순차열이다. 아래는 서로다른 객체형을 다루는 함수를 연결한 파이프라인의 개념도다. 이 장에서는 함수 호출을 위의 그림과 같이 고수준의 간명한 함수 파이프라인으로 배열하는 기법을 연구한다. 체이닝과 파이프라인의 접근방법 차이체이닝 - 객체 메서드를 통해 함수들을 단단히 결합파이프라인 - 함수 입출력을 서로 연결지어 느슨하게 결합된 컴포넌트를 만든다. 단, 함수의 항수(인수 개수)와 형식이 호환되지 않으면 연결할 수 없다. 함수 호환 요건함수형 프로그래밍에서는 파이프라인이 프로그램을 구축하는 유일한 수단!정의된 문제를 해결하기 위해서는 단계별로 명확하게 정의된 계산을 차례차례 해내가는 과정이 필요하다. 이 계산 단계가 코드에서는 함수로 표현된다. 각 함수는 입력과 출력이 서로 호환돼야 한다. 형식 : 한 함수의 반환 형식과 수신 함수의 인수 형식이 일치해야 한다. 항수 : 수신 함수는 앞 단계 함수가 반환한 값을 처리하기 위해 적어도 하나 이상의 매개변수를 선언해야 한다. 형식이 호환되는 함수함수 파이프라인을 설계할 때는 한 함수가 반환하는 것과 다른 함수가 받는 것이 반드시 호환되어야 한다.정적 형식statically typed 언어에서는 형식이 큰 관심사이지만 자바스크립트는 형식이 느슨한 언어라서 그렇지 않다. 어떤 객체가 실제로 특정 형식처럼 작동하면 그 형식은 그냥 그 객체의 형식인 것 덕 타이핑(“오리처럼 걷고 말하는 동물이 있다면 그건 다름아닌 오리다”)이라고 한다. 자바스크립트는 동적 파견dynamic dispatch 체제 덕분에 형식과 무관하게 객체에서 속성과 메서드를 가져올 수 있지만, 함수가 어떤 형식의 값을 기대하는지 알아야 프로그램을 이해하기가 더 쉬워진다.하스켈 표기법으로 코드에 주석을 붙여 문서화하는 식으로라도 입출력을 명확하게 정의해두면 프로그램을 이해하기가 수월해진다. trim과 normalize로 함수 파이프라인을 수동으로 구성// trim :: String -&gt; Stringconst trim = (str) =&gt; str.replace(/^\\s*|\\s*$/g, '');// normalize :: String -&gt; Stringconst normalize = (str) =&gt; str.replace(/\\-/g, '');normalize(trim(\" 444-444-4444 \")) // '4444444444 형식은 틀림없이 중요한 이슈지만, 자바스크립트에서는 함수가 취하는 인수 개수의 호환 여부가 더 중요하다. 함수와 항수:튜플항수란 함수가 받는 인수의 개수다. 함수의 길이라고도 한다. 다른 프로그래밍에서는 항수를 당연하게 생각하지만 FP에서는 함수에 선언된 인수의 개수가 많아질 수록 복잡도가 증가하는 경우가 많다. 가령 문자열 인수를 하나만 받는 함수는 서너개 받는 함수보다 훨씬 단순하다고 볼 수 있다. // 인수가 1개인 순수함수는 한가지용도! 즉 단일 책임을 담당하므로 가장 단순한 함수// isValid :: String -&gt; Booleanfunction isValid(str) { ...}//makeAsyncHttp :: String, String, Array -&gt; Booleanfunction makeAsyncHttp(method, url, data) { // 모든 인수를 먼저 계산해야하므로 사용하기 어렵다. ...} 우리의 목표는 함수의 인수를 가능한한 적게 하는 것, 그래야 인수가 많은 함수보다 더 유연하고 다목적으로 활용할 수 있다. 하지만 단항 함수를 얻는 것은 쉽지않다. isValid가 오류 내용까지 메시지 형태로 반환하도록 고치면 isValid :: String -&gt; (Boolean, String)isValid(' 4444-44444-444 ') // (false, '입력값이 너무 길어요!') 그런데 이렇게 두가지 다른 값을 동시에 반환할 수 있을까???함수형 언어는 튜플이라는 자료구조를 지원한다. 튜플은 유한 원소를 지닌 정렬된 리스트로, 보통 한 번에 두세 개 값을 묶어 (a, b, c) 와 같이 쓴다. isValid가 검사 결과와 에러 메시지를 함께 묶은 튜플 형태로 결과를 내면 한 개체로 반환할 수 있고, 필요시 그 다음 함수에 건네줄 수 있다. 튜플은 형식이 다른 원소를 한데 묶어 다른 함수에 건네주는 일이 가능한 불변성 자료구조다. 물론 객체 리터럴이나 배열같은 임의의 형식으로 반환하는 방법이 있긴하지만 튜플이 다음 측면에서 더 유리하다. 불변성: 튜플은 한번 만들어지면 나중에 내용을 못 바꿈. 임의 형식의 생성 방지 : 튜플은 전혀 무관한 값을 서로 연관지을 수 있다. 단지 데이터를 묶겠다고 새로운 형식을 정의하고 인스턴스화하는 건 괜스레 데이터 모형을 복잡하게 할 뿐… 이형배열의 생성 방지 : 형식이 다른 원소가 배열에 섞여 있으면 형식을 검사하는 방어코드를 수반하므로 다루기가 까다롭다. 배열은 태생 자체가 동일한 형식의 객체를 담는 구조다. 튜플은 2장에 나왔던 값 객체와 작동방식이 유사. 자바스크립트에서는 튜플 자료형을 처음부터 지원하지 않아서 자신만의 튜플을 구현해서 쓰면 된다. // 4-2 형식화한 튜플자료형const Tuple = function(/* 형식 */) { // Array.prototype.slice.call(arguments)는 arguments.slice(), 즉 주어진 인자들의 배열을 복사한 배열을 얻는 역할 const typeInfo = Array.prototype.slice.call(arguments) // 튜플에 담긴 인수 형식을 읽는다. const _T = function(/* 값 */) { // 내부형 _T는 튜플의 형식과 값이 맞는지 확인 const values = Array.prototype.slice.call(arguments) // 튜플에 저장된 값을 꺼낸다. // null 값 유무를 체크. 함수형 자료형은 null 값이 스며드는 것을 허용해선 안된다. if (values.some(val =&gt; val === null || val === undefined)) { throw new ReferenceError(\"튜플을 null값을 가질 수 없다.\") } // 정의된 형식 개수와 튜플 항수가 일치하는지 체크 if (values.length !== typeInfo.length) { throw new TypeError(\"튜플 항수가 프로토타입과 맞지 않다.\") } // 각 튜플값의 형식이 올바른지 checkType함수로 조사. // 각 튜플의 원소는 ._n(원소 인덱스 n은 1부터 시작)로 참조가능한 튜플속성으로 바꾼다. values.forEach((val, index) =&gt; { this[\"_\" + (index + 1)] = checkType(typeInfo[index])(val) }, this) Object.freeze(this) // 튜플을 불변 인스턴스화한다. // 튜플 값을 전부 꺼내 배열로 만든다. // ES6 해체 할당을 이용하면 튜플 값을 변수로 매핑할 수 있다. _T.prototype.values = () =&gt; { return Object.keys(this).map(k =&gt; this[k], this) } } return _T} 위 코드에서 튜플 객체는 크기가 고정된 불변성 자료구조로, 함수 간 통신에 사용가능한 n개의 이형 값을 담을 수 있다. ES6부터 지원하는 해체할당destructuring assignment과 조합하면 튜플 값을 변수로 깔끔하게 매핑할 수 있다. // StringPair형식const StringPair = Tuple(String, String)const name = (StringPair(\"Barkley\", \"Rosser\")[(first, last)] = name.values())first // Barkleylast // Rosser// 항수가 맞지 않아 에러가 난다.const fullName = StringPair(\"J\", \"Barkley\", \"Rosser\") 튜플로 함수 항수를 줄일 순 있지만, 튜플만으로 만족스럽지 못할 땐 더 나은 방안이 있다.항수를 추상하는 동시에 모듈성, 재사용성을 높이는 함수 커링이라는 천연 조미료다. 커리된 함수를 평가커링을 이해하려면 먼저 일반(비커리된) 평가와 커리된 평가의 차이점을 분명히 인지해야 한다.자바스크립트에서는 비커리된 일반 함수를 호출할 때 인수가 모자라도 별문제없이 실행된다. 이와 달리 모든 매개변수가 명시된 커리된 함수에 일부 인수만 넣어 호출하면, 함수가 실행되는 게 아니라 모자란 나머지 인수가 다 채워지기를 기다리는 새로운 함수가 반환된다. 커링은 다변수 함수가 인수를 전부 받을 때까지 실행을 보류, 또는 지연시켜 단계별로 나뉜 단항 함수의 순차열로 전환하는 기법이다. 매개변수가 3개인 curry함수를 수학적으로 쓰면 다음과 같다. curry(f) :: ((a, b, c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d curry는 (a, b, c)라는 입력을 인수가 하나뿐인 호출로 해체하는 함수 간의 매핑이다.자바스크립트로는 자동으로 함수를 커리할 수 없으므로 직접 코드 구현해야한다. 먼저 수동으로 커리하는 간단한 예제를 보면 // 두 인수를 수동으로 커리function curry2(fn) { // 처음 curry2 호출시 첫번째인수를 포착 return function(firstArg) { // 두번째호출시 두번째인수를 포착 return function(secondArg) { // 두인수 firstArg, secondArg로 함수를 실행한 결과값을 반환 return fn(firstArg, secondArg) } }} 반환된 함수는 나중에 사용할 인수를 포착하기 위해 함수 래퍼를 중첩한 코드에 불과하다.커링은 클로저의 또다른 사례라고도 할 수 있다. const name = curry2(last, first) =&gt; new StringPair(last, first)// 두 인수를 모두 넣으면 함수평가가 완료[first, last] = StringPair(\"Barkley\", \"Rosser\").values()first // Barkleylast // Rosser// 하나만 넣으면 나머지 인수를 undefined로 넣고 평가하는게 아니라,// 또다른 함수를 반환name('Curry') // -&gt; Function 4-2에서 사용했던 checkType 함수를 람다JS라는 함수형 라이브러리의 함수를 빌려 구현해보자.람다JS의 모든 기능은 전역변수 R을 통해 접근가능하다.람다JS는 커링, 부분 적용, 합성 등의 기법을 구사할 때 매개변수를 간편하게 배열할 수 있기 때문 // checkType :: Type -&gt; Object -&gt; Objectconst checkType = R.curry((typeDef, obj) =&gt; { // R.is()로 형식 정보를 체크 if (!R.is(typeDef, obj)) { let type = typeof obj throw new TypeError(`형식 불일치: [${typeDef}]이어야 하는데, [${type}]이다.`) } return obj})checkType(String)(\"Curry\") // =&gt; 'Curry'checkType(Number)(3) // =&gt; 3checkType(Number)(3.5) // =&gt; 3.5let now = new Date()checkType(Date)(now) // =&gt; nowcheckType(Object)({}) // =&gt; {}checkType(String)(42) // =&gt; TypeError 단순한 작업이야 수동으로 커리할 수 있겠지만 기능이 복잡해지고 인수가 늘어나면 자동으로 처리할 방법이 필요하다. R.curry를 쓰면 인수 개수와 상관없이 순수 함수형 언어의 자동 커링장치를 모방할 수 있다.자동 커링은 선언된 인수 개수만큼 중첩된 함수 스코프를 인위적으로 생성하는 작업이라고 보면 된다. // fullname을 커리한 코드// fullname :: (String, String) -&gt; Stringconst fullname = function (first, last) { ...}// fullname :: String -&gt; String -&gt; Stringconst fullname = function (first) { return function (last) { ... } } 그렇다면, 커링은 어디에 써먹는 기법일까? 함수 팩토리모방 재사용 가능한 모듈적 함수 템플릿을 구현 함수 팩토리를 모방객체지향에서 인터페이스는 클래스가 반드시 구현해야할 규약을 정해놓은 추상적인 형식이다.동일한 인터페이스를 두 클래스가 구현한 예제 DB에서 학생정보 얻어오는 클래스 캐시에서 학생정보 얻어오는 클래스 호출자 관점에서 메서드를 호출한다는 사실이 중요하지, 객체의 출처는 관심없다. 이것이 바로 팩토리 메서드 패턴으로 설계한 객체지향코드의 아름다운 자태다. 자바스크립트로 바꿔보면 //fetchStudentFromDb :: DB -&gt; (String -&gt; Student)const fetchStudentFromDb = R.curry(function(db, ssn) { // 객체 db에서 찾는다. return find(db, ssn)})//fetchStudentFromArray :: Array -&gt; ( String -&gt; Student)const fetchStudentFromArray = R.curry(function(arr, ssn) { // 배열에서 찾는다. return arr[ssn]}) 이 함수는 커리해놔서 일반 팩토리 메서드 findStudent로 평가하는 부분과 함수를 정의한 부분을 떼어놓을 수 있다. 실제 구현부는 둘 중하나 const findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromArray(arr)findStudent(\"4444-444-4444\") 이제 다른 모듈의 호출자는 실제 구현부를 알지 못해도 얼마든지 findStudent를 가져다 쓸 수 있다. 재사용 가능한 함수 템플릿 구현애플리케이션의 상태(에러, 경고, 디버그 등) 별로 로그를 나누어 처리하고 싶은 경우가 있다.함수 템플릿은 생성 시점에 커리된 인수 개수를 기준으로 연관된 함수들을 묶어놓은 것 console.log보다 기능이 우수한 Log4js를 사용해서 예제를 들어보겠다. // Log4js의 일반적인 사용법const logger = new Log4js.getLogger(\"StudentEvents\")logger.info(\"학생이 정상적으로 추가되었다.\")// 로그를 팝업창에logger.addAppender(new Log4js.JSAlertAppender())// 로그메시지를 일반텍스트 대신 JSON형식으로logger.setLayout(new Log4js.JSONLayout()) 하지만 이렇게 일일이 개별 파일에 코드를 복붙하면 엄청난 중복이 발생…!재사용이 가능함 함수 템플릿(즉, 로거모듈)을 커링 기법으로 정의하는 편이 유연성, 재사용 측면에서 좋다. // 로거 함수 템플리을 만듦const logger = function(appender, layout, name, level, message) { // 원하는 appender를 정의 const appneders = { alert: new Log4js.JSAlertAppender(), console: new Log4js.BrowserConsoleAppender() } // 원하는 레이아웃 제공기를 정의 const layouts = { basic: new Log4js.BasicLayout(), json: new Log4js.JSONLayout(), xml: new Log4js.XMLLayout() } const appender = appneders[appender] appneder.setLayout(layouts[layout]) const logger = new Log4js.getLogger(name) logger.addAppender(appender) // 구성 매개변수를 모두 적용해서 로그를 남긴다. logger.log(level, message, null)} 로거를 커리하면 상황별로 적합한 로거를 모두 한곳에서 관리하고 재사용할 수 있다. // 마지막 두 인수만 빼고 모두 평가const log = R.curry(logger)(&apos;alert&apos;, &apos;json&apos;, &apos;FJS)log(&apos;ERROR&apos;, &apos;에러가 발생했습니다.&apos;)// =&gt; 팝업창을 띄우고 요청한 메시지를 경고 문구로 표시한다. 여러 에러 처리 구문을 하나의 함수나 파일로 구현하고 싶으면, 유연하게 마지막 매개변수를 제외한 나머지 매개변수를 부분 세팅하면 된다. const logError = R.curry(logger)(\"console\", \"basic\", \"FJS\", \"ERROR\")logError(\"코드 404 에러가 발생했습니다.\") 내부적으로는 이 함수에 curry함수를 연속 호출해서 결국 단항 함수 하나만 남을 것이다. 기존 함수에서 새 함수를 만들고 매개변수는 몇개라도 전달 가능하니 인수가 정해질때마다 단계별로 함수를 쉽게 쌓아 올릴 수 있다. 커링의 가장 중요한 의의는 다인수 함수를 단항 함수로 바꾼다는 것이다. 커링의 대용품인 부분 적용partial application과 매개변수 바인딩parameter binding은 자바스크립트에서도 어느 정도 지원되는 기법으로, 함수 파이프라인에 연결해도 잘 작동할 수 있도록 항수가 더 작은 함수를 만든다. 부분 적용과 매개변수 바인딩부분 적용은 함수의 일부 매개변수값을 처음부터 고정시켜 항수가 더 작은 함수를 생성하는 기법이다.커링처럼 부분 적용도 함수의 길이를 직접 줄이는 임무를 수행하지만 방법은 조금 다르다. 커링은 부분호출할 때마다 단항 함수를 중첩생성하며, 내부적으로는 이들을 단계별로 합성하여 최종 결과를 낸다. 커링은 여러 인수를 부분 평가하는 식으로도 변용할 수 있어서 개발자가 평가 시점과 방법을 좌지우지할 수 있다. 부분 적용은 함수 인수를 미리 정의된 값으로 묶은(할당한) 후, 인수가 적은 함수를 새로 만든다. 이 결과 함수는 자신의 클로저에 고정된 매개변수를 갖고 있으며, 후속 호출시 이미 평가를 마친 상태다. // 4-7. partial()구현부function partial() { let fn = this, boundArgs = Array.prototype.slice.call(arguments) // 로대시JS같은 라이브러리의 partial구현부는 언더스코어객체를 자리끼우개로 쓴다. // 대충만들어 쓸 때는 undefined로 해당 매개변수를 건너뛰게 한다. let placeholder = \"&lt;&lt;자리끼우개 객체&gt;&gt;\" // 모든 매개 변수가 부분적용된 새 함수를 생성 let bound = function() { let position = 0, length = boundArgs.length let args = Array(length) for (let i = 0; i &lt; length; i++) { // 자리끼우개 객체는 나중에 호출할 때 쓰려고 함수 매개변수를 정의하지 않고 건너뛰므로, // 어떤 매개변수를 바인딩하고 호출의 일부로 제공할지 개발자가 선택할 수 있다. args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i] } while (position &lt; arguments.length) { args.push(arguments[position++]) } // 적절한 콘텍스트와 바인딩된 인수를 Function.apply()에 넣고 함수호출 return fn.apply(this.args) } return bound} 방금전에 봤던 로거함수에 특정 매개변수를 부분 적용하면 더 구체적인 로직을 적용할 수 있다. const consoleLog = _.partial(logger, \"console\", \"json\", \"FJS 부분적용\") 이 함수를 보면서 커링과 부분 적용의 차이점을 다시 한번 보자.세 매개변수를 부분 적용해서 만든 consoleLog 함수를 호출(단계별로 나뉜 게 아니라 1회성 호출)하려면 다른 두 인수도 필요하다. 따라서 커링처럼 consoleLog함수에 인수를 하나만 준다고 새 함수가 생성되는 게 아니라, 마지막 인수처리에 undefined를 넣고 함수를 평가하게 된다. 커링은 부분 적용을 자동화한 것이다.커링과 부분 적용은 차이점을 아래와 같이 표현할 수 있다. //커링// 모든 인수가 다 들어올 때까지 함수를 리턴..var curriedFn = function(a) { return function(b) { return function(c) { return a + \", \" + b + \",\" + c + \"는 좋은 친구들입니다.\" } }}//부분 적용// 미리 셋팅된 a 매개변수외에 b, c에 대해서는 커링적용안됨. 없으면 없는대로 undefined로 처리됨var partialAppliedFn = function(a) { return function(b, c) { return a + \", \" + b + \",\" + c + \"는 좋은 친구들입니다.\" }} 부분 적용과 작동 방식은 다르지만, 비슷하게 동작하는 Function.prototype.bind() 함수를 응용한 함수 바인딩 기법도 있다. const log = _.bind(logger, undefined, \"console\", \"json\", \"FJS 바인딩\")log(\"WARN\", \"함수형 프로그래밍, 정말 멋지군!\") _.bind 함수의 두번째 인수는 왜 undefined일까? 바인딩 결과 생성된 함수는 소유 객체 콘텍스트에서 실행되므로 undefined를 넘겨서 전역콘텍스트에 바인딩하라고 런타임에 요청한 것이다. _.partial, _.bind 는 두가지 용도로 쓰인다. 언어의 핵심을 확장 지연된 함수에 바인딩 언어의 핵심을 확장부분 적용은 String, Number 같은 핵심 자료형을 확장하여 언어의 표현성을 풍부하게 할 목적으로 사용할 수 있다. // 문자열을 배열로 변환// match에 정규표현식을 부분적용해서 주어진 문자열을 특정 데이터가 포함된 배열로 변환// \\w : 영문자 및 _ 문자와 일치String.prototype.explode = _.partial(String.prototype.match, /[\\w]/gi)\"ABC\".explode() // ['A', 'B', 'C'] 지연된 함수에 바인딩소유 객체를 전제로 메서드를 다룰 때는 함수 바인딩으로 콘텍스트 객체를 세팅하는 일이 중요하다. const Scheduler = (function() { // undefined를 넘겨줘서 전역콘텍스트에서 실행되도록 const delayedFn = _.bind(setTimeout, undefined, _, _) return { delay5: _.partial(delayedFn, _, 5000), delay10: _.partial(delayedFn, _, 10000), delay: _.partial(delayedFn, _, _) }})()Scheculer.delay5(function() { consoleLog(\"5초 후에 실행\")}) 이렇게 스케쥴러만 있으면 함수 본체 안에 감싼 코드를 원하는 시간 이후에 실행시킬 수 있다.","link":"/2019/04/01/Programming/JavaScript/study-modular-code/"},{"title":"자바스크립트 this란 대체 무엇인가?","text":"자바스크립트에서 가장 오해하기 쉬운 개념 중 하나가 this 키워드다. 이 글에서 this 키워드가 무엇을 참조하는지 알아낼 수 있는 5가지 법칙을 배울거다. 암묵적 바인딩, 명시적 바인딩, new 바인딩, window 바인딩, lexical 바인딩. 더불어서 javascript에서 헷갈리는 부분 중 하나인 .call, .apply, .bind 그리고 new 키워드에 대한 것도 살펴볼것이다. this 키워드에 대해 구체적으로 알아보기 전에 애초에 왜 this 키워드라는 것이 있을까? 생각을 해보자. this 키워드는 다른 컨텍스트에서 함수를 재사용할 수 있게 한다. 다르게 말하면, this 키워드는 함수나 메소드가 호출될 때 어떤 object 에 초점을 맞출 것인지 결정할 수 있게 한다. 앞으로 이런 관점에서 this에 대해 알아볼거다. 우리는 다른 컨텍스트나 다른 object에서 함수, 메소드를 재사용할 수 있게 하고 싶다. this 키워드가 무엇을 참조하고 있는가 ⇒ 이 함수가 어디에서 호출되는가? this 키워드가 무엇을 참조하는지 알 수 있는 유일한 방법은 this 키워드를 이용하는 함수가 호출된 위치를 확인하는 것이다. Implicit Binding가장 일반적인 규칙이다. 거의 80% 정도가 this가 무엇을 참조하는지 이 규칙을 통해 알 수 있다. const user = { name: \"Tyler\", age: 27, greet() { alert(`Hello, my name is ${this.name}`) }}user.greet() // Hello, my name is Tyler look to the left of the dot when the function is invoked 만약 . 이 있다면 . 의 왼쪽에 있는 object를 찾아라. 그게 this가 참조하고 있는 것이다. const user = { name: \"Tyler\", age: 27, greet() { alert(`Hello, my name is ${this.name}`) }, mother: { name: \"Stacey\", greet() { alert(`Hello, my name is ${this.name}`) } }}user.greet() // Hello, my name is Tyleruser.mother.greet() // Hello, my name is Stacey 위의 예제에서도 동일하게 left of the dot 규칙이 통하는 것을 볼 수 있다. 그런데 만약 . 이 없으면? Explicit Binding아래와 같이 greet 함수가 user object에 속한 메서드가 아니라 단독 함수라면 function greet() { alert(`Hello, my name is ${this.name}`)}const user = { name: \"Tyler\", age: 27} this 가 user obejct를 참조하도록 하면서 greet함수를 호출하려면 어떻게 해야할까? call 함수를 통해 가능하다. call은 모든 함수에 있는 메소드로, 함수가 호출될 컨텍스트를 지정하여 함수를 호출할 수 있게 한다. greet.call(user) 이것이 바로 명시적 바인딩이다. this 키워드가 무엇을 참조할 지 명시적으로 알려주는 방법이다. 만약 파라미터가 필요한 함수라면 function greet(l1, l2, l3) { alert(`Hello, my name is ${this.name} and I know ${l1}, ${l2}, and ${l3}`)}const languages = [\"JavaScript\", \"Ruby\", \"Python\"]greet.call(user, languages[0], languages[1], languages[2]) call 함수의 첫번째 인자로 컨텍스트를 넣은 다음, 차례대로 인자를 넣어주면 된다. 하지만 이렇게 일일이 인자를 넣어주는 게 귀찮다면, .apply 함수를 사용해서 인자를 한번에 배열로 넣어주면 된다. const languages = [\"JavaScript\", \"Ruby\", \"Python\"]greet.apply(user, languages) 마지막으로 .bind를 살펴보면, .call 함수와 동일한데 즉시 함수를 호출하는 게 아니라 바인딩된 새로운 함수를 리턴하는 것이 다르다. const newFn = greet.bind(user, languages[0], languages[1], languages[2])newFn() new Bindingnew 키워드로 함수를 호출하면 자바스크립트 인터프리터는 새로운 object를 리턴하는데 this는 그 새로운 object를 참조한다. function User(name, age) { this.name = name this.age = age}const me = new User(\"Tyler\", 27) Lexical BindingES6부터 도입된 arrow function은 일반 function과 다르게 함수 자체의 this를 가지고 있지 않다. 대신 lexical하게 this를 결정짓는다. 예제로 알아보자. ( lexical scope : 바깥에서 선언한 변수는 안쪽에서 접근 가능하다) 아래와 같이 user object를 만든다. const user = { name: \"Tyler\", age: 27, languages: [\"JavaScript\", \"Ruby\", \"Python\"], greet() { const hello = `Hello, my name is ${this.name} and I know` const langs = this.languages.reduce(function(str, lang, i) { if (i === this.languages.length - 1) { return `${str} and ${lang}.` } return `${str} ${lang},` }, \"\") alert(hello + langs) }}user.greet() // Uncaught TypeError: Cannot read property 'length' of undefined this.languages 가 undefined 여서 Cannot read property ‘length’ of undefined 에러가 발생한다.원래 바라는 바는 this가 user object를 참조하는 것인데, 어디서 잘못됐는지 차근차근 확인해보자. 어디서 함수가 호출되었나? → language 문자열을 합치는 함수는 reduce 함수에 전달되었다. reduce 함수내에서 어떻게 함수가 호출되는지 정확히 알 수 없다. 이 부분이 문제다! 우리는 function (str, lang, i) { if (i === this.languages.length - 1) { return `${str} and ${lang}.` } return `${str} ${lang},` } 이 함수가 user 컨텍스트에서 호출될 수 있도록 명시적으로 알려줘야 한다. bind를 이용해서 user 를 참조하는 this를 바인딩해주면 된다. greet() { const hello = `Hello, my name is ${this.name} and I know` const langs = this.languages.reduce(function (str, lang, i) { if (i === this.languages.length - 1) { return `${str} and ${lang}.` } return `${str} ${lang},` }.bind(this), \"\") alert(hello + langs)} 하지만 좀 보기 복잡한 면이 있다. arrow function 은 렉시컬 스코프에 의해 this를 결정짓는다고 이전에 언급했었다. arrow function을 이용하면 this를 명시적으로 바인딩해주지 않아도 부모 스코프의 this를 참조한다. (Arrow functions don’t have their own this.) const langs = this.languages.reduce((str, lang, i) =&gt; { if (i === this.languages.length - 1) { return `${str} and ${lang}.` } return `${str} ${lang},`}, \"\") window Binding자바스크립트는 기본적으로 this 키워드는 window object를 참조하고 있다. (Node.js에서는 global object) function sayAge() { console.log(`My age is ${this.age}`)}const user = { name: \"Tyler\", age: 27}sayAge() // My age is undefined 하지만 window object에 age 프로퍼티를 추가하면 정상적으로 age가 출력된다. window.age = 27function sayAge() { console.log(`My age is ${this.age}`)}sayAge() // My age is 27 참고로 ES5부터 “엄격 모드”를 활성화하면 JavaScript가 올바른 작업을 수행하며 창 객체를 기본값으로 사용하는 대신 “this”를 정의되지 않은 상태로 유지한다. \"use strict\"window.age = 27function sayAge() { console.log(`My age is ${this.age}`)}sayAge() // TypeError: Cannot read property 'age' of undefined 다시 한번 정리해보자면, this 키워드가 무엇을 참조하는지는 아래의 순서에 따라 판단하면 된다. 함수가 어디에서 호출됐는지 확인 . 왼쪽에 object가 있나? 그 object가 this 키워드가 참조하는 거다. 만약 그렇지 않다면 #3 규칙으로 함수가 call, apply, bind를 이용해서 호출됐나? 그렇다면 call, apply, bind의 첫번째 인자가 바로 this 키워드가 참조하고 있는 것이다. 아니면 #4 규칙으로 함수가 new 키워드로 호출됐나? 그렇다면 this 키워드는 새롭게 생성된 object를 참조하고 있다. 아니면 #5로 화살표함수 안에 this가 있나? 그렇다면 부모 스코프에서 this 가 무엇을 참조하는지 찾을 수 있을거다. 아니면 #6으로 strict mode인가? 그렇다면 this 는 undefined다. 아니면 #7로 위의 모든 케이스에 해당되지 않는다면, this는 window object를 참조하고 있다! 참고 https://www.youtube.com/watch?v=NV9sHLX-jZU https://tylermcginnis.com/this-keyword-call-apply-bind-javascript/","link":"/2020/02/27/Programming/JavaScript/this/"},{"title":"스터디 - 고계 자바스크립트","text":"이번에 정리할 내용은 Chapter 2. 고계 자바스크립트이다. 이 장의 내용 자바스크립트가 함수형 언어로 적합한 이유 자바스크립트는 다중 패러다임 개발이 가능한 언어 불변성 및 변경에 대한 정책 고계함수와 일급 함수 클로저와 스코프 개념 클로저의 활용 왜 자바스크립트인가? 편재성(어디에나 있음) - 동적형식(dynamically typed)이고 객체지향적 범용언어이자 프로그래밍 언어 중에 가장 널리 쓰이면서, 모바일, 웹사이트, 웹서버, 데스크톱, 임베디드 애플리케이션, 심지어 DB에 이르기까지 광범위하게 쓰인다. 아직도 꾸준히 진화, 개선 중이다 - 현재 가장 주력버전인 ES6에서는 화살표함수, 상수, 이터레이터, 프로미스 등 함수형 프로그래밍에 걸맞은 기능이 많이 추가되었다. 함수형 장치가 많이 탑재되었지만, 자바스크립트는 어디까지나 함수형인 동시에 객체지향 언어라는 사실을 명심해야한다.많은 개발자들이 가변 연산, 명령식 제어구조, 객체 인스턴스의 상태를 변경하는 코드를 아무렇지 않게 쓰고 있어 진짜 함수형 자바스크립트 코드는 흔치않다. 그럼 먼저 객체지향과 함수형 프로그래밍의 패러다임 차이를 살펴보자. 함수형 대 객체지향 프로그래밍함수형/객체지향 모두 중대형 시스템 개발에 사용가능하다. 자바스크립트는 이 두 패러다임을 적절히 잘 버무려놓은 언어라 이 둘을 잘 조합해서 사용할 수 있다. 개발자의 개인적인 취향과 해결해야할 문제의 요건에 따라 조합이 달라질 수 있다. 먼저, 함수형/객체지향 두 접근 방법이 서로 어떤 차이점이 있는지 이해해보자. 어떤 학습 관리 시스템의 Student 객체를 간단히 모형화modeling한다고 하자. Student는 클래스나 형식 계층 관점에서 성, 이름, 주소 같은 기본 속성을 포함한 Person의 하위형이라고 볼 수 있다.추가할 기능이 있으면 Student보다 더 구체화한 형식, CollegeStudent 같은 형식을 만들어 붙이면 된다.==&gt; 객체지향 프로그램의 핵심이 바로!! 새로운 파생객체를 생성하여 코드를 재사용하는 것! 객체지향과 함수형의 가장 중요한 차이점은 바로 이런 데이터(객체 속성)와 기능(함수)을 조직하는 방법에 있다. 객체지향 프로그래밍인스턴스 메소드를 통해 가변 상태를 노출하고 조작할 수 있도록, 객체 기반의 캡슐화에 지나치게 의존한 채 가변 상태의 무결성을 유지힌다. 결국 객체의 데이터와 잘게 나뉜(fine-grained) 기능이 단단히 유착되어 응집도가 높은 패키지가 형성된다.객체지향의 모든 추상화의 주된 형태가 객체이다. 함수형 프로그래밍호출자caller로부터 데이터를 숨길 필요 없이 소규모의, 아주 단순한 자료형만을 대상으로 움직인다(?) 데이터와 기능을 느슨하게 결합한다. 여러 자료형에 두루 적용 가능하고 굵게 나뉜(coarse-grained)연산에 더 의존한다.함수는 함수형 패러다임의 주된 추상화 형태이다. 두 패러다임을 잘 활용하려면 객체를 불변 개체entity나 불변 값으로 바라보고 기능을 함수로 분리하여 객체 내에서 작동되게끔 해야한다. 예를 들면, // 메소드는 대개 this로 객체 상태에 접근get fullname() { return [this._firstname, this._lastname].join(' ');}// this는 사실상 전달받은 객체로 교체var fullname = person =&gt; [person.firstname, person.lastname].join(' '); 자바스크립트의 동적 형식언어라 fullname()은 Person의 모든 파생형 객체(또는 firstname, lastname 속성을 가진 객체 전부)에서 잘 작동한다. =&gt; 다형성polymorphic함수를 지원한다. OOP는 (Parent에서 Student가 나오듯) 메소드에 상속 계층을 두고 데이터를 서로 단단히 묶는 일에 열중한다. 반면 FP는 다양한 자료형을 아우르는 일반적인 다형성 함수를 선호하며 this는 가급적 사용하지 않는다.fullname()을 독립형 함수로 분리하면 객체 데이터를 this로 접근할 이유가 사라진다. this를 쓰면 메소드 스코프 밖에 위치한 인스턴스 수준의 데이터에 접근할 수 있어서 부수효과를 일으킬 수 있다. FP로 개발한 코드는 객체 데이터가 특정코드에 종속되지 않아 재사용성, 유지보수성이 좋다. 어떤 사람Person과 거주 국가가 같은 사람을 전부 찾고, 어떤 학생Student과 거주 국가와 다니는 학교가 모두 같은 학생을 전부 찾는 코드를 개발해보자. 객제지향적으로this와 super로 한 객체와 그 부모 객체가 단단히 결합된 코드가 될 것이다.//Person 클래스peopleInSameCountry(friends) { var result = [] for ( let i in friends ) { var friend = friends[i] if(this.address.country === friend.address.country) { result.push(friend) } } return result} // Student 클래스studentInSameCountryAndSchool(friends) {// super로 부모클래스에 접근하여 데이터를 받아온다var closeFriends = super.peopleInSameCountry(friends)var result = []for ( let i in closeFriends ) {var friend = closeFriends[i]if(firend.school === this.school) {result.push(friend)}}return result} church.studentInSameCountryAndSchool([curry, turing, kleene]) 2. 함수형으로 순수성과 참조 투명성에 기반을 둔 FP방식을 따르면, 상태와 기능을 철저히 분리한 다음 이들을 다시 조합한 새로운 함수로 연산을 추가할 수 있다. 문제를 작은 함수들도 잘게 나눈다.```bash// 학생의 거주 국가와 학교를 비교하는 selector함수var selector = (country, school) =&gt; (student) =&gt; student.address.country === country &amp;&amp; student.school === school;// 원하는 필터 기준을 selector함수로 주입하여 배열 원소를 걸러낸다var findStudentBy = (friends, selector) =&gt; friends.filter(seletor)//findStudentBy는 Person과 연관된 객체, 또 school, country를 조합한 객체를 받아 작동하는 함수다.findStudentBy([curry, turing, church, kleene], selector(&apos;US&apos;, &apos;Princeton&apos;)) 이제 두 패러다임의 차이점이 확실히 보이나요? 객체지향은 데이터와 데이터 관계의 본질에 초점을 두고!함수형의 관심사는 해야할 일, 즉 기능!! 자바스크립트 객체의 상태 관리프로그램의 상태state란 어느 한 시점에 찍은 모든 객체에 저장된 데이터의 스냅샷snapshot이다.자바스크립트는 너무나 동적이어서 언제건 속성을 추가, 삭제, 수정할 수 있다. 데이터를 완전히 캡슐화하고 보호하는 건 개발자가 훈련을 통해 엄격히 지켜야할 목표다!! 객체를 값으로 취급프로그래밍 언어에서 문자열과 숫자는 처음부터 불변값이라 가장 이해하기 쉬운 자료형이다. 이런 식으로 동작하는 형식들을 값value라고 한다. 1장에서 불변성을 바탕으로 사고하려면 사실상 모든 객체를 값으로 취급해야한다고 했다. 여러 프로그래밍언어는 자바의 final과 같이 객체의 속성을 불변 상태로 고정시키는 장치를 지원한다. 그러나 자바스크립트에서는 자료형의 불변성을 지원하지 않는다. 기본형 값은 불변이지만 기본형을 가리키는 변수 상태가 바뀌니까.다른 언어를 적어도 흉내라도 내려면 사용자 정의 객체도 마치 처음부터 불변이었던 것 처럼 작동시킬 수 있어야한다. 상수 레퍼런스 constant reference는 ES6부터 추가된 const 키워드로 선언한다. 값을 재할당하거나 레퍼런스를 다시 선언할 수 없다. const gravity_ms = 0.806gravity_ms = 20 // 에러발생 하지만 const로는 FP가 요구하는 수준의 불변성을 실현하기 어렵다. const student = new Student('Mina', 'Choi', '111-2222', 'Princeton')student.lastname = 'Kim' //속성값이 바뀐다. 더 업격한 불변성 정책이 필요하다!!객체 구조가 단순하다면 값 객체 패턴 value-object pattern도 괜찮은 방안이다.값 객체는 객체의 동등성equality가 항등성identity나 레퍼런스가 아닌, 오직 값에 따라 좌우되는 객체! 일단 값 객체를 선언한 이후에 그 상태는 절대 변하지 않는다. function zipCode(code, location) { let _code = code let _location = location return { code: function() { return _code }, location: function() { return _location }, fromString: function(str) { let parts = str.split('-') // 새로운 객체를 반환 return zipCode(parts[0], parts[1]) }, toString: function() { return _code + '-' + _location } }}const princetonZip = zipCode('08544', '3345')princetonZip.toString() // '08544-3345' 메소드를 일부만 호출자caller에게 공개하고, _code, _location을 의사-프라이빗pseudo-private 변수처럼 다루는 객체 리터럴 인터페이스object literal interface를 반환하는 식으로 자바스크립트 함수를 이용하면 우편번호의 내부 상태 접근을 차단할 수 있다. 값 객체는 함수형 프로그래밍의 영향을 받은 객체지향 디자인 패턴으로, 서로 다른 패러다임이 상호 보완적인 관계를 유지할 수 있음을 보여주는 실례다. 하지만 실세계의 문제를 전부 값 객체로 모형화modeling하기엔 충분치 않다. 다행히 자바스크립트에는 Object.freeze()라는 멋진 방법이 있다. 가동부를 깊이 동결Object.freeze()함수는 writable 속성을 false로 셋팅해서 객체 상태를 못 바꾸게 동결한다. const student = Object.freeze(new Student('Mina', 'Choi', '111-2222', 'Princeton'))student.lastname = 'Kim' // 에러발생!! Cannot assign to read only property!! Object.freeze()는 상속한 속성까지 고정하므로 Student 인스턴스를 동결하면 그 부모인 Person이 물려준 속성까지 모두 같은 방법으로 동결한다. 단, 중첩된 객체 속성까지 동결하는 건 불가능 Object.freeze()는 얕은 연산이라서 확실히 동결하고 싶을 때는 일일이 수작업으로 동결해야한다. // 재귀함수로 객체를 깊이 동결var isObject = val =&gt; val &amp;&amp; typeof val === 'object'function deepFreeze(obj) { if(isObject(obj) //아직 동결되지 않은 객체만 동결 &amp;&amp; !Object.isFrozen(obj)) { Object.keys(obj).forEach(name =&gt; deepFreeze(obj[name])) //루트 객체 동결 Object.freeze(obj) } return obj} BUT!!상태를 전혀 바꾸지 않는 애플리케이션이란 그리 현실적이지 않다.!따라서 복잡다기함을 줄인다는 차원에서 원본 객체에서 새 객체를 만드는 엄격한 정책을 허용하면 크게 도움될거다. 객체 그래프를 렌즈로 탐색/수정함수형으로 접근해서 객체의 불변 상태를 한곳에서 관리하는 렌즈lense라는 기법// 작업중… 함수함수형 프로그래밍에서 함수는 작업의 기본 단위!함수function은 () 연산자를 적용하여 평가할 수 있는 모든 호출 가능 표현식을 가리키며, 호출자caller에게 계산한 값 또는 undefined를 반환한다.FP의 함수는 사용 가능한 결과를 낼 경우에만 유의미하다.이 책에서는 표현식expression(값을 내는 함수)과 구문statement(값을 내지 않는 함수) 두 용어를 구분한다. 함수를 일급 시민으로자바스크립트 함수는 실제로 객체이기 때문에 일급first-class이며 일급시민이라고도 한다. // 함수를 선언하는 방법1. function multiplier(a, b) { return a * b }2. const square = function (x) { // 익명함수 return x * x } const sqaure = x =&gt; x * x // 람다표현식 함수를 호출할 때는 square(2) 함수 객체 자체를 출력하려면 sqaure // 객체 속성에서 메소드 형태로 할당할 수도 있다. const obj = { method: function (x) { return x * x } }3. 많이 쓰이지는 않지만 생성자를 통해 함수를 인스턴스화 하는 방법도 있다. const multiplier = new Function('a', 'b', 'return a * b') multiplier(2, 3) // 6 자바스크립트 함수는 모두 Function 형식의 인스턴스다.함수의 length 속성은 정규 매개변수 개수를 나타내고, apply(), call() 메소드는 함수를 주어진 콘텍스트로 호출한다. 익명함수는 어떤 함수의 기능을 확장하거나 특화시킬 때 인수로 전달한다. 예를 들어, Array.sort는 비교자comparator함수 객체를 인수로 받고, sort는 기본적으로 원소를 문자열로 바꾼 후 유니코드 값을 기준으로 자연정렬natural sorting한다. // 기본 sortconst fruit = ['Coconut', 'apples']fruit.sort() // ['Coconut', 'apples']// 커스텀people.sort((p1, p2) =&gt; p1.getAge() - p2.getAge() // comparator 함수) sort() 같은 자바스크립트 함수는 값을 할당할 수 있으면서 다른 함수도 인수로 받을 수 있으므로 고계함수 범주에 속한다. 고계함수함수도 작동 원리는 일반 객체와 같아서 함수를 인수로 전달하거나 함수를 반환받을 수 있다. 이런 함수를 고계함수higher-order function이라고 한다. // 한 함수를 다른 함수의 인자로 넘기는 예function applyOperation(a, b, opt) { return opt(a, b)}const multiplier = (a, b) =&gt; a * bapplyOperation(2, 3, multiplier) // 6// 다른 함수를 반환하는 예function add(a) { return function(b) { return a + b }}add(3)(3) // 6 자바스크립트에서 함수는 일급 + 고계여서 다른 값들과 똑같다!!! 즉, 자신이 받은 입력값을 기반으로 정의된 언젠가는 실행될yet-to-executed 값일 뿐이다. 고계함수를 조합하여 유의미한 표현식을 만들기도 한다. 미국 거주자 명단을 출력하는 프로그램을 생각해보자! // 알기 쉽게 명령형으로 작성하면function printPeopleInTheUs(people) { for ( let i = 0; i &lt; people.length; i++ ) { var thisPerson = people[i] if(thisPersion.address.country === 'US') { console.log(thisPerson) } }}printPeopleInTheUs([p1, p2, p3]) 이것을 고계함수를 사용해서 멋지게 추상화해보면!!! function printPeople(people, action) { for ( let i = 0; i &lt; people.length; i++ ) { action(people[i]) }}function action(person) { if(thisPersion.address.country === 'US') { console.log(thisPerson) }}printPeople(people, action) multiplier, comparator, action 같은 명사로 함수를 명명하는 건 자바스크립트 같은 언어에서 볼 수 있는 독특한 패턴이다. 자바스크립트 함수는 일급이라서 일단 변수에 할당한 뒤 나중에 실행해도 된다. // printPeople를 리팩토링해서 고계함수의 장점을 한 껏 살려보면!!function printPeople(people, selector, printer) { people.forEach(function(person) { if(selector(person)) { printer(person) } })}const inUs = person =&gt; person.address.country === 'US'// 고계함수를 쓰면 선언적 패턴이 점점 늘어나기 시작해서표현식만 봐도 프로그램이 하는 일을 파악할 수 있다.printPeople(people, inUs, console.log) 함수 호출 유형자바스크립트 함수는 호출 시점의 런타임 콘텍스트, 즉 함수 본체 내부의 this값을 자유롭게 지정할 수 있으며 호출방법도 다양하다. 1. 전역 함수로 호출 : this 레퍼런스는 전역 객체, 또는 undefined(엄격모드에서)function doWork() { this.myVar = '어떤 값'}doWork() // doWork()에서의 this레퍼런스는 전역객체를 가르킨다.2. 메소드로 호출 : this레퍼런스는 항상 메소드를 소유한 객체이다.var obj = { prop: '어떤 속성', getProp: function() { return this.prop // 객체매소드 호출시 this는 소유객체를 가리킨다. }}obj.getProp()3. 앞에 new를 붙여 생성자로 호출 : 새로 만든 객체의 레퍼런스를 암시적으로 반환function MyType(arg) { this.prop = arg // 함수를 new로 호출할 경우 this가 가리키는 것은 방금전 생성되어 반환된 객체}var someVal = new Mytype('어떤 인수') 위에서 보는 바와 같이 this 레퍼런스가 가리키는 대상은 함수를 사용하는 방법에 따라 달라진다.그러므로 함수가 실행되는 콘텍스트를 잘 살펴야한다. 함수 메서드자바스크립트 함수는 프로토타입에 소속된 (일종의 상위함수) apply와 call 메소드로도 호출할 수 있다. // 함수를 인수를 받아 그 실행결과를 논리적으로 부정하는 함수function negate(func) { return function() { // Function.apply()로 원본 인수를 넣어 함수실행 return !func.apply(null, arguments) }}function isNull(val) { return val === null}// isNull을 부정하여 isNotNull함수를 정의const isNotNull = negate(isNull)isNotNull(null) // falseisNotNull({}) // true apply는 인수 배열을, call은 인수를 목록으로 받는다. Function.prototype.apply(thisArg, [매개변수 배열])Function.prototype.call(thisArg, arg1, arg2) thisArg가 어떤 객체면 그 객체가 메소드의 호출자로 세팅된다. null이면 전역 함수처럼 작동하는 엄격모드에서 실행하면 실제 null값이 들어간다. 클로저와 스코프클로저는 함수를 선언할 당시의 환경에 함수를 묶어둔 자료구조이다. 정적스코프static scope, 어휘스코프lexical scope라고도 한다. function zipCode(code, location) { let _code = code let _location = location return { code: function() { return _code }, location: function() { return _location }, fromString: function(str) { let parts = str.split('-') // 새로운 객체를 반환 return zipCode(parts[0], parts[1]) }, toString: function() { return _code + '-' + _location } }}const princetonZip = zipCode('08544', '3345')princetonZip.code() // 08544 위 코드를 보면 zipCode 함수가 반환한 객체 리터럴이 이 함수 스코프 밖에 선언된 변수 _code에 자유롭게 접근할 수 있다. 즉 zipCode 실행 이후에도 그 결과 반환된 객체는 자신을 감싼 함수에 선언되었던 정보를 계속 참조할 수 있다. 함수가 자신을 둘러싼 주변 상태에 접근할 수 있기 때문에 클로저를 이용하면 명확하고 가독성 높은 코드를 작성할 수 있다. 또 클로저는 이벤트 처리 및 콜백, 프라이빗 변수 모방, 그리고 자바스크립트의 일부 약점을 보완하는 용도로 유익하다. 함수 클로저의 작동 규칙은 자바스크립트의 스코핑 규칙과 밀접한 관련이 있다. 스코프는 일련의 변수 바인딩을 한데 모아 변수가 정의된 코드 영역을 확정하는데, 클로저는 함수의 스코프를 상속한 것이다. function makeAddFunction(amount) { // add함수는 makeAddFunction에 바인딩되어 amount변수에 접근가능 function add(number) { return number + amount } return add}var addToTen = makeAddFunction(10)addToTen(10) // 20 위의 예제에서 amount변수는 더이상 활성스코프에 없지만 반환된 함수를 호출하면 여전히 되살릴 수 있다. 중첩된 함수 add가 자신의 계산로직뿐만 아니라 자신을 둘러싼 모든 변수의 스냅샷을 간직하고 있기 때문!일반적으로 함수의 스코프는 다음 두 가지를 포함 모든 함수 매개변수 (전역 변수를 포함해서) 바깥 스코프에 위치한 모든 변수 //클로저var outputVar = 'Outer'function makeInner(params) { var innerVar = 'Inner' function inner() { console.log(`${outerVar}, ${innerVar}, ${params}이 보여요`) } return inner}var inner = makeInner('Params')inner() // Outer, Inner, Params이 보여요 makeInner가 반환한 함수가 자신이 선언되었던 스코프에 존재했던 변수들을 모두 기억해서 쓰레기통으로 들어가지 않게 붙잡아둔 것! 전역 스코프의 문제점전역 스코프global scope는 가장 단순하면서, 가장 나쁜 스코프.전역 스코프에는 어느 함수에도 포함되지 않은 객체 및 변수가 자리하고, 어디에서는 접근가능하다. 그래서 namespace가 충돌할 소지가 높고, override문제도 발생할 수 있다. 전역 데이터는 변수 상태가 언제 어떻게 바뀌는지 머릿속으로 따라가야해서 코드가 많아질수록 복잡도가 높아진다. FP스타일로 개발할 땐 되도록 전역변수는 삼가야한다. 자바스크립트의 함수 스코프함수 스코프function scope는 자바스크립트가 선호하는 스코프 방식이다. 함수 내부에 선언된 변수는 모두 해당 함수의 지역변수라서 다른 곳에서는 안 보이고, 함수가 반환되는 시점에 이들은 모두 사라진다. function doWork() { let student = new Student() let address = new Address() .... // student와 address는 doWork함수에 바딩인된 지역 변수라서 함수 밖에서는 접근할 수 없다.} 변수 찾는 순서 변수의 함수 스코프를 체크 지역 스코프에 없으면 자신을 감싼 바깥쪽 어휘스코프로 이동해서 전역 스코프에 도달할 때까지 변수 레퍼런스를 찾는다. 그래도 참조하는 대상이 없으면 undefined 의사 블록 스코프표준 ES5 자바스크립트는 for, while, if, swith처럼 제어 구조를 중괄호 {}로 감싼 블록 수준의 스코프를 지원하지 않는다. function doWork() { if(!myVar) { var myVar = 10 } console.log(myVar) // 10}doWork() myVar변수는 if문 내부에서 선언했지만 if블록 바깥에서도 보인다.자바스크립트는 내부적으로 변수와 함수 선언부를 현재스코프(여기서는 함수스코프) 제일 위쪽으로 호이스팅hoisting(끌어올림)하기 때문에 이런 일이 발생한다. // 모호한 루프 카운터 문제var arr = [1, 2, 3, 4]function processArr() { function multipleBy10(val) { i = 10 // var i = 10 으로 바꾸면 함수 내부 스코프에 한정되어 루프카운터 i와 충돌하지 않는다. return val * i } // 루프카운터 i는 processArr함수의 최상단으로 이동하여 선언, multipleBy10함수의 클로저에 포함. // 루프카운터가 뜻하지 않게 10으로 변경 for(var i = 0; i &lt; arr.length; i++) { arr[i] = multipleBy10(arr[i]) } return arr}processArr() // [10, 2, 3, 4] ES6부터는 let 키워드로 루프 카운터를 해당 루프블록에 바인딩하여 모호함을 어느정도 극복할 수 있다. // let을 쓰면 호이스팅 문제가 해소되고 i는 제 스코프에 위치한다.for(let i = 0; i&lt;arr.length; i++) { // ....}i // undefined 클로저 응용클로저를 이용하면 자바스크립트의 독특한 함수 체제를 멋지게 활용할 수 있다. 프라이빗 변수를 모방다른 프로그래밍 언어에서는 private과 같은 접근제어자로 내부 속성을 셋팅할 수 있다. 자바스크립트에는 이러한 키워드가 없다.다행히 클로저를 이용하면 비슷하게 흉내낼 수 있다.위에서 본 zipCode함수가 객체를 반환하는 부분이 그렇다. 객체 리터럴을 반환하고, 이 객체는 자신을 감싼 함수의 지역 변수에 접근하는 메소드가 있다. 하지만 지역 변수 자체는 노출하지 않기 때문에 꽤 그럴싸하게 프라이빗 변수처럼 쓸 수 있다. 전역범위의 데이터 공유를 피하기 위해 전역 namespace를 관리하는 수단으로도 쓰인다.실제로 자바스크립트 라이브러리, 모듈 개발자는 전체모듈의 프라이빗 메소드와 데이터를 숨길 때 클로저를 활용! 이것을 모듈패턴module-pattern이라고 한다. // 대략적인 모듈의 뼈대var MyModule = (function MyModule(export) { // 에러발생시 스택을 보며 추적할때 IIFE를 식별할 수 있게 함수이름을 붙인다. let _myPrivateVar = \"\" // 두 메소드를 제외하고 프라이빗 변수는 이 함수 바깥에서 접근할 수 없다. export.method1 = function () { // 이 객체 스코프 아래에서 메소드를 전역범위로 표출. 그 결과 의사 이름공간이 생성 } export.method2 = function () { } return export;}(MyModule || {})) // 모든 숨겨진 상태와 메소드를 은밀히 포함한 단일 객체, MyModule.method1()으로 호출 서버 측 비동기 호출자바스크립트의 일급 고계함수는 다른 함수에 콜백으로 건넬 수 있다. getJSON('/students', (students) =&gt; { getJSON('/students/grades', // 두 응답 모두 처리 grades =&gt; progressGrades(grades), error =&gt; console.log(error.message)) // 점수조회중 발생한에러처리 }, (error) =&gt; { console.log(error.message) // 학생조회중 발생한 에러처리 } ) 고계함수 getJSON은 성공/실패 두 콜백함수를 인수로 받는다. 가상의 블록 스코프 변수를 생성함수형으로 접근하면 클로저와 함수 스코프를 적극 활용한 forEach를 사용하면 된다. arr.forEach(function(ele, i) { ...}) 이 장을 마치며 자바스크립트는 OOP와 FP 양쪽 다 가능한 팔방미인 언어다. OOP에 불변성을 도입하면 함수형 프로그래밍을 멋지게 쓸 수 있다. 고계/일급 함수는 함수형 자바스크립트를 구사하는 근간이다. 클로저는 정보 감춤, 모듈개발 뿐만 아니라 여러 자료형에 걸쳐 굵게 나뉜 함수에 원하는 기능을 매개변수로 넘기는 등 다양한 쓰임새로 쓰인다. 본 스터디는 “함수형 자바스크립트” 책을 중심으로 진행한다.","link":"/2019/03/07/Programming/JavaScript/study-high-order-javascript/"},{"title":"var, let, const를 사용하여 생성된 변수들의 차이점","text":"실무에서 변수를 선언할 때, 값의 재할당이 필요한 경우 let을, 아닌 경우 const를 사용했다. var를 사용하는 일은 거의 없었다.var, let, const에 대해서 술술 말할 수 있도록 정리를 해보았다. 1. var 은 함수 스코프, let과 const 는 블록스코프function foo() { // 함수 내에서는 모든 변수에 접근할 수 있다. var bar = \"bar\" let bae = \"bae\" const baw = \"baw\" console.log(bar) console.log(bae) console.log(baw)} function foo() { if (true) { var bar = \"bar\" let bae = \"bae\" const baw = \"baw\" } // var로 선언된 변수는 함수내에서 어디서나 접근 가능하다. console.log(bar) // bar // let, const로 선언된 변수는 정의된 블록 외부에서 접근 할 수 없다. console.log(bae) // ReferenceError:bae is not defined console.log(baw) // ReferenceError:baw is not defined} 2. var로 선언한 변수는 호이스팅되고 let, const는 그렇지 않다.function foo() { // var로 선언한 변수는 호이스팅된다. 변수가 선언되기 전에 코드에서 참조될 수 있다. console.log(bar) // undefined var bar = \"bar\" // let, const에서는 호이스팅을 허용하지 않는다. //ReferenceError: Cannot access 'bae' before initialization console.log(bae) let bae = \"bae\" // ReferenceError: Cannot access 'baw' before initialization console.log(baw) const baw = \"baw\"} 3. var 는 변수의 재선언을 허용하고 let,const는 허용하지 않는다.function foo() { var foo = \"foo\" var foo = \"foo2\" // var 는 변수의 재선언을 허용한다. console.log(foo) // let, const는 변수의 재선언을 허용하지 않는다. let bar = \"bar\" // SyntaxError: Identifier 'bar' has already been declared let bar = \"bar2\" console.log(bar)} 4. let으로 선언한 변수는 값을 재할당할 수 있지만 const는 불가능하다.function foo() { // let로 선언한 변수는 값의 재할당 가능하다. let bar = \"bar\" bar = \"bar2\" console.log(bar) // bar2 // const로 선언한 변수는 값의 재할당이 불가능하다. // 단, primitive형 일 경우만 (string, number, boolean...) const baz = \"baz\" // TypeError: Assignment to constant variable. baz = \"baz2\" console.log(baz) // 하지만 object 나 array의 경우 프로퍼티를 수정할 수 있다. const qwe = { x: 1, y: 2 } qwe.x = 3 console.log(qwe) // { x: 3, y: 2 } const awd = [1, 2, 3, 4] awd[2] = 99 console.log(awd) // [ 1, 2, 99, 4 ]} 하지만 const로 생성한 변수가 object의 경우, object의 프로퍼티는 수정가능하다. function foo() { // 새로운 object 를 할당하는 것은 불가능하지만, const object = { key: \"value\" } // TypeError: Assignment to constant variable. object = { otherKey: \"otherValue\" } // object의 property는 수정가능하다. object.key = \"newValue\" console.log(object) // newValue const array = [1, 2, 3, 4] // TypeError: Assignment to constant variable. array = [0, 0, 0, 0] array[4] = 5 array.push(6) console.log(array) // [ 1, 2, 3, 4, 5, 6 ]} 만약 object property의 값도 상수로 만들고 싶다면, Object.freeze() 를 이용해 object를 수정불가능하게 한다. object.key = \"newValue\"Object.freeze(object)object.key = \"NEWNEW\"console.log(object) // newValuefunction foo() { // let은 변수의 선언과 할당을 분리할 수 있다. let foo foo = 1 console.log(foo) // 1 // const는 변수의 선언과 동시에 할당을 해줘야한다. const bar bar = 2 // SyntaxError: Missing initializer in const declaration console.log(bar)} [참고]https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/consthttps://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let","link":"/2020/02/25/Programming/JavaScript/var-let-const/"},{"title":"VSCODE에서 ES2020 이용하기","text":"vscode에서 기존의 es6 문법만 사용하다가 ES2019 (ES10)에서 추가된 #으로 private field를 만들어주는 문법을 사용하려니 Invalid character 라는 에러가 발생했다. JavaScript and TypeScript Nightly 익스텐션을 vscode에 다운로드한다.https://marketplace.visualstudio.com/items?itemName=ms-vscode.vscode-typescript-next 이 익스텐션은 vscode 내장 typescript 버전을 typescript@next 로 대체한다. 아래의 과정을 통해 확인할 수 있다. vscode Code Command palette 를 열어서 TypeScript: Select TypeScript Version 을 검색한다. Use VS Code’s version 클릭한다. 기존에 오류가 나던 코드가 정상 작동하는 것을 확인할 수 있다. [참고] https://stackoverflow.com/questions/59640931/how-can-i-use-javascript-private-fields-in-vs-code","link":"/2020/01/16/Programming/JavaScript/vscode-es2020/"},{"title":"build.gradle (Project)와 build.gradle (Module)의 차이점","text":"1년만에 안드로이드 스튜디오를 켰더니만…모든 것이 새롭다.머릿속에 확실히 정리가 안 된 내용들은 글로 정리를 해두자. [참고] build.gradle이란?모듈의 빌드 방법이 정의된 빌드스크립트이다. 빌드에 사용할 SDK버전부터 애플리케이션 버전, 사용하는 라이브러리 등 다양한 항목을 설정할 수 있다. Build.gradle(Project : MyApplication)Top-level build file where you can add configuration options common to all sub-projects/modules.이 파일에 정의된 설정은 Project의 모든 모듈에 적용된다. 모듈은 프로젝트를 구성하는 하나의 구성품! 보통 대부분의 안드로이드 프로젝트에는 하나의 모듈인 app모듈만 있다. Build.gradle(Module:app)Build file of your specific module (where you add your dependencies, signing configs, build types, flavors, etc)이 빌드 설정은 앱모듈에만 적용된다.모든 모듈은 각자의 특정한 gradle파일을 가지고 있다. [참고] https://stackoverflow.com/questions/28295933/difference-between-build-gradleproject-and-build-gradlemodule","link":"/2018/07/15/Programming/Android/android-build-gradle/"},{"title":"android.view.InflateException 해결","text":"문제 상황Activity에 두 개의 fragment를 구성한 프로젝트를 build하려고 하자 아래와 같은 에러를 뿜으면서 앱이 build 실패했다. Caused by: android.view.InflateException: Binary XML file line #25: Binary XML file line #25: Error inflating class fragmentCaused by: android.view.InflateException: Binary XML file line #25: Error inflating class fragmentCaused by: java.lang.NullPointerException 검색을 통해 알아보니 android.view.InflateException 에러는 아래와 같은 경우 발생한다고 한다. xml에 값을 잘못 넣었을 경우 CustomView의 생성자 함수를 제대로 만들어주지 않았을 경우 [참고]CustomView 생성자의 매개변수에 context가 꼭 들어가야 한다고 함! public CustomView(Context context, AttributeSet attrs){ super(context, attrs);} 해결 방법내 경우에는 위의 2가지 사례에 해당하지 않았고, 좀 더 찾아보니 fragment에 class 속성을 명시하지 않아서 생기는 문제였다. &lt;fragmentandroid:id=\"@+id/mapFragment\"android:layout_width=\"match_parent\"android:layout_height=\"wrap_content\"app:layout_constraintLeft_toLeftOf=\"parent\"app:layout_constraintRight_toRightOf=\"parent\"app:layout_constraintTop_toBottomOf=\"@+id/guideline\"app:layout_constraintBottom_toBottomOf=\"parent\"class=\"com.example.minachoi.findjuyou.fragment.MapFragment\"/&gt; 이렇게 class값을 넣어주니 제대로 build되었다.","link":"/2018/08/01/Programming/Android/android-inflateException/"},{"title":"안드로이드 에러 - x86 emulation currently requires hardware acceleration","text":"문제 상황 emulator: ERROR: x86 emulation currently requires hardware acceleration! 위와 같은 에러가 나면서 에뮬레이터가 실행되지 않았다. 해결 방법 Tools - SDK manager - SDK tools에서 Intel x86 emulator accelerator (HAXM installer)가 설치되어 있는지 체크, 설치가 안되었다면 설치. 만약 설치해도 똑같은 에러가 발생한다면, emulator accelerator를 다운로드 완료했음에도 안드로이드 SDK Manager가 자동으로 emulator accelator를 설치하지 못한다는 의미다. 수동으로 설치해줘야한다. Hardware_Accelerated_Execution_Manager가 설치된 위치를 찾아가서 실행파일을 실행시키면 된다. 내경우에는 아래의 경로에 있었다. C:\\Users\\cmina\\AppData\\Local\\Android\\Sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manager 설치를 완료하고 나면 아래와 같은 화면이 뜬다. 위의 과정을 모두 마친 뒤, 다시 앱을 실행시켜보면 에뮬레이터에서 잘 동작하는 것을 확인할 수 있다.","link":"/2018/08/01/Programming/Android/android-hardware-acceleration/"},{"title":"Android Render Problem 해결","text":"문제 상황constraintlayout을 적용하던 중에 testview를 세팅했음에도 design 탭 화면에 나타나지 않는 문제를 발견했다.에러 메시지를 확인해보니 Render problem!!! 해결 방법app - build.gradle 에서 # 수정전compileSdkVersion28targetSdkVersion28dependencies{...implementation'com.android.support:appcompat-v7:28.0.0-alpha3'…}# 수정후compileSdkVersion27targetSdkVersion27dependencies{...Implementation 'com.android.support:appcompat-v7:27.0.2'…} Sdk버전을 낮춰주면 된다. 수정 후, File -&gt; Invalidate Caches/Restart -&gt; Invalidate and Restart 하면 정상적으로 동작하는 것을 확인할 수 있다. 아직 com.android.support:appcompat-v7:28.0.0-alpha3이 안정화가 안돼서 생기는 문제인 듯하다.","link":"/2018/07/31/Programming/Android/android-render-error/"},{"title":"자바에서 Incompatible types error","text":"ArrayList의 타입을 제네릭을 통해 명시하기문제 상황private ArrayList findUnAskedPermissions(ArrayList wanted) { ArrayList result = new ArrayList(); for (String perm : wanted) { if(!hasPermissions(perm)) { result.add(perm); } } return result;} for (String perm : wanted) 이 부분에서 Incompatible types required java.lang.string found java.lang.object 이러한 에러가 발생했다. 해결 방법findUnAskedPermissions 의 파라미터 타입을 ArrayList wanted 에서 ArrayList&lt;String&gt; wanted으로 변경하니 에러가 사라졌다.ArrayList를 사용할 때 제너릭으로 타입형을 명시해 주는 것을 잊지말자!","link":"/2018/08/12/Programming/Android/java-incompatible-type-error/"},{"title":"Angular에서 ObjectUnsubscribedError 해결방법","text":"ObjectUnsubscribedError 해결방법어떤 페이지에서 Event나 Observable을 subscribe하고 있다가 페이지를 벗어날 때는 unsubscribe를 해줘야 한다!!그렇지 않으면 메모리릭이 발생할 수 있다. 보통 ngOnInit()에서 subscribe하고 ngOnDestroy()에서 unsubscribe를 하는데다른 페이지에서 해당페이지로 돌아오기 위해 백버튼을 누르면 ObjectUnsubscribedError 에러 발생했다. 해결방법 eventEmitter를 바로 ngOnInit()에서 subscribe하는 게 아니라,eventEmitter를 subscribe한 subscriber를 해당 컴포넌트 변수에 담아서 사용하고, 그걸 unsubscribe해야한다. changedMyWalletList: EventEmitter&lt;any&gt; = new EventEmitter&lt;any&gt;(); changedMyWalletList을 구독한다고치면, 나는 그동안 ngOnInit() { this.changedMyWalletList.subscribe(()=&gt; { ~~~~ });}ngOnDestroy() { this.changedMyWalletList.unsubscribe();} 이런 식으로 작성했었는데, subscriberForMyWalletList: any;...ngOnInit() { this.subscriberForMyWalletList = this.changedMyWalletList.subscribe(()=&gt; { ~~~~ });}ngOnDestroy() { if(!this.subscriberForMyWalletList.closed) this.subscriberForMyWalletList.unsubscribe();} 이렇게 사용해야 한다. rxjs의 takeWhile을 사용import ‘rxjs/add/operator/takeWhile’ 를 하고this.isSubscribing이 true일 때만 구독을 하도록 하면 된다. isSubscribing: boolean = true;...ngOnInit() { this.moveToSendCard .takeWhile(()=&gt;this.isSubscribing) .subscribe(() =&gt; { ~~~~ });}ngOnDestroy() { this.isSubscribing = false;} 첫번째 방법은 구독해야할 것들마다 일일이 subscriber변수를 할당해줘야 해서 번거로우므로 takeWhile을 사용하는 게 더 간편하겠다!","link":"/2018/04/23/Programming/Angular/angular-ObjectUnsubscribedError/"},{"title":"앵귤러 아키텍쳐","text":"이번에 앵귤러 프로젝트를 리뉴얼하면서 구조를 어떻게 짜야 다른 개발자가 봐도 이해하기 쉬우면서도 협업하기 좋고, 확장성있게 구성할 수 있을까에 대한 고민을 했다. 여러 레퍼런스들을 검토하던 중 GFT팀에서 앵귤러 프로젝트의 구조를 어떤 식으로 짜는지에 대한 좋은 아티클이 있길래 번역을 하면서 내 식대로 정리를 해보았다. (번역 실력이 부족해 이해하기 힘들 수 있다…아래 첨부한 원본사이트를 참고하세요.) GFT팀의 아키텍쳐 규칙 Project structure - 프로젝트 파일들을 어떤 방식으로 체계화하고, 앵귤러모듈과 의존성 을 정의하고 활용할지 Data flow architecture - 애플리케이션 단에서 데이터가 흐르는 방식을 어떻게 할 것인지 State management - GUI의 상태를 어떻게 관리하고, 그것을 다른 앱에서도 활용할 수 있도록 할 것인지 What is a scalable architecture ?(여기서 GUI라고 표현한 것은 client application을 의미하는 듯? GUI는 일반적으로 그래픽 유저인터페이스의 줄임말이지만..)일단, GUI 애플리케이션이 확장성이 있다는 말은 어떤 의미일까?GUI는 항상 모든 사용자에 대해 하나의 별도의 응용 프로그램으로 실행되므로 백엔드 응용 프로그램의 일반적인 “높은 사용자 수”문제는 없습니다.대신 GUI는 아래와 같은 확장성 요소를 신경써야한다.앱에 로딩되는 데이터 사이즈가 커지고, 프로젝트의 복잡성과 사이즈가 커짐으로 인해 로딩시간이 길어진다는 것…. 외부에서는 잘 보이지 않지만, 프로그래머의 관점에서 앱을 어떻게 확장되는지에 대해서도 신경써야한다. 확장성이 없고 나쁜 아키텍쳐의 앱은 일정시간이 지나면 개발하기 힘들어진다. 복잡성의 증가, 기술적 debt부채, 지저분한 코드… 이런 것들은 프로젝트의 견적, 비용, 솔루션 전체의 질에 직접적으로 영향을 준다. 좋은 아키텍처가 위의 문제들이 발생하는 것을 다 막아주는 것은 아니지만 개발팀에게 그들이 직면할지도 모르는 이슈들을 줄이거나 심지어 제거하는 강력한 툴을 제공한다. 간단히 말해, 잘 디자인된 아키텍처는 크고 작은 프로젝트 어디에서든 잘 동작해야하고 좋은 유저인터페이스를 제공해야한다. 앱의 사이즈나 처리하는 데이터의 양에 상관없이.그리고, 프로젝트의 품질을 유지하기 위해 개발자들에게 명확하고 쉬운 규칙을 제공해야한다. 마지막으로 그 아키텍쳐는 기본적으로 널리 받아들여지는 디자인패턴을 따라야한다. 앱의 학습곡선을 가능한 작게하기 위해서. 자, 이제 잘 디자인된 앵귤러 애플리케이션의 규칙을 알아보자. Structure of the application보통 새로운 프로젝트를 세팅할 때 첫번째로 해야하는 것이 애플리케이션의 구조를 정하는 일이다. 많은 방법들이 있지만, 공식적으로 추천되는 방식이 있다. 바로 module-oriented 구조다. 이런 식으로 접근하면, 앱의 모듈들을 파일트리구조에서 분리된 디렉토리로 명확하게 보인다.각 모듈디렉토리에는 각 모듈과 연관된 모든 파일을 포함하고 있다.(code, styles, templates…etc). 이러한 방법에서 매우 중요한 요소는&quot;모듈의 독립성&quot;이다.각 모듈은 독립적이고, 다른 모듈에 있는 파일들을 참조하지 않는다. 그래서, 이론적으로 하나의 모듈을 지운다고 해도 앱이 아무런 문제없이 제대로 동작할 수 있다. 사실, 하지만 모듈의 독립성은 실제상황에서는 엄격히 지켜지지는 않는다. 적어도 몇개의 서비스나 컴포넌트는 앱전체에서 공통적으로 사용해야한다. 그러므로 앱기능의 일부분을 &quot;Core&quot;와 &quot;Shared&quot;모듈로 분리한다.앱의 구조는 아래와 같아진다. 위의 그림을 보면 3가지 메인 모듈이 있다. AppModule - 앱을 시작하고 다른 모듈을 합치는 부트스트랩 모듈 CoreModule - global Service 같은 앱전체에서 공통적으로 사용하는 코어 기능들. 앱의 다른 모듈에 import되지 않는다. SharedModule - 보통 다른 앱에서도 재활용할 수 있는고, 전역적으로 사용되지 않는 컴포넌트와 서비스의 세트로 구성된다. Featured Module기능모듈로 import된다. 나머지 모듈들은 (보통 기능모듈이라고 불림) 분리되어있고 독립적이다.이러한 구조는 관심사 분리해 줄 뿐만 아니라 확장성있는 앱 아키텍처에 중요한 부분인 lazy loading을 구현하기도 쉽다. Lazy Loading유저가 겪을 수 있는 가장 눈에 띄는 성능 문제는 바로 앱의 로딩시간이다! 코드량이 증가함에 따라 앱의 번들사이즈도 증가한다. 번들크기가 클수록 브라우저가 코드를 로딩하고 구문을 분석하는데 시간이 많이 걸린다. 다행스럽게도, 로딩시간 이슈를 해결하기 위한 패턴이 있다. 바로 Lazy Loading 이다.실제로 필요할 때까지 앱의 특정부분의 로딩을 늦출 수 있다. (보통 유저가 앱의 특정부분을 액세스하려고 할 때) 앵귤러는 Lazy Loading 기능이 내장되어있다. Route 정의할 때 올바르게 모듈을 정의하면 lazy loading되는 모듈파일을 가르킬 수 있다. 위에서 설명한 프로젝트 구조를 따랐다면, 앱이 초기화된 후 기능모듈들은 필요할 때 지연로드할 수 있다. 이것은 앱의 초기화시간을 크게 줄여 전반적인 UX를 개선한다. 게다가 앱이 확장될 수록 더 효과를 볼 수 있다. 앱이 커지더라도 지연로드 모듈만 추가되는 식으로 확장된다면 앱의 코어번들과 시작 시간은 계속 똑같을 거다. 만약 기본적으로 제공되는 lazy loading으로도 충분하지 않을 경우, 주어진 앱에서 모듈이 로딩되는 방식을 커스터마이징할 수 있는 Preloading 전략을 사용할 수도 있다. Data flow and state management아키텍처는 구조, 파일, 모듈에 대한 것만이 아니다. 복잡한 애플리케이션에서 직면하는 가장 큰 문제는 데이터와 상태정보의 흐름을 관리하는 것이다. 그것은 앱에서 매우 빠르게 복잡해지고 자주 수정되는 부분 중 하나다. 그러므로 잘 디자인된 데이터, 상태정보 관리체계를 갖는 것은 모든 아키텍트가 해야할 중요한 체크포인트다. Data flow앵귤러1과는 달리 앵귤러2부터는 단방향 데이터 flow를 선호한다. 이러한 접근은 양방향 데이터바인딩보다 유지보수하기가 수월하다. 단뱡향 데이터 바인딩이 해당 모듈에 있는 데이터소스가 어떤 것인지, 시스템을 통해 어떤 변화가 생겼는지 더 분명하게 알 수 있다.앵귤러에서는 데이터의 흐름이 위에서 아래로 전해진다. 부모컴포넌트에서 자식컴포넌트로 전달되고, 컴포넌트에서 템플릿으로 전달된다. 아직까지는 데이터흐름에 기본적인 규칙외에 추가적인 규칙을 설정하는 것이 좋다. smart, dummy컴포넌트 개념을 도입했다.스마트컴포넌트는 Container라고도 불린다. 이러한 구분은 로직을 포함하고 서비스와 소통하고 사이드이펙트를 발생시키는(서비스 실행, 상태변경 등등) 앱의 파트를 명확히 정의하기 위해서다. 모든 액션은 컨테이너에서만 일어난다. 반대로 stupid컴포넌트는 거의 또는 전혀 로직이 없다. 모든 데이터는 @input 파라미터를 통해 전달된다. 만약 이 컴포넌트가 다른 컴포넌트와 소통하려면 @output을 통해 이벤트를 발생시킨다. 이러한 아키텍처 접근방식은 컨테이너의 수를 가능한한 작게 유지하기 위함이다. 더 많은 컴포넌트가 dummy일 수록 데이터흐름이 간단해지고 작업이 쉬워진다. 어떤 컴포넌트가 컨테이너의 역할을 맡을 지 선택하는 것은 간단한 작업이 아니다. 특정 경우마다 해결해야한다. 그러나, 보통 첫번 째 단계는 주화면요소가 스마트컴포넌트이다.아래의 화면에서 파란색이 스마트컴포넌트이고, 회색이 더미컴포넌트다. 그 후에, 적은 수의 컨테이너와 단일책임원칙을 잘 유지하는 것이 중요하다. 대시보드 화면은 단일화면에 표시되는 여러스마트 컨테이너의 완벽한 예다.각 대시보드의 구성들은 스마트컴포넌트이고, 각자의 행동, 데이터, 로직을 담당한다. 아키텍쳐에 대한 이러한 접근은 코드의 가독성과 조직화된 데이터흐름을 위한 것만이 아니다. 더미컴포넌트는 테스트하기 쉽다. 그들의 상태는 전적으로 제공받는 입력에 의해 정해지고, 사이드이펙트가 없다. 적절한 이벤트가 발생되면 컴포넌트 동작결과가 보여진다. 게다가 이러한 행동은 앵귤러의 변경감지프로세스의 성능최적화와잘 일치한다. 더미컴포넌트의 변경감지전략은 “onPush”로 설정된다. onPush는 input 프로퍼티가 수정되었을 때만 컴포넌트의 변경감지 프로세스를 트리거한다. 앵귤러 애플리케이션의 최적화는 쉽고 효율적인 방법인다. State management애플리케이션에 흐르는 특수한 타입의 데이터가 있다. 바로 State상태다GUI는 모두 상태에 대한 것이다. 유저가 화면을 통해보는 모든 것은 앱의 상태를 반영한 것이다. 만약 유저가 어떤 동작을 한다면 어떤 데이터는 로딩되거나 다른 이벤트를 발생시키거나 한다. 앱의 로직은 실행된다. 그리고 GUI 상태는 변경된다. 이러한 수정은 보통 렌더링프로세스를 트리거하고 뷰는 업데이트된다. 그래서 유저는 수행된 작업의 결과물을 볼수 있게 된다. 이러한 싸이클이 앱의 실행중에 여러 번 발생한다. 기본적으로 GUI 애플리케이션의 모든 상호작용의 기본구조다. 프로세스 자체는 매우 간단하지만, 복잡한 애플리케이션에서는 상태관리에 관련된 많은 어려움을 겪는다. 일반적인 상호작용이 애플리케이션의 모든 레이어를 거쳐 진행되기 때문에 발생한다. 주어진 상태는 보통 공유된다 그리고 거기에 저장된 정보는 여러 컴포넌트와 심지어 화면에 영향을 미친다. 이미 언급했듯이 상태 관리는 보통 매우 복잡하고 자주 수정되는 것들이다. Single store to rule them all 이러한 이슈를 다루기 위한 방법중 하나는 애플리케이션 레벨에서 단방향데이터흐름을 활용하는 것이다.! 앵귤러커뮤니티는 Redux 아키텍쳐 패턴을 채택했다. Redux의 아이디어는 전체 애프리케이션의 상태가 앱의 현재 상태를 대표하는 객체인 단일 저장소에 저장된다는 것이다. Store는 변경할 수 없고 수정될 수 없다. 상태를 변경할 때마다 새로운 객체를 만들어야한다. 전체 앱의 상태에 대한 하나의 단일 참조지점은 앱의 다른 파트간의 동기화문제를 단순화한다.다른 모듈이나 컴포넌트에서 주어진 정보를 찾을 필요가 없다. 모든 것은 store에서 사용할 수 있다. Actions and ReducersStore는 직접 액세스하고 수정할 수 없다. Reducers가 수정된 데이터를 가지고 새로운 상태를 만드는 역할을 한다. Reduces는 대개 액션을 인수로 받고 제공된 데이터를 기반으로 새로운 상태를 리턴하는 간단한 function이다. State propagation (상태전이)앵귤러에서 Redux패턴을 구현하는 방법에는 여러가지가 있다.가장 유명한 것은 바로 ngrx/store다. 여기서는 ngrx/state의 구현에 대해서는 자세하게 다루지 않고 앱을 통해 state가 어떻게 수정되고 전파되는지 보겠다. 일단 Store에 수정이 적용되면 모든 subscriber에게 변경사항이 전달된다. State가 변경되지 않는 다는 사실 덕분에 세부검사를 진행할 필요가 없다. 만약 상태가 수정되면, subscriber는 새로운 객체를 전달받는다. 이 중앙집중화된 패턴덕분에 모든 상태변화들은 앱의 각 파트에 적절히 전파된다. 반드시 따라야하는 규칙은 Store에 모든 state변경을 변영하는 것이다. 분리된 컴포넌트에 보관되지 않도록. State Service뷰 레이어와 직접적으로 관련이 없는 다른 로직들과 마찬가지로 전용 service에 Store 작업을 캡슐화하는 것이 좋다. 이러한 서비스는 모듈이나 앱에서 재사용할 수 있다. 컴포넌트는 state의 세부작업에 대해 인식하지 않아도 된다. Combining state management and data flow설명된 패턴은 서로 결합될 때 정말 강력하다. Redux기반의 state 관리는 앱의 다양한 파트와 불변의 state 사이에 중요한, 믿을만한 동기화를 제공한다. 단방향 데이터 흐름과 스마트컨테이너는 애플리케이션에서 잘 정의된 책임(중요 로직)과 하위에 있는 더미컴포넌트에 전달되는 state 변경을 어떤 전파방버을 제공한다. 공유데이터의 불변성은 앵귤러 변경감지 알고리즘의 최적화 패턴에 적합하다. 이 방식으로 설계된 애플리케이션은 중앙 상태관리 시스템을 통해 상태와 데이터를 동기화하는 캡슐화된 자율 컴포넌트로 구성된다. [참고] https://bulldogjob.pl/articles/539-scalable-angular-application-architecture","link":"/2018/08/09/Programming/Angular/angular-architecture/"},{"title":"Angular의 Content Projection","text":"Angular5 / Components / Content Projectionhttps://codecraft.tv/courses/angular/components/content-projection/ 의 글을 번역했다. JokeComponent를 재사용하려는 개발자는 어떻게 Joke를 렌더링할 지 구성할 수 있다. Content Projection이 무엇인지, 그리고 우리가 그걸 왜 사용하는지 알아보자 ng-content 태그를 사용해서 컨텐트를 적용시키는 방법을 알아보자 css selector를 사용해서 여러 컨텐트를 적용시키는 방법을 알아보자 이런 상황을 가정해보자JokeComponent를 재활용하길 원하는데, p태그 대신 h1태그를 사용하고 싶다면 어떻게 해야할까? 지금 현재의 Component로는 그대로 재사용할 수가 없다. 그러나!! content projection이라고 불리는 걸 이용해서 컴포넌트를 커스텀가능하도록 설계할 수 있다. Content Projection&lt;ng-content&gt; &lt;/ng-content&gt; 태그를 템플릿의 HTML 어디에나 추가하면 된다.ng-content 태그내부에 우리가 정의한 컴포넌트가 적용된다. JokeComponent를 수정해보면 &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt;{{ data.setup }}&lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; //이 부분 원래는 {{data.punchline}} 이었던 것을 ng-content로 변경 &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; JokeComponent를 위와 같이 변경한 후,JokeListComponent 를 &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt;&lt;/joke&gt; 에서 &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt; &lt;h1&gt;{{ j.punchline }}&lt;/h1&gt; // j.punchline 을 h1태그로 감싸줬다.&lt;/joke&gt; 으로 변경한다. &lt;h1&gt;&lt;/h1&gt; 는 상위컴포넌트인 JokeListComponent에서 정의되었고, JokeComponent에서 &lt;ng-content&gt;&lt;/ng-content&gt; 태그로 변환된다. 이것을 Content Projection이라고 부른다. 상위컴포넌트에서 현재의 컴포넌트로 컨텐트를 투영하는 것을 의미한다. Content Projection을 사용하면, 컴포넌트를 우리가 바라는대로 정확히 렌더링될 수 있게 할 수 있다. 그러나, Content Projection의 단점은 JokeListComponent가 JokeComponent의 프로퍼티나 메소드를 액세스할 수 없다는 것…그래서 우리가 투영하는 컨텐트는 JokeComponent의 프로퍼티, 메소드에 바인딩할 수 없고, JokeListComponent에서만 가능하다.(위의 예에서 보면, JokeListComponent에서 j.punchline를 h1 태그로 감싼 것을 볼 수 있다. JokeComponent에서 이렇게 표현했던 것을) Multi-content Projection만약 여러 컨텐트 영역을 정의하고 싶다면?JokeComponent에서 와 에 둘다 Content Projection을 적용시키고 싶다면?? 이 방법은 단지 Multi-content Projection을 설명하기 위한 용도라고 생각하자. 이 방법보다 더 쉽게 해결할 수 있는 다른 방법들이 있다. JokeListComponent을 아래와 같이 바꾸고 싶다. &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt; &lt;span&gt;{{ j.setup }} ?&lt;/span&gt; &lt;h1&gt;{{ j.punchline }}&lt;/h1&gt;&lt;/joke&gt; 하지만 JokeComponent를 둘 다 &lt;ng-content&gt;&lt;/ng-content&gt; 로 변환하는 식으로 바꿀 수는 없다. &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; JokeListComponent의 어떤 컨텐트(j.setup인지, j.punchline인지)가 JokeComponent의 &lt;ng-content&gt;&lt;/ng-content&gt;에 투영되어야 하는지 앵귤러는 알지 못한다. 이를 위해서 select라는 속성을 이용한다.select에 전달된 태그와 일치하는 부분에 매칭된다. &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt; &lt;ng-content select=\"span\"&gt;&lt;/ng-content&gt; // &lt;span&gt;{{ j.setup }} ?&lt;/span&gt;와 매칭된다. &lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content select=\"h1\"&gt;&lt;/ng-content&gt; // &lt;h1&gt;{{ j.punchline }}&lt;/h1&gt; 와 매칭 &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; 약간의 트릭을 써서 클래스 이름과 같은 의미있는 규칙을 정할 수도 있다. &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt; &lt;ng-content select=\".setup\"&gt;&lt;/ng-content&gt; &lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content select=\".punchline\"&gt;&lt;/ng-content&gt; &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; 위를 적용시키기 위해서 상위 컴포넌트인 JokeListComponent는 아래와 같이 변경하면 된다. &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt; &lt;span class=\"setup\"&gt;{{ j.setup }} ?&lt;/span&gt; &lt;h1 class=\"punchline\"&gt;{{ j.punchline }}&lt;/h1&gt;&lt;/joke&gt; 정리어떤 경우에는 컴포넌트의 특성에 따라, 사용자는 뷰, 데이터를 보여주는 방식을 각 케이스별로 커스텀하고 싶어할 수 있다. 모든 케이스를 커버하기 위해서 모든 구성 프로퍼티를 셋팅하는 대신 Content Projection을 사용할 수 있다.사용자에게 그들이 원하는 대로 컴포넌트의 프레젠테이션을 구성할 수 있도록 권한을 준다.","link":"/2018/05/01/Programming/Angular/angular-component-overview2/"},{"title":"Angular에서 특정 div 이외의 영역 클릭이벤트 탐지","text":"Angular에서 특정 div 이외의 영역 클릭이벤트 탐지하는 방법회사 프로젝트 진행하던 중, 드롭박스 이외의 영역을 클릭했을 때 드롭박스를 닫히도록 하는 기능이 필요했다. select태그를 사용했더라면 신경 쓸 필요가 없는 일이었지만 원활한 스타일적용을 위해 select태그가 아니라 button, li 태그로 드롭박스를 구현한 상태였다. 해당 기능을 제공하는 ng4-click-outside, ng-click-outside 모듈이 앵귤러 5 프로젝트 내에서는 제대로 동작을 하지않아 직접 구현하는 수 밖에 없었다. swap.component.html&lt;div class=\"swap-coin-inp-wrap\" #fromDiv&gt; ... &lt;/div&gt; swap.component.tsconstructor( ) { document.addEventListener('click', this.offClickHandler.bind(this)); // bind on doc}offClickHandler(event: any) { if (!this.fromDiv.nativeElement.contains(event.target)) { // check click origin this.fromListShow = false } if (!this.toDiv.nativeElement.contains(event.target)) this.toListShow = false} 이렇게 구현했더니, fromDiv, toDiv 이외의 영역을 클릭했을 때 드롭박스가 제대로 닫히는 것을 확인할 수 있었다.","link":"/2018/06/19/Programming/Angular/angular-detect-click-outside/"},{"title":"formGroup 하위에 [(ngModel)] 사용시 발생하는 error","text":"Angular에서 formGroup 하위에 [(ngModel)] 사용문제 상황Form태그 안에 있는 select에 [(ngModel)]을 넣으니까 아래와 같은 에러 발생했다. 해결 방법 formGroup 안에서는 ngModel 쓰지말고 formControlName 디렉티브를 사용한다. (ts파일에서 FormBuilder를 통해 group 생성시 formControlName에 있는 값들도 전부 넣어줘야 함.) 굳이 ngModel을 사용하고 싶다면, [ngModelOptions]=&quot;{standalone: true}&quot; 와 함께 사용해야한다. # 1번 방법&lt;select class=\"form-control\" formControlName=\"selectedToken\"(change)=\"selectSendToken()\" [(ngModel)]=\"global.sendInfo.token\"&gt; &lt;option *ngFor=\"let token of global.sendTokenOptions\" [ngValue]=\"token\"&gt; {{token.symbol}}({{token.name}}) &lt;/option&gt;&lt;/select&gt;# 2번 방법&lt;select class=\"form-control\" (change)=\"selectSendToken()\"[(ngModel)]=\"global.sendInfo.token\" [ngModelOptions]=\"{standalone: true}\"&gt;....&lt;/select&gt;","link":"/2018/08/06/Programming/Angular/angular-formgroup-error/"},{"title":"앵귤러에서 커스텀 디렉티브 만들기","text":"Angular5 / Custom Directive빌트인 디렉티브처럼 사용할 수 있는 커스텀 디렉티브를 만들어보자. https://codecraft.tv/courses/angular/custom-directives/overview/ 참고. 우리는 이미 커스텀 디렉티브를 이미 생성해봤을거다. 왜냐면 컴포넌트도 디렉티브이기 때문!컴포넌트는 디렉티브의 모든 특징을 가지고 있다. 거기에 view를 가지고 있는 것이 컴포넌트다.that is to say they have a template and some HTML that is injected into the DOM when we use it. 또다른 차이점은 하나의 html 엘리먼트에 하나의 컴포넌트만 가질 수 있는데, 디렉티브의 경우 하나의 엘리먼트에 여러 디렉티브를 연결할 수 있다. 이번 글에서 아래와 같은 것을 알아보자. 1. @Directive 데코레이터를 사용해서 커스텀 디렉티브를 만드는 법 2. 디렉티브가 이벤트를 인지하고 연관된 host element의 프로퍼티변경을 인지하는 법 3. 엘리먼트에 정의된 input을 가져올 수 있도록 디렉티브를 구성하는 방법 [aDirective]={config: &apos;value&apos;} 와 같이.Creating a custom directive1. @Directive 데코레이터를 사용해서 기본 디렉티브를 만드는 방법 2. 셀렉터를 사용해서, 어트리뷰트를 기반으로 하는 디렉티브와 엘리먼트를 연결하는 법 3. 디렉티브와 연결된 엘리먼트의 raw DOM 엘리먼트와 상호작용하는 방법Directive decorator&lt;div class=\"card card-block\" ccCardHover&gt;...&lt;/div&gt; 위와 같이 ccCardHover라는 디렉티브를 card 블록에 붙일 수 있다. [참고]앵귤러팀은 디렉티브를 어트리뷰트로 사용할 때, 디렉티브의 이름에 접두어를 붙이는 것을 추천했다. 여기서는 ‘cc’를 접두어로 사용했다. Class에 @Directive라는 데코레이터를 붙이면 디렉티브를 만들 수 있다. import { Directive } from '@angular/core';...@Directive({ selector:\"[ccCardHover]\"})class CardHoverDirective { } Attribute selector컴포넌트를 만드는 것과 비슷한 데, selector를 []으로 감싼 것이 다르다.이것을 이해하기 위해서 우리는 selector attribute는 CSS 매칭 규칙을 사용해서 컴포넌트/디렉티브를 HTML 요소와 매치한다는 것을 먼저 이해할 필요가 있다. 특정 element를 매치하려면 CSS에서는 아래와 같이 element의 이름으로 스타일 매칭한다. input { 스타일 설정 }p {…​}….// selector:\".ccCardHover\"// 위와 같은 경우 class로 쓰임&lt;div class=\"card card-block ccCardHover\"&gt;...&lt;/div&gt; 디렉티브를 특정 속성을 가진 엘리먼트에 연관시키고자 한다.CSS에서 이를 수행하려면 속성이름을 []으로 감싸야한다. 그래서 selector는 [ccCardHover]이다. Directive constructor디렉티브가 생성될 때, 앵귤러는 ElementRef를 주입할 수 있다.ElementRef는 디렉티브가 연결된 DOM 요소에 직접 액세스를 할 수 있게 한다. el.nativeElement.style.backgroundColor = &quot;gray&quot;; 위는 card의 배경색을 회색으로 변경한다. ElementRef는 nativeElement 프로퍼티를 통해 액세스할 수 있는 실제 DOM 엘리먼트의 래퍼다. ElementRef는 지시어가 첨부 된 DOM 요소에 직접 액세스 할 수있게합니다. 카드의 배경색을 회색으로 변경하는 데 사용합시다. ElementRef 자체는 다음과 같이 nativeElement 속성을 통해 액세스 할 수있는 실제 DOM 요소의 래퍼입니다. 그러나 이것은 앱이 항상 브라우저환경에서 동작하는 것을 가정한다.앵귤러는 노드를 통한 서버사이드, 모바일디바이스 등등 다양한 환경에서 동작하도록 설계되었다. 그래서 앵귤러는 Renderer를 통해 엘리먼트에 어트리뷰트를 세팅함으로써 플랫폼에 독립적인 방법을 제공한다. import { Renderer } from '@angular/core';...class CardHoverDirective { constructor(private el: ElementRef, private renderer: Renderer) { renderer.setElementStyle(el.nativeElement, 'backgroundColor', 'gray'); }} HostListener &amp; HostBinding1. 디렉티브를 붙인 host element에서 발생된 이벤트에 반응하는 방법 2. 인풋 프로퍼티에 바인딩하여 host element를 조작하는 방법HostListener위에서 우리는 ccCardHover라는 디렉티브를 만들었는데, ccCardHover가 있는 엘리먼트의 배경색을 단순히 회색으로 바꾸었다.하지만 디렉티브의 네이밍처럼 hover가 되었을 때만 배경색을 바꾸기 위해서는 유저가 host element를 hover하는지를 감지해야한다. 앵귤러에서는 @HostListener 데코레이터를 통해 이를 쉽게 할 수 있다. 이것은 인자로 넘긴 이벤트를 받아들이는 function 데코레이터다. Host element에서 해당 이벤트가 발생하면 연결된 functions을 실행한다. @HostListener('mouseover') onHover() { window.alert(\"hover\");} HostBindingHost element에서의 이벤트발생을 캐치할 수 있는 거처럼 host element에 있는 input 프로퍼티에도 @HostBinding을 통해 바인드할 수 있다. 이 디렉티브는 host element의 프로퍼티를 바꿀 수 있다. host element에 적용된 클래스 리스트와 같은… @HostBinding 데코레이터를 사용해 디렉티브는 내부 프로퍼티를 host element 에 있는 input 프로퍼티에 연결할 수 있다. 그래서 내부 프로퍼티가 변경되면 host element에 있는 input 프로퍼티도 변경될 거다. 그러기 위해서는 바인드의 재료로 사용할 수 있는 디렉티브의 프로퍼티가 필요하다. Boolean형의 ishovering이라는 프로퍼티를 선언해서,onmouseover(), onmouseout()에 따라 true, false값을 세팅하자. 이제 host element의 input프로퍼티에 소스프로퍼티를 연결해야하는데,Ishovering에 @HostBinding데코레이터를 붙인다.@HostBinding은 하나의 파라미터를 가지는데, host element에 바인드할 프로퍼티의 이름이다. [class.&lt;class-name&gt;] 프로퍼티를 사용해 ngClass 문법을 이용할 수도 있다. @HostListener와 @HostBinding 데코레이터를 사용하면 호스트 요소의 출력 이벤트를 수신 할 수 있으며 호스트 요소의 입력 속성에도 바인딩 할 수 있습니다. Inputs &amp; Configuration1. 디렉티브를 구성가능하게 만드는 방법을 알아보자Configuration 위에서 ccCardHover 디렉티브를 완성했는데 이는 재사용하기 불편하다.이번에는 ccCardHover를 구성가능하도록 바꿔서 다른 상황에서도 사용할 수 있게끔 해보자. 구성 파라미터 중 하나는 숨기거나 보이길 원하는 element를 선택할 수 있는 query selector다.let part = this.el.nativeElement.querySelector('.card-text'); 첫번째로 해야할 것은 query selector를 디렉티브의 속성으로 이동하는거다. 객체의 속성으로 세팅하면 되겠다. config: any = { querySelector: '.card-text'} 이런 식으로 config에 매개변수를 추가하고 싶다면 config 객체에 프로퍼티를 추가하면 된다. 하드코딩된 selector대신 config객체를 이용해 select할 수 있다.let part = this.el.nativeElement.querySelector(this.config.querySelector); 마지막으로 config 프로퍼티를 디렉티브의 input binding으로 만든다. @Input() config: Object = { querySelector: '.card-text'} 위와 같이 표준 Input 프로퍼티 바인딩을 사용해서 디렉티브를 구성할 수 있다.","link":"/2018/07/23/Programming/Angular/angular-custom-directive/"},{"title":"Angular의 Component에 대한 정리","text":"Angular5 / Componentshttps://codecraft.tv/courses/angular/components/overview/ 의 글을 번역했다. 컴포넌트는 앵귤러 앱의 기본적인 빌딩블록이다.우리는 작은 컴포넌트를 사용해 큰 컴포넌트를 만들 수 있다. 앵귤러는 이러한 컴포넌트의 트리라고 할 수 있다.각 컴포넌트가 렌더링될 때, 해당 컴포넌트의 하위 컴포넌트까지 렌더링한다. 루트 컴포넌트는 이 컴포넌트 트리의 최상단에 있는 컴포넌트다. 우리가 앵귤러 앱을 실행할 때, 우리는 브라우저에게 루트 컴포넌트를 렌더링하라고 알려준다. 그리고 루트 컴포넌트는 그 안에 포함된 하위 컴포넌트를 렌더링한다. 이 포스트를 통해 아래의 사항들을 정리해보자! 컴포넌트를 사용해 앱을 설계하는 방법 @Component에 대해 깊게 알아보기 Content Projection 컴포넌트 lifecycle hooks View Childres vs Content Children Component 설계앵귤러 앱을 설계하는 법을 알아보자. 앵귤러 앱을 만들 때, 우리는 다음과 같은 과정을 거친다. 몇 개의 컴포넌트로 앱을 나눈다. 각 컴포넌트의 역할(기능)을 정리한다. 그 다음, 각 컴포넌트의 input, output을 정리한다. 아래의 예시를 보면 Header, Sidebar, Content구역을 가진 기본적인 앱이다. 각 컴포넌트는 자체 구성 요소로 구현한다. 그리고나서 각 컴포넌트의 responsibilities, inputs, outputs 등등을 리스트업한다. HeaderComponentResponsibilities유저 로그인, 회원가입, 로그아웃과 관련된 모든 인증 기능들 Inputs입력받는 것은 없음. Outputs-LoginChanged : 유저 로그인 상태가 변경되었을 때 발생되는 이벤트 SidebarComponentResponsibilities검색관련 기능 Inputs입력받는 것은 없음. Outputs-SearchTermChanged : 유저가 검색을 할 때 발생되는 이벤트, $event는 검색어를 담고있다. ContentComponentResponsibilities검색 결과를 보여주는 역할 Inputs-SearchTerm : 필터링할 검색어를 입력받음. Outputs아웃풋 없음 이렇게 inputs, outputs, 각 컴포넌트가 담당하는 기능들을 리스트업하는 것은 컴포넌트의 정확한 설계를 도와준다.이렇게 하는 목적은 각각의 컴포넌트가 잘 정의된 기준을 가지도록 하는 것!!! 데이터 흐름위의 컴포넌트를 루트컴포넌트와 연결하고 나면 데이터의 흐름이 아래 그림과 같을거다. inputs, outputs의 바인딩은 실제적으로 HTML(컴포넌트의 템플릿)에서 일어난다. 루트 컴포넌트의 템플릿은 아래와 같을거다. &lt;header (loginChanged)=\"loggedIn = $event\"&gt;&lt;/header&gt;&lt;sidebar (searchTermChanged)=\"searchTerm = $event\"&gt;&lt;/sidebar&gt;&lt;content [searchTerm]=\"searchTerm\"&gt;&lt;/content&gt; 데이터 흐름은 inputs, outputs를 통해 컴포넌트를 어떻게 연결하는지 보여준다. 위의 데이터흐름 다이어그램을 들여다보면 단방향 데이터 바인딩에 대해 흥미로운 점을 발견할 수 있다.inputs는 아래방향으로 전달되고, outputs은 위방향으로 전달된다. 단방향 데이터 바인딩을 통해 앱이 훨씬 심플해지고, 앱의 이벤트 흐름을 쉽게 추적할 수 있다. 정리해보면,앵귤러 앱을 설계한다는 것은 컴포넌트 트리라는 것을 이해한다는 거다. 각각의 컴포넌트는 몇 개의 inputs, outputs를 가지고 있다. 분명한 기능도 가지고 있다. 컴포넌트는 구성될 수 있다. HeaderComponent에 LoginButtonComponent를 추가할 수 있다. LoginButtonComponent를 재사용하고 싶을 경우에만 이렇게 구성한다. 이번에는 @Component 데코레이터에 대해 알아보자 templateURL앵귤러에서는 HTML코드를 ts파일 안에 inline으로 작성할 필요가 없다. 대신에 HTML파일을 따로 저장하고 templateURL 프로퍼티를 사용해서 컴포넌트에서 그 HTML을 읽어들일 수 있다. @Component({ selector: 'joke-form', templateUrl: 'joke-form-component.html'})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} 이런 식으로, templateUrl 프로퍼티를 사용해서 외부의 템플릿 파일을 해당 컴포넌트에 지정한다. styles커스텀 css파일도 styles 프로퍼티를 통해 지정할 수 있다.styles는 스트링 배열을 가질 수 있는데, 백틱을 사용해서 여러줄로도 표현가능하다. @Component({ selector: 'joke-form', template: 'joke-form-component.html', styles: [ ` .card { background-color: gray; } ` ],})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} 뷰 캡슐화(View Encapsulation) 위의 예에서 보면 .card를 통해 배경색을 회색으로 바꿨다. 하지만 첫 번째 컴포넌트에만 적용된 것을 볼 수 있는데,보통의 경우 css class의 적용범위는 앱 전체이지만, 이 경우 해당 컴포넌트에서만 적용된다.이를 View Encapsulation 이라고 한다. 앵귤러는 쉐도우 돔이 주 기능인 웹 컴포넌트에서 영감을 얻었는데, 쉐도우 돔을 사용하면 컴포넌트 외부에는 스타일이 적용되지 않고 해당 웹 컴포넌트에서만 스타일이 적용되도록 할 수 있다. 앵귤러는 이러한 기능들을 encapsulation의 프로퍼티로 제공한다. ViewEncapsulation.Native ViewEncapsulation.Emulated ViewEncapsulation.None 기본 값은 ViewEncapsulation.Emulated 이고, 위와 같이 동작한다. ViewEncapsulation.Emulated브라우저 개발자도구를 사용해서 폼 엘리먼트에 어떤 변화가 있는지 살펴보면,JokeFormComponent에 자동적으로 어트리뷰트가 생성된 것을 볼 수 있다. “_ngcontent-qwe-3” 이라는 어트리뷰트를 추가했다. 다른 컴포넌트에는 해당 어트리뷰트가 추가되지 않았고, JokeFormComponent에만 추가된 것을 알 수 있다.style 탭을 보면, “_ngcontent-qwe-3” 에 스타일이 입혀진 것을 볼 수 있다. css 셀렉터 .card[_ngcontent-qwe-3]는 JokeFormComponent만 타켓팅했다. 왜냐면 _ngcontent-qwe-3 어트리뷰트는 JokeFormComponent에만 있다. ViewEncapsulation.Emulated 모드에서 앵귤러는자동으로 생성되는 어트리뷰트를 이용함으로써 일반적인 (전역) css 클래스 셀렉터가 특정 컴포넌트에만 적용되도록 변경한다. 이 때문에, 다른 모든 JockComponent가 같은 card 클래스를 사용했음에도 불구하고 JokeFormComponent의 배경색만 회색으로 바뀐다. 컴포넌트에 정의한 모든 스타일은 나머지 앱 부분에 적용되지 않지만 컴포넌트는 여전히 트위터 부트스트랩의 전역스타일을 상속한다.JokeFormComponent는 트위터 부트스트랩의 전역 스타일을 적용시키면서, 컴포넌트 자체의 캡슐화된 스타일도 적용시킨다. ViewEncapsulation.Native앵귤러에서 쉐도우 돔을 사용하기를 원한다면 ViewEncapsulation.Native을 사용하도록 캡슐화 매개변수를 설정할 수 있다. @Component({ selector: 'joke-form', templateUrl: 'joke-form-component.html', styles: [ ` .card { background-color: gray; } ` ], encapsulation: ViewEncapsulation.Native # &lt;!&gt;})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} 하지만!! 여전히 배경색은 회색이지만, 전역적인 트위터 부트스트랩 스타일이 적용 안된 것을 볼 수 있다!! ViewEncapsulation.Native을 사용하면 우리가 컴포넌트에 설정한 스타일이 다른 부분에 적용되지 않도록 할 수 있다.독립적인 제 3의 스타일을 정의할 때 사용하는 것이 좋다. 우리가 설정한 스타일이 누출되어 앱의 나머지에 영향을 끼칠 수 있다는 걱정을 안해도 된다. 그러나, ViewEncapsulation.Native을 사용하면 우리가 앱에 설정한 전역 스타일과 분리되기 때문에, 트위터 부트스트랩 스타일을 상속받지 않는다. 그래서 컴포넌트 데코레이터에 필요한 스타일을 전부다 정의해줘야한다. ViewEncapsulation.Native 은 모든 브라우저에서 지원하지 않는, 쉐도우 돔이라고 불리는 기능이 필요하다. ViewEncapsulation.None만약 스타일을 캡슐화하고 싶지 않다면 ViewEncapsulation.None을 사용하면 된다.card클래스를 사용하는 모든 컴포넌트에 배경색이 회색으로 변경될 거다. 브라우저 개발자도구로 살펴보면, 앵귤러가 HTML의 head 영역에 .card 클래스를 전역스타일로 추가한 것을 볼 수 있다. 아무것도 캡슐화하지 않고, 우리가 컴포넌트에서 정의한 스타일이 흘러나와 앱 전체에 적용될 거다. styleURLs@Component({ selector: 'joke-form', templateUrl: 'joke-form-component.html', styleUrls: [ 'joke-form-component.css' ]})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} templateUrl프로퍼티처럼 외부 스타일파일을 사용하고 싶다면 styleUrls 프로퍼티를 사용하면 된다. 배열을 값으로 받는다. Depreciated Properties@Component의 프로퍼티로 directives, pipes, inputs, outputs를 포함하는 글도 볼 수 있는데 이는 베타버전에 앵귤러에 추가됐다가 2.0 최종 릴리즈 버전에서는 빠진 기능이다. shadow DOM 이란?http://d2.naver.com/helloworld/188655","link":"/2018/04/27/Programming/Angular/angular-component-overview/"},{"title":"Angular의 Forms 제대로 사용하기","text":"Angular5 / Forms그동안 서버 통신할 때 content-type을 json형태로 주로 통신하다보니 앵귤러 forms을 제대로 사용하지 않고 [(ngModel)] 양방향 데이터바인딩을 통해 값을 취득하는 방식을 취했다. 그래서 값의 validation도 직접 구현했는데, Forms을 사용하면 Forms가 제공하는 validation을 이용함으로써 편리하겠다싶어 Forms을 검토해봤다. 앵귤러 마스터북의 Forms예제와 https://codecraft.tv/courses/angular/forms/overview/ 을 참고했다. 성, 이름, 이메일, 비밀번호, 언어선택 박스가 있는 회원가입 폼을 만들어보자.유저가 필드별 입력값을 제대로 입력했는지 알려주기 위한 visual feedback도 추가할거다. 템플릿 기반 폼이 더 단순하지만, 실제적으로 자동으로 생성된 모델 기반 폼으로 동작한다.그래서 먼저 모델 기반 폼을 먼저 설명하고 템플릿 기반 폼을 설명하겠다.마지막으로 RxJS를 이용해reactive model 기반 폼을 구현하는 메소드를 보여주겠다. Model Driven Forms모델기반으로 폼을 구현하는 것은 컴포넌트 파일에 FormGroup, FormControl의 인스턴스 객체를 변수로 선언해 html에서 해당 변수를 참조함으로써 form을 구현하는 방식을 의미한다. &lt;!-- signup.component.ts --&gt; myForm: FormGroup; firstName: FormControl; lastName: FormControl; email: FormControl; password: FormControl; language: FormControl; ngOnInit() { this.myform = new FormGroup({ name: new FormGroup({ firstName: new FormControl('', Validators.required), lastName: new FormControl('', Validators.required), }), email: new FormControl('', [ Validators.required, Validators.pattern(\"[^ @]*@[^ @]*\") ]), password: new FormControl('', [ Validators.required, Validators.minLength(8) ]), language: new FormControl() }); }&lt;!-- signup.component.html --&gt; &lt;form [formGroup]=\"myForm\" class=\"ui form error\" (ngSubmit)=\"onSubmit(myForm.value)\"&gt; ... &lt;input type=\"password\" id=\"password\" [formControl]=\"myForm.controls.password\"&gt; ... &lt;/form&gt; Model Driven Form Validation1. Form model을 통해 유효성 체크를 어떻게 추가할까 2. 유효성체크 결과를 유저에게 visual feedback을 어떻게줄까 3. 유효성 에러메시지 어떻게 추가할까validators 를 적용하려면 템플릿에 어트리뷰트를 추가하거나 모델에 FormControl를 정의하면 된다. 우리는 여기서 2번째 방법으로 적용시켜보겠다. 앵귤러는 이미 built-in된 validators가 있다( 예를 들면 required, minLength, maxlength, pattern) FormControl 생성자의 첫번째 파라미터는 컨트롤의 초기값이고 그 값은 빈 값으로 둘 수 있다.두번째 파라미터는 single validator이거나 multi validators를 적용시키고 싶으면 validators의 리스트일 수도 있다. ngOnInit() { this.myform = new FormGroup({ name: new FormGroup({ firstName: new FormControl('', Validators.required), //싱글 validators lastName: new FormControl('', Validators.required), }), email: new FormControl('', [ // validators 여러개 Validators.required, Validators.pattern(\"[^ @]*@[^ @]*\") ]), password: new FormControl('', [ Validators.required, Validators.minLength(8) ]), language: new FormControl() });} 1.Form control state폼 컨트롤 객체는 컨트롤자체의 상태를 캡슐화했다. (현재 유효한지, 터치된 적이 있는지에 대한) &lt;pre&gt;Dirty? {{ myform.controls.email.dirty }}&lt;/pre&gt;&lt;pre&gt;Pristine? {{ myform.controls.email.pristine }}&lt;/pre&gt; Dirty가 true이면 유저가 컨트롤의 값을 변경한 적이 있다는 의미.Pristine이 true이면 유저가 값을 변경한 적이 없다는 의미. &lt;pre&gt;Touched? {{ myform.controls.email.touched }}&lt;/pre&gt; Touched는 유저가 폼을 터치한 적이 있을 때…Touched, dirty의 차이점은 touched는 실제로 값을 변경안해도 touched가 true &lt;pre&gt;Valid? {{ myform.controls.email.valid }}&lt;/pre&gt; 모든 validator를 통과하면 valid는 true 2.Validation Styling[ngClass]=\"{'error' : myForm.controls.email.invalid &amp;&amp; myForm.controls.email.dirty,'success' : myForm.controls.email.valid &amp;&amp; myForm.controls.email.dirty}\" Dirty가 true인지 체크하는 이유는아무런 입력을 받지 않았을 때, 최초로딩에서 validation style이 적용되는 것을 막기 위해. 3.Writing shorter validation expressions위의 방법은 FormGroup이 중첩되었을 경우, 사용하기 복잡할 수 도 있다. &lt;div class=\"form-group\"[ngClass]=\"{'has-danger': myform.controls.name.controls.firstName.invalid &amp;&amp; myform.controls.name.controls.firstName.dirty,'has-success': myform.controls.name.controls.firstName.valid &amp;&amp; myform.controls.name.controls.firstName.dirty}\"&gt; 아래와 같이 표현을 짧게 하기 위해서 Ts파일에 로컬프로퍼티를 생성해서 참조할 수도 있다. createFormControls() { this.firstName = new FormControl('', Validators.required); this.lastName = new FormControl('', Validators.required); this.email = new FormControl('', [ Validators.required, Validators.pattern(\"[^ @]*@[^ @]*\") ]); this.password = new FormControl('', [ Validators.required, Validators.minLength(8) ]); this.language = new FormControl('', Validators.required); }createForm() { this.myform = new FormGroup({ name: new FormGroup({ firstName: this.firstName, lastName: this.lastName, }), email: this.email, password: this.password, language: this.language }); }&lt;div class=\"form-group\" [ngClass]=\"{ 'has-danger': firstName.invalid &amp;&amp; firstName.dirty, 'has-success': firstName.valid &amp;&amp; firstName.dirty }\"&gt; 4.Validation messages폼을 스타일링하는 것과 마찬가지로 유저가 유효하지 않은 값을 넣었을 때 hint를 주면 어떻게 유효한 값을 입력할 지 알 수 있게 된다. Validator가 여러개일 때, 각각에 맞는 에러메시지를 보여주려면 어떻게 해야할까?formControl의 errors 프로퍼티를 체크해서 처리할 수 있다.만약 errors 객체의 required 키가 있는 경우, 이것은 유저가 필수입력값을 입력하지 않았다는 의미이다. &lt;div class=\"form-control-feedback\" *ngIf=\"password.errors &amp;&amp; (password.dirty || password.touched)\"&gt; &lt;p *ngIf=\"password.errors.required\"&gt;Password is required&lt;/p&gt; &lt;p *ngIf=\"password.errors.minlength\"&gt;Password must be 8 characters long&lt;/p&gt;&lt;/div&gt; Submitting &amp; ResettingSubmit을 클릭했을 때 컴포넌트에 있는 함수를 어떻게 콜할 것인가?그리고, 어떻게 원래상태로 되돌릴 것인가? 1. SubmittingForm태그 안에 Type=submit인 button 이 필요하다.일반적인 HTML5는 submit을 클릭하면 바로 해당 폼을 POST형식으로 현재 url에 전달한다. 그러나 POST형식으로 전달하는 거 말고 함수를 호출할 수도 있다. Form태그에 추가된 ngSubmit 디렉티브를 통해 할 수 있다.(ngSubmit)=&quot;onSubmit(myForm.value)&quot;현재 폼의 값을 함수로 전달할 수 있다. 2. Resetting모델기반 폼에서 폼을 리셋하기위해서 myForm.reset()메소드만 호출하면 된다.인풋 값이 초기값으로 리셋되고, valid, touched or dirty 프로퍼티도 초기화된다. Reactive Model Form1. formControl 디렉티브를 어떻게 사용하는가? 2. FormGroup / FormControl observable을 어떻게 구독할까? 3. RxJS의 debounceTime, distinctUntilChanged를 어떻게 사용하는가?FormControls와 FormGroups는 valuesChanged 라는 observable을 노출한다.valuesChanged를 구독함으로써 실시간으로 폼의 값이 바뀌는 걸 캐치할 수 있다. ngOnInit() { this.searchField = new FormControl(); this.searchField.valueChanges .subscribe(term =&gt; { this.searches.push(term); });} ngOnInit() { this.searchField = new FormControl(); this.searchField.valueChanges .debounceTime(400) // 400밀리초의 디바운스 타임을 준다. .distinctUntilChanged() //값이 이전값과 달라졌을 때만 구독한다. .subscribe(term =&gt; { this.searches.push(term); });} Summary폼을 제출했을 때 함수를 호출한 다음 폼액션을 처리하는 방식으로 모델기반폼을 처리할 수 있다.그러나 앵귤러를 이용하면 observable을 구독함으로써 폼을 처리할 수도 있다. 리액티브폼과 몇가지 RxJS 오퍼레이터를 사용하면 단 몇줄의 코드로 강력한 기능을 구현할 수 있다. 실시간으로 유저가 입력하는 폼을 처리해야할 때 Reactive Form이 더 유용하다.유저가 버튼을 클릭했을 때만 폼을 처리해야하면 Model driven Form이 더 유용하다. 두가지 방법이 상호배타적인 것이 아니므로 적절히 잘 섞어서 사용하면 되겠다. Template Driven Forms1. Template driven form과 model driven form의 차이점을 알자. 2. 템플릿 input 컨트롤을 컴포넌트의 프로퍼티로 연결하기 위해 ngModel 디렉티브를 어떻게 사용할 것인가. 3. Template driven form에서 폼 유효성체크를 어떻게 구현할 것인가. 4. Template driven form에서 submit, reset을 어떻게 할 것인가.템플릿 기반이나 모델기반이나 모델을 사용한다는 걸 이해하자.템플릿기반 폼은 템플릿에 디렉티브를 이용해 FormGroups, FormControls로 모델을 생성한다. 1.Directives템플릿 기반 폼을 만들 때 필요한 디렉티브는 FormsModule에 있다. ReactiveFormsModule이 아니라. FormsModule에서 가져온 디렉티브 중 하나는 ngForm이다.This instance of ngForm is hidden but we can expose it with a local template reference variable attached to the form element, like so:&lt;form #f=&quot;ngForm&quot;&gt; ... &lt;/form&gt; 변수 f는 템플릿에서 지역변수로 쓸 수 있는데 f는 ngForm 디렉티브의 객체를 가르킨다. &lt;pre&gt;{{f.value | json}}&lt;/pre&gt; 을 찍어보면 {} 빈 객체가 찍히는데 ngForm 디렉티브는 자동으로 form태그안에 있는 모든 컨트롤을 감지하지 않기 때문이다.그래서 최상위 FormGroup이 만들어졌지만 비어있다. 그래서 명시적으로 ngForm디렉티브를 이용해 컨트롤을 등록을 해줘야하는데,ngForm디렉티브는 FormControl 객체를 만들어내고 FormGroup에 매칭시킨다. To do that we need to do two things to each template form control: 1. Add the NgModel directive 2. Add the name attribute.&lt;input name=&quot;foo&quot; ngModel&gt; 모델기반 폼에서는 아래와 같이 해줬다. let model = new FormGroup({ \"foo\": new FormControl()}); 2.Two way data bindingThe [( )] syntax is a combination of the syntax for input property binding [] and output event binding ()The long form of writing the above would be:&lt;input ... [ngModel]=&quot;email&quot; (ngModelChange)=&quot;email = $event&quot; &gt;But the [()] syntax is shorter and clearly shows we are implementing two way data binding on this input control. 3.Domain model앵귤러에서 일반적으로 간단한 스트링이나 객체에 데이터바인딩을 하지 않지만 클래스를 통해 정의한 도메인 모델을 통해서는 데이터바인딩을 한다. class Signup { constructor(public firstName: string = '', public lastName: string = '', public email: string = '', public password: string = '', public language: string = '') { }}model: Signup = new Signup(); 4.Validation모델기반폼에서는 validator를 ts파일에다 정의했다.템플릿 기반폼에서는 디렉티브를 통해 validate를 한다.HTML5에 빌트인되어 있는 디렉티브이다. &lt;div class=\"field\"&gt; &lt;label&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" #password=\"ngModel\" [(ngModel)]=\"model.password\" required minlength=\"8\"&gt; &lt;div class=\"form-control-feedback\" *ngIf=\"password.errors &amp;&amp; (password.dirty || password.touched)\"&gt; &lt;p *ngIf=\"password.errors.required\"&gt;Password is required&lt;/p&gt; &lt;p *ngIf=\"password.errors.minlength\"&gt;Password must be at least 8 characters long&lt;/p&gt;&lt;/div&gt; 5.Resetting the form모델기반폼에서는 reset()을 사용할 수 있지만,템플릿기반폼에서는 f.form을 컴포넌트에서 참조할 수 없다 BUT!!!ngForm의 객체를 컴포넌트에서 ViewChild 데코레이터를 이용해 참조할 수 있다!!ViewChild 데코레이터는 템플릿에 있는 변수를 컴포넌트에서 참조할 수 있도록 도와준다. @ViewChild('f') form: any;this.form.reset()","link":"/2018/06/28/Programming/Angular/angular-forms/"},{"title":"Angular의 injector tree 구조 파악하기","text":"Angular5 / Injector Tree앵귤러에서 인젝터 트리의 구조가 어떻게 구성되었는지 살펴보았다. (위의 그림을 보면서 아래의 설명을 이해해보자!!) 앵귤러는 컴포넌트 트리의 구조와 동일한 인젝터 트리를 가진다.위의 그림에서 @NgModule의 provider 배열을 해 설정된 Root Injector가 하나 있다. 루트 인젝터에는 LoginService가 등록되어 있다. 루트 인젝터 아래에는 root Component가 있다.이 컴포넌트에는 provider배열이 없고 루트 인젝터를 사용한다. 하위 인젝터가 2개 있는데, 각각의 ChatWindow Component를 위한 인젝터다. 각 컴포넌트는 해당 컴포넌트에서 생성한 CharService를 가지고 있다. 세번째 하위 컴포넌트로 Logout/Login Component가 있고, 여기에는 인젝터가 없다. 그리고, 인젝터가 없는 몇몇 개의 하위 컴포넌트가 있다.각각의 ChatWindow Component에는 하위 컴포넌트로 ChatFeed, ChatInput Component가 있고,Logout/Login Component의 하위 컴포넌트로는 Login Widget Component, Logout Widget Component이 있다. 인젝터 트리는 모든 컴포넌트에 대해서 새로운 인젝터를 생성하지는 않는다.@Component의 메타데이터로 Providers 배열이 있는 컴포넌트에만 새로운 인젝터를 생성한다.Providers배열이 없으면 그 상위컴포넌트의 인젝터에서 찾는다.만약 상위 컴포넌트에도 없으면 Root Injector에 도달할 때까지 계속 상위 인젝터를 찾는다. 위 그림에서 실선은 Component Tree를 나타내고, 점선은 Injector Tree를 나타내는 데, 두 개의 트리구조가 동일함을 알 수 있다. 경고: provider 배열에 주의하자. 하위 Component가 상위 Component에서도 요청된 의존성을 포함하는 provider 배열로 메타데이터로 가질 경우, 하위 Component가 가지는 의존성은 상위 Component의 의존성을 가린다. 만약 Chat Window Component에서 provider 배열로 LoginService를 새롭게 선언했다면, 이 LoginService는 root injector에 등록된 LoginService와는 다른 인스턴스다.","link":"/2018/05/04/Programming/Angular/angular-injector-tree/"},{"title":"앵귤러에서 이미지 경로 세팅","text":"앵귤러에서 이미지 경로 세팅앵귤러 프로젝트에서 css파일에 백그라운드 이미지 경로를 넣었더니 assets폴더에 있는 이미지를 제대로 불러들이지 못하는 에러가 발생했다. .intro { background: url(\"./images/overlay.png\"), url(\"./images/intro.jpg\") } 이미지의 경로를 이렇게 넣었더니 이미지 파일을 찾지 못하고 GET http://localhost:4200/images/overlay.png 404 (Not Found) 에러가 발생했다.(실제로 저 위치에 이미지는 존재했는데도 불구하고 이미지를 찾지못함.) .intro { background: url(\"assets/css/images/overlay.png\"), url(\"assets/css/images/intro.jpg\") }.intro { background: url(\"../../assets/css/images/overlay.png\"), url(\"../../assets/css/images/intro.jpg\") } 위와 같이 경로를 넣어주니까 아래와 같이 이미지를 제대로 불러오는 것을 알 수가 있다. 그리고 html에서도 아래와 같이 경로지정을 해줬더니 이미지를 잘 불러온다. &lt;a href=\"assets/css/images/fulls/01.jpg\" class=\"image fit\"&gt; &lt;img src=\"assets/css/images/thumbs/01.jpg\" title=\"The Anonymous Red\" alt=\"\" /&gt;&lt;/a&gt; [참고]절대경로와 상대경로절대경로작업 디렉토리와 관계없이 절대적인 위치를 가리키는 경로상대경로작업 디렉토리를 기준으로 상대적인 위치를 가리키는 경로/ : 최상위 경로를 의미./: 현재 디렉토리를 의미../: 상위 디렉토리를 의미","link":"/2018/05/11/Programming/Angular/img-path/"},{"title":"타입스크립트에서 json파일 import하기","text":"타입스크립트에서 json파일 import하기ES6/ES2015에서 json파일을 코드에 import할 수 있다. 만약 example.json이 있다면 { \"name\": \"testing\"} ES6/ES2015에서 아래와 같은 방식으로 import할 수 있다. // ES6/ES2015// app.jsimport * as data from './example.json';const word = data.name;console.log(word); // output 'testing' 하지만 typescript에서는 똑같이 적용하면 에러가 발생한다. Cannot find module 'example.json' 해결방법TS Definition 파일에 (예를 들면, typings.d.ts파일) 아래를 추가하면 된다. declare module \"*.json\" { const value: any; export default value;} 그럼 아래와 같이 동작할 수 있다. // Typescript// app.tsimport * as data from './example.json';const word = (&lt;any&gt;data).name;console.log(word); // output 'testing'","link":"/2018/05/23/Programming/Angular/import-json-in-typescript/"},{"title":"MSBUILD - error MSB3428 에러 해결","text":"“MSBUILD : error MSB3428” 에러 해결npm을 통해 모듈들을 다운받다보면 가끔 “MSBUILD : error MSB3428” 에러가 발생하면서 npm install이 제대로 동작하지 않을 때가 있다. 에러 MSBUILD : error MSB3428: Visual C++ 구성 요소 “VCBuild.exe”을(를) 로드할 수 없습니다. 이 문제를 해결하려면 1) .NET Framework 2.0 SDK를 설치하거나, 2) Microsoft Visual Studio 2005를 설치하거나, 3) 해당 구성 요소 가 다른 위치에 설치되어 있는 경우에는 그 위치를 시스템 경로에 추가하십시오. [c:\\Users\\JooYoung\\workspace\\js\\server_side_javascript\\node_modules\\orientjs-native\\build\\binding.sln] 해결방법 npm install –global –production windows-build-tools (관리자 모드로 실행한 커맨드 창에서 실행해야 한다. 시간이 좀 걸림) node-gyp이 python 2.x를 사용하여 python 2.7을 설치한다음에, node-gyp이 그 2.7을 사용도록 설정. 위에서 ‘npm install –global –production windows-build-tools’을 실행하면, 사용자 홈디렉토리 밑에 .windows-build-tools\\python27이 이미 설치되어 있다. npm config set python &lt;파이썬설치디렉토리&gt;를 설정.","link":"/2018/05/14/Programming/Angular/msbuild-errorMSB3428/"},{"title":"앵귤러와 ngrx 버전 미스 매치","text":"Angular에서 ngrx도입 시 주의해야할 점앵귤러 버전5 프로젝트에서 ngrx 버전6을 의존했더니 아래와 같은 에러를 냈다. angular ngrx store error Cannot read property 'schedule' of undefined 해결방법구글링을 해보니 npm WARN @ngrx/store@6.0.1 requires a peer of @angular/core@^6.0.0 but none is installed. You must install peer dependencies yourself. angular@6 에서만 @ngrx/store@6 을 사용할 수 있다. npm install @ngrx/store@5.2.0 ngrx버전을 5로 낮추니 문제가 해결됐다.","link":"/2018/08/04/Programming/Angular/angular-ngrx-error/"},{"title":"앵귤러에서 뒤로가기 에러 해결 (routing)","text":"앵귤러에서 routing 설정회사 프로젝트를 진행하던 중, 브라우저에서 뒤로가기 버튼을 클릭했을 때 뒤로 가기가 제대로 동작하지 않는 문제가 있었다. 문제상황{ path: 'home', component: HomeComponent,},{ path: 'home/:platform', component: HomeComponent},{ path: 'home/:platform/:lang', component: HomeComponent},{ path: 'new-account', component: NewAccountComponent},{ path: 'new-account/:lang', component: NewAccountComponent}, 라우팅을 위와 같이 Optional하게 파라미터를 설정하는 방식으로 구성했더니.home페이지로 들어오면 url이 /home -&gt; /home/platform -&gt; /home/platform/lang 이렇게 이중, 삼중으로 변경되었다. new-account페이지에서 home페이지로 온 뒤, 브라우저의 뒤로가기 버튼을 클릭하면 new-account페이지가 아니라, /home/platform -&gt; /home/platform/lang으로 redirect되어 뒤로가기가 제대로 동작하지 않는 문제가 발생했다. 해결방법우리 사이트의 경우 url에 플랫폼과 언어정보가 붙는 것은 필수적이므로 아래와 같이 라우팅을 변경했다. {path: 'home/:platform/:lang',component: HomeComponent},{path: 'new-account/:lang',component: NewAccountComponent }, 위와 같이 변경했더니 원하는대로 뒤로가기를 할 수 있었다. 앵귤러의 라우팅에 대해 좀 더 상세히 정리할 필요가 있겠다.결국 Optional하게 파라미터를 추가하는 방식을 잘못 사용했기 때문에 위와 같은 문제가 발생한 것이다! 제대로 알고 사용하자! &lt;참고블로그&gt;https://codecraft.tv/courses/angular/routing/parameterised-routes/https://www.sitepoint.com/component-routing-angular-router/","link":"/2018/05/24/Programming/Angular/routing-error/"},{"title":"재귀(recursion)","text":"여러가지 알고리즘에 쓰이는 코딩 테크닉인 재귀(recursion)을 배운다.하나의 문제를 기본단계와 재귀단계로 나누는 방법을 배운다. 프로그래밍을 하면서 재귀라는 용어를 종종 접해왔지만 완벽히 이해하지 못한 채 항상 얼버무리듯이 대충 넘어가곤 했었는데이번에는 기필코!!! 재귀를 완전히 내 것으로 만들자! “재귀”를 한 눈에 보여주는 그림을 찾았다!!! 러시아 인형 속에 더 작은 러시아 인형이 있고 또 그 인형 안에 더 작은 인형이 있는데, 이는 러시아 인형이 너무 작아서 다른 인형을 담지 못할 때까지 계속 된다.이처럼 어떤 문제를 해결하기 위해 알고리즘을 설계할 때 동일한 문제의 조금 더 작은 경우를 해결함으로써 그 문제를 해결하는 것이다. 문제가 간단해져서 바로 풀 수 있는 문제로 작아질 때까지!!이런 테크닉을 바로 재귀!!라고 한다! 기본 단계와 재귀 단계재귀함수는 자기 자신을 호출하기 때문에 실수로 무한 반복을 하는 함수를 만들기 쉽다.재귀함수를 만들 때는 언제 재귀를 멈출지를 알려줘야 한다.그래서 모든 재귀함수는 기본단계와 재귀단계로 나눠져있다. 재귀단계 - 함수가 자기 자신을 다시 호출하는 부분.기본단계 - 자기 자신을 다시 호출하지 않는 부분. 즉, 무한 반복에 빠지지 않게 하는 부분 countdown = i =&gt; { console.log(i); if (i &lt;= 0) // 기본단계 return; else countdown(i - 1); //재귀단계};countdown(5); 스택스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다. 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출 방식으로 자료를 처리한다. 포스트잇을 생각하면 새로운 포스트잇을 가장 위에다 붙이고(push), 뗄 때도 가장 위에 있는 것부터 떼어낸다(pop). 호출 스택컴퓨터는 호출 스택이라고 불리는 스택을 사용. greet2 = (name) =&gt; { console.log(`how are you, ${name}?`);}bye = () =&gt; { console.log(`ok bye!`);}greet = (name) =&gt; { console.log(`hello, ${name}!`); greet2(name); console.log(`getting ready to say bye...`); bye();}greet('mina'); // 결과 hello, mina! how are you, mina? getting ready to say bye... ok bye! 1. greet(name)함수를 실행하기 위해서 컴퓨터는 메모리상자를 하나 할당 2. name이라는 변수의 값이 &quot;mina&quot;가 되었으므로 이 값을 메모리에 저장 3. greet2(name)함수를 호출하기 위해 또다른 메모리상자를 할당 4. `how are you, name?`을 찍고 함수 호출 상태에서 반환하여 돌아옴 5. 함수가 반환되면 가장 위에 있는 상자는 POP 연산으로 없어짐 6. 다시 greet(name)함수로 돌아옴 (**어떤 함수를 호출하여 완전히 실행을 완료하기 전이라도 그 함수를 잠깐 멈추고 다른 함수를 호출할수 있다. 중지된 함수의 변수의 값은 모두 메모리에 저장되어 있다!!!**) 1. bye() 함수 실행 후 다시 return 2. 현재 greet(name)함수. 더이상 실행할 것이 없으므로 greet함수에서도 반환하여 돌아옴이런 식으로 여러 개의 함수를 호출하면서 사용되는 변수를 저장하는 스택을 호출 스택Call Stack이라고 한다. 재귀 함수에서 호출 스택 사용fact = x =&gt; { if (x == 1) return 1; else return x * fact(x - 1);};console.log(fact(5)); fact(5)를 호출하면 그 위에 fact(4)가 쌓이고 또 그 위에는 fact(3) …fact(2) fact(1)이렇게 함수가 호출된다.fact(1)에 다다르면 1을 리턴하고 스택에서 pop된다. 나머지 함수에 대해서도 동일한 작업이 진행된다. 스택을 사용하면 모든 정보를 저장해야 하므로 메모리를 많이 소비,스택이 너무 커졌다는 것은 과다한 함수 호출정보를 저장하고 있다는 의미… stack overflow 에러가 발생할 것이다. 적절하게 잘 사용해야겠다… 3장에서 배운 내용1. 재귀는 함수가 스스로를 호출하는 것 2. 모든 재귀 함수는 기본 단계와 재귀 단계라는 두 부분으로 나누어져 있다 3. 스택에는 push와 pop이라는 두 가지 연산이 있다 4. 모든 함수 호출은 호출 스택을 사용 5. 호출 스택은 너무 커져서 메모리를 엄청나게 소비할 수도 있다","link":"/2018/04/23/Programming/Angular/recursion/"},{"title":"앵귤러에서 GA달기","text":"SPA에 GA 달기문제상황1. 추적 코드 누락 error 메시지. &quot; 유효한 추적 코드를 찾을 수 없습니다.&quot; 2. 활성 사용자 집계는 안 되고 있음. 3. 사용자 이벤트발생 추적은 정상적 원인일반적인 웹사이트의 경우는 페이지를 이동할 때마다 서버에서 리소스를 다운받기 때문에 구글에서 제공하는 아래와 같은 추적코드를 헤더(header) 혹은 푸터(footer)같은 웹사이트 내 (거의) 모든 페이지에서 동일하게 실행되는 영역에 붙이면 사용자 트래킹이 가능하다.(사용자가 새 페이지로 이동할 때마다 추적코드가 실행되기 때문에 사용자의 행동을 추적가능하다) &lt;script&gt; (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject'] = r; i[r]=i[r]||function(){ (i[r].q = i[r].q || []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-xxxxxxxx-x', 'auto'); ga('send', 'pageview'); // Pageview event&lt;/script&gt; 하지만 앵귤러와 같은 SPA(Single Page Application)의 경우, 처음 페이지로드를 할 때 사이트 전체를 탐색하는 데 필요한 모든 리소스를 로드하기 때문에 위의 추적코드가 앱이 최초 실행될 때 딱 한번만 실행된다. 그래서 추가적으로 앵귤러 앱내에서 페이지 이동이 일어날때 GA에 알려주는 코드가 필요! 해결방법앵귤러는 라우터모듈을 통해서 페이지 이동을 하는데이 때, Router.events 발생시킨다. 이 이벤트를 받아서 GA에 알려주면 되겠다. app.component.ts의 constructor에 this.router.events.subscribe(event =&gt; { if (event instanceof NavigationEnd) { (&lt;any&gt;window).ga('set', 'page', event.urlAfterRedirects); (&lt;any&gt;window).ga('send', 'pageview'); } }); 사용자의 페이지 이동을 추적할 수 있다.위 코드를 추가하니, 활성사용자 집계도 정상적으로 동작한다.","link":"/2018/05/09/Programming/Angular/spa-ga/"},{"title":"[ERROR] no space left on device","text":"문제 상황우분투에서 no space left on device 에러 때문에 데몬으로 돌고 있던 서비스가 중단되는 상황이 발생했다. journalctl -u [systemd unit name] -xe 를 통해 에러로그를 확인해 보니 아래와 같았다. prometheus[10240]: level=error ts=2020-01-13T02:42:03.333Z caller=db.go:609 component=tsdb msg=\"compaction failed\" err=\"persist head block: mkdir /var/lib/prometheus/01DYECF5\"prometheus[10318]: level=error ts=2020-01-13T02:48:38.374Z caller=db.go:609 component=tsdb msg=\"compaction failed\" err=\"persist head block: 2 errors: *write compaction: write chunks: no space left on device; *write /var/lib/prometheus/01DYECV759ENR26FQM1JH51Z90.tmp/index: no space left on device\"prometheus[10318]: level=error ts=2020-01-13T02:48:39.375Z caller=db.go:609 component=tsdb msg=\"compaction failed\" err=\"persist head block: mkdir /var/lib/prometheus/01DYECV86FXD7TCM5FQ47064ZT.tmp: no space left on device\".... 해결 방법1. 남은 디스크 용량 확인df -h// 결과값Filesystem Size Used Avail Use% Mounted on.../dev/xvda1 9.7G 9.7G 814M 100% /tmpfs 996M 0 996M 0% /dev/shm... 2. 디스크 용량을 가장 많이 사용하는 순서대로 sort 해서 파일에 저장sudo du -ckx | sort -n &gt; /tmp/duck-rootsudo tail /tmp/duck-root// 결과값912776 ./var/log/journal/b01ab494c90847679cfeb694e862ddbb912780 ./var/log/journal... 3. 우분투 서비스 로그 파일이 담기는 journal 로그 파일 비우기먼저 systemd journal log 파일이 얼마만큼의 디스크용량을 차지하고 있는지 확인한다. journalctl —disk-usage// 결과값// Archived and active journals take up 907.3M in the file system. 아래의 명령어를 통해 journal 로그 파일 비운다. sudo journalctl -—rotate -—vacuum-time=2weeks To remove all journal entries (including active journal files, which are marked as archived by the –rotate command)–vacuum-time=2weeks은 2주보다 더 오래 보관된 journal log 파일은 지우겠다는 옵션–rotate : active journal file을 archived(보관된, 아카이브된)으로 바꿔서 새로 쓰여지지 않도록 한다. 이를 사용하지 않으면 active journal log file은 지워지지 않는다. 4. journald.conf 파일 수정특정 조건이상으로 로그 파일이 커지지 않도록 journald.conf파일을 수정한다. cd /etc/systemdsudo nano journald.conf// 주석 처리되어 있는 설정값들을 수정하고 저장SystemMaxUse= (e.g.: SystemMaxUse=100M to remove archived journal files until the disk space they use falls below 100M) and/or MaxFileSec= (.e.g. MaxFileSec=5day to make all journal files contain no data older than 5 days).// 새로운 설정값을 읽도록 재시작sudo systemctl restart systemd-journald [참고]https://www.linuxuprising.com/2019/10/how-to-clean-up-systemd-journal-logs.htmlhttps://withcoding.com/104https://twpower.github.io/171-journalctl-usage-and-examples","link":"/2020/01/13/Programming/Server/no-space-left-on-device/"},{"title":"constructor와 ngOnInit 차이점","text":"constructor와 ngOnInit 차이점앵귤러의 lifecycle의 ngOnInit()과 constructor의 차이점을 정리해보려 한다.constructor를 사용할 수 있는데도 ngOnInit이 필요한 이유가 뭘까? https://toddmotto.com/angular-constructor-ngoninit-lifecycle-hook 의 글을 참고했다. constructor와 ngOnInit은 뭐가 다른걸까?ES6 클래스(앵귤러에서는 TypeScript)에서 constructor 메소드는 클래스 자체의 기능이다. 반면 ngOnInit()은 앵귤러의 기능.constructor가 호출될 때는 앵귤러의 컨트롤을 벗어난다.이 의미는, 앵귤러가 컴포넌트 초기화를 마쳤는지 알기에는 적당한 위치가 아니다. 컴포넌트를 살펴보면 import { Component } from '@angular/core';@Component({})class ExampleComponent { // this is called by the JavaScript engine // rather than Angular constructor() { console.log('Constructor initialised'); }}// internally calls the constructornew ExampleComponent(); 여기서 가장 중요한 점은! 앵귤러가 아니라 JavaScript 엔진이 constructor를 호출한다는 것! 이 때문에 ngOnInit이라는 lifecycle이 생겼다.이 lifehook을 추가하면서, 컴포넌트의 초기화가 끝난 후 앵귤러는 그 메소드를 실행시킨다. ngOnInit()이라는 네이밍에서 알 수 있듯이 이 메소드는 컴포넌트의 lifecycle 중 하나다. import { Component, OnInit } from '@angular/core';@Component({})class ExampleComponent implements OnInit { constructor() {} // called on demand by Angular ngOnInit() { console.log('ngOnInit fired'); }}const instance = new ExampleComponent();// Angular calls this when necessaryinstance.ngOnInit(); Constructor의 용도constructor는 컴포넌트에 의존성 주입을 하기에 알맞은 위치다.constructor는 자바스크립트 엔진이 초기화하는데, 필요한 의존성을 어떤 프로퍼티에 매핑할지 앵귤러에 알려준다. import { Component, ElementRef } from '@angular/core';import { Router } from '@angular/router';@Component({})class ExampleComponent { constructor( private router: Router, private el: ElementRef ) {}} 위의 코드에서 Router는 this.router에 바인드되고, 컴포넌트 클래스 안에서 this.router로 접근가능하다. ngOnInitngOnInit은 앵귤러가 컴포넌트를 초기화를 완료했다는 것을 우리에게 알려주기 위해서 만들어졌다. 이 단계는 컴포넌트에서 바인드한 프로퍼티에 첫 변경 감지가 되는 범위까지 포함되어 있다. @Input() 데코레이터를 사용하는 경우를 예로 들 수 있다 이 때문에 @Input()프로퍼티는 ngOnInit에서 읽어들일 수 있고, constructor에서는 undefined가 된다. import { Component, ElementRef, Input, OnInit } from '@angular/core';import { Router } from '@angular/router';@Component({})class ExampleComponent implements OnInit { @Input() person: Person; constructor( private router: Router, private el: ElementRef ) { // undefined console.log(this.person); } ngOnInit() { this.el.nativeElement.style.display = 'none'; // { name: 'Todd Motto', location: 'England, UK' } console.log(this.person); }} ngOnInit()는 바인딩한 값을 읽어들이는 것을 보장하는 lifecycle hook이다. contructor에서는 의존성 주입에 대한 작업을 하고, 변수 초기화 작업은 ngOnInit()에서 하도록하쟈~! [참고] 변경감지(Change Detection)가 일어나는 순서 1. update bound properties for all child components/directives 2. call ngOnInit, OnChanges and ngDoCheck lifecycle hooks on all child components/directives 3. update DOM for the current component 4. run change detection for a child component call ngAfterViewInit lifecycle hook for all child components/directives","link":"/2018/04/26/Programming/Angular/constructorVsNgOnInit/"},{"title":"엑셀에서 json파일 추출하기","text":"회사서비스에서 다국어를 지원하기 위해 번역 데이터를 하나로 정리해 둘 필요가 생겼다.앵귤러에서 다국어 서비스를 하기 위해서는 i18n 모듈을 사용하는데 나라별로 json파일이 필요하다. ( ko.json, en.json, cn.json 등등) 약간의 검토를 해보니 excel파일에서 json을 추출하는 방법이 있다는 것을 알게되어 정리를 해두게 되었다. 1. excel에서 데이터를 정리 후 csv파일로 저장2. http://www.convertcsv.com/csv-to-json.htm 에서 변환 작업2-1. Option1 : 변환할 csv 파일 선택 2-2. Options2 : First row is column names 옵션 체크2-3. Options4 : 출력할 형태 만들기 http://www.convertcsv.com/csv-to-template-output.htm 참고해서 형태 만들기{lb} : left bracket {{br} : Line break{rb} : right bracket }{f1} : 첫번째 필드값{h1} : 첫번째 헤드값 3. “Convert CSV To JSON via Template” 버튼 클릭하면 결과물이 나온다.","link":"/2018/05/28/Programming/etc/excel-to-json/"},{"title":"백준 알고리즘 Node.js 입출력 정리","text":"프로그래머스나 릿코드처럼 입출력을 알고리즘 문제사이트에서 알아서 처리해주고 함수만 구현하면 되는 환경에서 연습하다가처음 백준 알고리즘 사이트에서 문제풀이를 할 때 어떻게 입출력을 구현해야하는지 몰라 많이 당황했었다.백준 알고리즘에서의 입출력방법을 까먹지 않도록 정리했다. 입력var fs = require(\"fs\")// 문자 하나var input = fs.readFileSync(\"/dev/stdin\").toString()// 한 칸 띄어쓰기로 구분// input[0], input[1] 배열에서 꺼내쓰면 된다.var input = fs .readFileSync(\"/dev/stdin\") .toString() .split(\" \")// 줄바꿈으로 구분var input = fs .readFileSync(\"/dev/stdin\") .toString() .split(\"\\n\")// 만약 인풋값이 숫자라면var input = fs .readFileSync(\"/dev/stdin\") .toString() .split(\" \") .map(function(a) { return +a }) 출력백준 알고리즘에서는 console.log로 결과값의 로그를 찍어주면 된다.","link":"/2020/01/15/Programming/etc/acmicpc-nodejs-input/"},{"title":"ubuntu18.04에 NginX 설치 & SSL 붙이기","text":"1. apt 업데이트 및 업그레이드(https://www.cyberciti.biz/faq/ubuntu-lts-debian-linux-apt-command-examples/)Advanced Package Tool의 약자로 우분투(Ubuntu)를 포함한 데비안(Debian)계열의 리눅스에서 쓰이는 패키지 관리 도구 2. 우분투에 apt 이용해서 Nginx 설치sudo apt update # 패키지 저장소에 업데이트가 존재하는지 확인하는 역할만sudo apt upgrade # 실제로 최신 버전 패키지로 업데이트sudo apt install nginx 3. Nginx server 설정파일 생성위치는 etc/nginx/sites-available/custom_server_name.config server { listen 80; listen [::]:80; server_name custom_server_name location / { proxy_pass http://localhost:3000/; }} 4. /etc/nginx/sites-enabled/로 심볼릭 링크 연결cd /etc/nginx/sites-enabled/# sites-enabled 디렉토리에 있는 config파일은 nginx가 시작할 때 참조하는 파일이다.sudo ln -s /etc/nginx/sites-available/custom_server_name.conf . 5. Enable and restart Nginx server# 설정파일에 문법적 요류가 없는지 체크, 오류내용을 프린트한다sudo nginx -t# 참고로 나는 아래와 같은 오류가 떴다.[emerg] 10619#0: a duplicate default server for 0.0.0.0:80# /etc/nginx/sites-enabled에 default-server.conf, custom_server_name.conf 셋팅이 중복 그렇다.# /etc/nginx/sites-enabled 위치에 custom_server_name.conf만 남기면 Okay 설정파일에 이상이 없으면 nginx 를 재시작하면 된다. sudo service nginx reloadsudo service nginx status 6. Certbot 설치sudo apt install python-certbot-nginx Certbot은 SSL을 자동으로 구성하려면 Nginx 구성에서 올바른 서버 블록을 찾을 수 있어야한다.. 특히 인증서를 요청하는 도메인과 일치하는 server_name 지시문을 찾아서 이를 수행한다. 7. SSL 적용sudo certbot --nginx -d custom_server_name -nginx 플러그인과 함께 certbot을 실행하고 -d를 사용하여 인증서가 유효한 이름을 지정한다. OutputPlease choose whether or not to redirect HTTP traffic to HTTPS, removing HTTP access.-------------------------------------------------------------------------------1: No redirect - Make no further changes to the webserver configuration.2: Redirect - Make all requests redirect to secure HTTPS access. Choose this fornew sites, or if you're confident your site works on HTTPS. You can undo thischange by editing your web server's configuration.-------------------------------------------------------------------------------Select the appropriate number [1-2] then [enter] (press 'c' to cancel): http -&gt; https로 리다이렉트 시키기 위해서 2번을 입력하고 엔터를 누르면 OutputIMPORTANT NOTES:- Congratulations! Your certificate and chain have been saved at:/etc/letsencrypt/live/custom_server_name/fullchain.pemYour key file has been saved at:/etc/letsencrypt/live/custom_server_name/privkey.pem... 드디어 인증서가 다운로드되고 로드되었다.custom_server_name.conf가 아래와 같이 변경됨을 알 수 있다. # Redirecting HTTP to HTTPSserver { listen 80 default_server; listen [::]:80 default_server ipv6only=on; server_name custom_server_name; if ($host = custom_server_name) { return 301 https://$host$request_uri; } # managed by Certbot return 404; # managed by Certbot}# Reverse Proxy Serverserver { listen 443 ssl; # managed by Certbot listen [::]:443 ssl ipv6only=on; # managed by Certbot server_name custom_server_name; ssl_certificate /etc/letsencrypt/live/custom_server_name/fullchain.pem; # managed by Certbot ssl_certificate_key /etc/letsencrypt/live/custom_server_name/privkey.pem; # managed by Certbot include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot location / { proxy_pass http://localhost:3000/; }} [참고]https://www.cyberciti.biz/faq/install-and-configure-nginx-on-ubuntu-linux-18-04-lts/https://www.digitalocean.com/community/tutorials/how-to-install-nginx-on-ubuntu-18-04https://www.digitalocean.com/community/tutorials/how-to-secure-nginx-with-let-s-encrypt-on-ubuntu-18-04","link":"/2020/02/12/Programming/Server/ubuntu-nginx/"},{"title":"ElasticSearch 스냅샷 생성 및 복원","text":"AWS elasticsearch에서 자동 백업을 지원하지만 이걸 복원하려면 AWS Support에 직접 요청하는 방식이라 원하는 시점에 복원하지 못할 수도 있다.또한 elasticsearch 버전을 올리기위해 마이그레이션을 할 때는 새로운 elasticsearch를 생성하고 직접 백업 및 복원을 해야한다.=&gt; 수동으로 스냅샷 생성하고 복원하는 작업이 필요하다. 1. 준비사항1-1. 스냅샷이 저장될 S3 만들기 버킷이름 정하기 되도록 해당 ES와 동일한 리전을 선택 나머지는 기본설정값으로 1-2. IAM Role 생성 IAM -&gt; Role(역할) - Create New Role(역할만들기) AWS 서비스 - EC2 - “다음”버튼 Attach Policy에서는 아무것도 선택하지 않고 “다음” 검토 - 원하는 역할이름 (EsSnapshotRole)입력하고 - 역할만들기 신뢰관계 - 신뢰 관계 편집 // 신뢰 관계{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"es.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ]} 1-3. IAM Policy 생성 후 연결 정책 생성 버튼 시각적편집기/JSON 중에서 JSON탭 선택 아래와 같은 데이터 넣음 (s3-bucket-name에 본인이 만든 버킷이름 넣음) { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [\"s3:ListBucket\"], \"Effect\": \"Allow\", \"Resource\": [\"arn:aws:s3:::s3-bucket-name\"] }, { \"Action\": [\"s3:GetObject\", \"s3:PutObject\", \"s3:DeleteObject\"], \"Effect\": \"Allow\", \"Resource\": [\"arn:aws:s3:::s3-bucket-name/*\"] } ]} 정책검토 클릭 - 정책 이름( EsCosmoshub2SnapshotPolicy) 입력 후, 정책 생성 1-4. IAM 정책과 역할 연결 IAM - Role - 아까 만든 역할 클릭 정책연결 클릭 미리 만든 정책검색 - 체크박스 클릭 - 정책연결 2. 스냅샷 생성2-1. 스냅샷 저장소 생성AWS elasticsearch service에서는 스냅샷 저장소 생성을 curl 명령어로 할 수 없음.python을 이용하거나 POSTMAN 이용.포스트맨을 이용해보겠다.포스트맨 Authorization설정에 type을 AWS Signature를 선택한 후 접근권한이 있는 계정 정보(AccessKey, SecretKey) 및 Advanced정보(AWS region, Service name)를 넣는다. PUT elasticsearch-domain-endpoint/_snapshot/{스냅샷 레포 이름}// body{ &quot;type&quot;: &quot;s3&quot;, &quot;settings&quot;: { &quot;bucket&quot;: &quot;s3버킷이름&quot;, &quot;region&quot;: &quot;ap-northeast-2&quot;, &quot;role_arn&quot;: &quot;arn:aws:iam::793775630439:role/역할이름&quot; }}// 아래와 같이 응답오면 okay{ &quot;acknowledged&quot;: true} 만약 위의 과정에서 아래와 같은 에러가 발생한다면 신뢰관계 - 신뢰 관계를 편집해줘야한다. { &quot;error&quot;: { &quot;root_cause&quot;: [ { &quot;type&quot;: &quot;repository_verification_exception&quot;, &quot;reason&quot;: &quot;[kava_backup] path is not accessible on master node&quot; } ], &quot;type&quot;: &quot;repository_verification_exception&quot;, &quot;reason&quot;: &quot;[kava_backup] path is not accessible on master node&quot;, &quot;caused_by&quot;: { &quot;type&quot;: &quot;i_o_exception&quot;, &quot;reason&quot;: &quot;Unable to upload object [tests-Yf1EOrcpS_iSjfSL6PVFwQ/master.dat] using a single upload&quot;, &quot;caused_by&quot;: { &quot;type&quot;: &quot;a_w_s_security_token_service_exception&quot;, &quot;reason&quot;: &quot;a_w_s_security_token_service_exception: Access denied (Service: AWSSecurityTokenService; Status Code: 403; Error Code: AccessDenied; Request ID: f2bf46e0-a6d4-11e9-a6e8-897239377f7d)“ } } }, &quot;status&quot;: 500} 2-2. 스냅샷 생성PUT {es주소}/_snapshot/{스냅샷 레포 이름}/{스냅샷 이름}{&quot;accepted&quot;: true}// 라고 뜨면 생성완료 GET {es주소}/_snapshot/{스냅샷 레포 이름}/{스냅샷 이름}// 통해서 완료여부 확인가능 3. 스냅샷 복원POST https://{es주소}/_snapshot/{스냅샷 레포 이름}/{복원할 스냅샷 이름}/_restore 스냅샷 생성할 때와 마찬가지로 실행하자마자 반환값이 나오지만 뒤에서 계속 복원중인 상태.복원 진행중일때는 클러스터 상태가 Red이고 원래의 클러스터 상태로 돌아오므로 클러스터 상태를 통해 복원이 완료됐는지 체크 [참고]스냅샷 생성에 필요한 시간은 Amazon ES 도메인의 크기에 따라 다르다.스냅샷 작업이 길게 실행되면 일반적으로 다음과 같은 오류가 발생한다.“504 GATEWAY_TIMEOUT. “elasticsearch에 저장하는 데이터가 보통 대용량이기 때문에 자주나타나는 에러다무시하고 작업이 성공적으로 완료될 때까지 기다리면 된다. GET https://{es주소}/_cluster/health 3-1. 다른 elasticsearch로 스냅샷을 복원하는 경우elasticsearch 를 마이그레이션 하거나 다른 elasticsearch 클러스터에 복원하려는 경우 새로운 elasticserach 에 스냅샷 저장소만 생성하면 된다. 스냅샷 저장소를 앞서 생성한 스냅샷 저장소와 동일한 옵션으로 생성하면 같은 S3를 바라보게 되므로 복원도 바로 된다 3-1-1. 새로 생성한 ES에 snapshot 저장소 생성PUT https://{새로운 es 주소}/_snapshot/{스냅샷 레포 이름}// body (복원하려는 스냅샷 저장소 정보와 동일하게){ &quot;type&quot;: &quot;s3&quot;, &quot;settings&quot;: { &quot;bucket&quot;: &quot;버킷이름&quot;, &quot;region&quot;: &quot;ap-northeast-2&quot;, &quot;role_arn&quot;: &quot;arn:aws:iam::793775630439:role/{role이름}&quot; }} 3-1-2. 복원요청POST https://{새로운es주소}/_snapshot/{스냅샷 레포 이름}/{스냅샷 이름}/_restore{&quot;accepted&quot;: true}// 응답이 위와 같이 오면 복원완료! 아래와 같은 에러 발생시, url 참고 [kava_backup:snap_shot_20190715/reFsXleAQlW7dss3uvNEew] cannot restore index [tx_index] because an open index with same name already exists in the cluster. Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement namehttps://aws.amazon.com/ko/premiumsupport/knowledge-center/elasticsearch-kibana-error/ [참고] https://blog.weirdx.io/post/32308?fbclid=IwAR3sC_l3GeImMAKI2ArwtvlxSnoxzBdId8F5_TJdO7cCRqtYmtOREGaz9UAhttps://m.blog.naver.com/PostView.nhn?blogId=znxcx93&amp;logNo=221305307740&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F","link":"/2019/12/02/Programming/ElasticSearch/snapshot/"},{"title":"material-ui 빌드 최적화 하는 방법","text":"문제상황import { Button, TextField } from \"@material-ui/core\" 이렇게 import를 하면 Button, TextField만 임포트되는 게 아니라 @material/core에 있는 모든 모듈들이 빌드파일이 포함된다. 딱 사용하려는 모듈만 import를 하려면 추가적으로 처리가 필요하다. # 1. 바벨 플러그인 임포트 모듈 설치yarn add -D babel-plugin-import 2-1. 웹팩을 사용한다면 webpack.config.js 파일 수정{ test: /\\.(js|mjs|jsx|ts|tsx)$/, include: paths.appSrc, loader: require.resolve(\"babel-loader\"), options: { customize: require.resolve(\"babel-preset-react-app/webpack-overrides\"), plugins: [ [ \"babel-plugin-import\", { libraryName: \"@material-ui/core\", // Use \"'libraryDirectory': '',\" if your bundler does not support ES modules libraryDirectory: \"\", camel2DashComponentName: false }, \"core\" ], ... ], ... } }, 2-2. 아니면, 프로젝트 루트 위치에// .babelrc.jsconst plugins = [ [ \"babel-plugin-import\", { libraryName: \"@material-ui/core\", // Use \"'libraryDirectory': '',\" if your bundler does not support ES modules libraryDirectory: \"esm\", camel2DashComponentName: false }, \"core\" ], [ \"babel-plugin-import\", { libraryName: \"@material-ui/icons\", // Use \"'libraryDirectory': '',\" if your bundler does not support ES modules libraryDirectory: \"esm\", camel2DashComponentName: false }, \"icons\" ]]module.exports = { plugins } [참고] https://material-ui.com/guides/minimizing-bundle-size/#ecmascript","link":"/2019/12/04/Programming/React/material-ui-optimization/"},{"title":"리액트 라우터 component vs render 차이","text":"리액트 라우터를 통해 렌더된 컴포넌트에 props를 어떻게 넘길 수 있는지 알아보자.특정 path와 그 때 렌더할 component를 Route에 넘겨주면 애플리케이션이 특정 path에 오면 그 component가 렌더링이 된다. &lt;Route path=\"/dashboard\" component=\"{Dashboard}\" /&gt; 만약, Dashboard에 props를 넘겨주고 싶으면?단순히 Route에 props를 하나 추가하면 안 된다. 리액트라우터는 이 props를 컴포넌트에 전달하지 않는다. &lt;Route path=\"/dashboard\" component=\"{Dashboard}\" isAuthed=\"{true}\" /&gt; 안됨 다른 방법으로는 아래와 같이 component에 dashboard를 리턴하는 inline function을 만드는 것을 생각할 수 있다. &lt;Route path=\"/dashboard\" component={() =&gt; &lt;Dashboard isAuthed=\"{true}\" /&gt;} /&gt; 위 방법은 동작은 하지만, 성능상 좋은 해결책이 아니다. 공식문서에 따르면, “When you use the component props, the router uses React.createElement to create a new React element from the given component. That means if you provide an inline function to the component attribute,_ you would create a new component every render._ This results in the existing component unmounting and the new component mounting instead of just updating the existing component.” 이미 존재하는 컴포넌트를 재활용하는게 아니라, 해당 컴포넌트를 렌더링할 때마다 언마운트 후 새로운 컴포넌트를 마운팅하는 거라 component에 function을 넘기는 것을 추천하지 않는다. 리액트라우터팀은 간단한 해결책을 제공했다.prop으로 component를 쓰는 대신, render을 쓰는 것이다.render는 functional component를 허용한다. 그리고 render를 사용하면 불필요하게 컴포넌트가 재마운트되지 않는다. &lt;Route path=\"/dashboard\" render={props =&gt; &lt;Dashboard {...props} isAuthed=\"{true}\" /&gt;} /&gt; 요약해보면, 만약 리액트라우터를 통해 렌더링되는 컴포넌트에 props를 넘기고 싶다면, Route의 component prop을 이용하는 것 대신에, render prop을 사용하면 된다. render를 사용하면 컴포넌트가 불필요하게 다시 마운트되지 않고, inline function에서 리턴하는 컴포넌트에 넘기는 props들을 제대로 전달한다. [참고] https://tylermcginnis.com/react-router-pass-props-to-components/","link":"/2019/12/04/Programming/React/react-router-component-vs-render/"},{"title":"Mac 업데이트 후 Git 에러 해결 방법","text":"문제상황이번에 Mojave에서 Catalina로 Mac os를 업데이트하고 나서 CLI로 git명령어를 사용하려니 아래와 같은 에러가 발생했다. xcrun: error: invalid active developer path (/Library/Developer/CommandLineTools), missing xcrun at: /Library/Developer/CommandLineTools/usr/bin/xcrun 해결방법reinstall the command line tools xcode-select --install// xcode-select: note: install requested for command line developer tools// 팝업창으로 소프트웨어 안내창이 뜨면 \"설치\"를 클릭하면 된다.","link":"/2020/01/03/Programming/etc/xcrun-error/"}],"tags":[{"name":"1일1알고리즘풀이","slug":"1일1알고리즘풀이","link":"/tags/1일1알고리즘풀이/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"kibana","slug":"kibana","link":"/tags/kibana/"},{"name":"elastic","slug":"elastic","link":"/tags/elastic/"},{"name":"글또4기","slug":"글또4기","link":"/tags/글또4기/"},{"name":"binarysearch","slug":"binarysearch","link":"/tags/binarysearch/"},{"name":"이진탐색","slug":"이진탐색","link":"/tags/이진탐색/"},{"name":"binary-search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/알고리즘/"},{"name":"빅오 표기법","slug":"빅오-표기법","link":"/tags/빅오-표기법/"},{"name":"Big-O","slug":"Big-O","link":"/tags/Big-O/"},{"name":"BinarySearchTree","slug":"BinarySearchTree","link":"/tags/BinarySearchTree/"},{"name":"다익스트라알고리즘","slug":"다익스트라알고리즘","link":"/tags/다익스트라알고리즘/"},{"name":"dijkstra-algorithm","slug":"dijkstra-algorithm","link":"/tags/dijkstra-algorithm/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","link":"/tags/탐욕알고리즘/"},{"name":"greedy-algorithm","slug":"greedy-algorithm","link":"/tags/greedy-algorithm/"},{"name":"너비우선탐색","slug":"너비우선탐색","link":"/tags/너비우선탐색/"},{"name":"breadth-first-search","slug":"breadth-first-search","link":"/tags/breadth-first-search/"},{"name":"해시테이블","slug":"해시테이블","link":"/tags/해시테이블/"},{"name":"hashtable","slug":"hashtable","link":"/tags/hashtable/"},{"name":"HashTable","slug":"HashTable","link":"/tags/HashTable/"},{"name":"MinMaxDivision","slug":"MinMaxDivision","link":"/tags/MinMaxDivision/"},{"name":"Codility","slug":"Codility","link":"/tags/Codility/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"선택 정렬","slug":"선택-정렬","link":"/tags/선택-정렬/"},{"name":"selection-sort","slug":"selection-sort","link":"/tags/selection-sort/"},{"name":"Heap","slug":"Heap","link":"/tags/Heap/"},{"name":"bubble sort","slug":"bubble-sort","link":"/tags/bubble-sort/"},{"name":"selection sort","slug":"selection-sort","link":"/tags/selection-sort/"},{"name":"insertion sort","slug":"insertion-sort","link":"/tags/insertion-sort/"},{"name":"MergeSort","slug":"MergeSort","link":"/tags/MergeSort/"},{"name":"QuickSort","slug":"QuickSort","link":"/tags/QuickSort/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Browser","slug":"Browser","link":"/tags/Browser/"},{"name":"for문","slug":"for문","link":"/tags/for문/"},{"name":"foreach문","slug":"foreach문","link":"/tags/foreach문/"},{"name":"for~in문","slug":"for-in문","link":"/tags/for-in문/"},{"name":"for~of문","slug":"for-of문","link":"/tags/for-of문/"},{"name":"크로스 도메인","slug":"크로스-도메인","link":"/tags/크로스-도메인/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"SOP","slug":"SOP","link":"/tags/SOP/"},{"name":"else if","slug":"else-if","link":"/tags/else-if/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"화살표 함수","slug":"화살표-함수","link":"/tags/화살표-함수/"},{"name":"arrow-function","slug":"arrow-function","link":"/tags/arrow-function/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"매개변수","slug":"매개변수","link":"/tags/매개변수/"},{"name":"인수","slug":"인수","link":"/tags/인수/"},{"name":"parameter","slug":"parameter","link":"/tags/parameter/"},{"name":"argument","slug":"argument","link":"/tags/argument/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"clipboard.js","slug":"clipboard-js","link":"/tags/clipboard-js/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"함수형 자바스크립트","slug":"함수형-자바스크립트","link":"/tags/함수형-자바스크립트/"},{"name":"재사용 가능한, 모듈적인 코드로","slug":"재사용-가능한-모듈적인-코드로","link":"/tags/재사용-가능한-모듈적인-코드로/"},{"name":"고계 자바스크립트","slug":"고계-자바스크립트","link":"/tags/고계-자바스크립트/"},{"name":"vscode","slug":"vscode","link":"/tags/vscode/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"build.gradle","slug":"build-gradle","link":"/tags/build-gradle/"},{"name":"안드로이드 그래들","slug":"안드로이드-그래들","link":"/tags/안드로이드-그래들/"},{"name":"안드로이드","slug":"안드로이드","link":"/tags/안드로이드/"},{"name":"InflateException","slug":"InflateException","link":"/tags/InflateException/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"ObjectUnsubscribedError","slug":"ObjectUnsubscribedError","link":"/tags/ObjectUnsubscribedError/"},{"name":"architecture","slug":"architecture","link":"/tags/architecture/"},{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"click outside","slug":"click-outside","link":"/tags/click-outside/"},{"name":"formgroup","slug":"formgroup","link":"/tags/formgroup/"},{"name":"Directive","slug":"Directive","link":"/tags/Directive/"},{"name":"Custom Directive","slug":"Custom-Directive","link":"/tags/Custom-Directive/"},{"name":"Forms","slug":"Forms","link":"/tags/Forms/"},{"name":"injector","slug":"injector","link":"/tags/injector/"},{"name":"injector-tree","slug":"injector-tree","link":"/tags/injector-tree/"},{"name":"image-path","slug":"image-path","link":"/tags/image-path/"},{"name":"json import","slug":"json-import","link":"/tags/json-import/"},{"name":"MSBUILD","slug":"MSBUILD","link":"/tags/MSBUILD/"},{"name":"MSB3428","slug":"MSB3428","link":"/tags/MSB3428/"},{"name":"npm install error","slug":"npm-install-error","link":"/tags/npm-install-error/"},{"name":"ngrx","slug":"ngrx","link":"/tags/ngrx/"},{"name":"Routing","slug":"Routing","link":"/tags/Routing/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"재귀","slug":"재귀","link":"/tags/재귀/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"GoogleAnayltics","slug":"GoogleAnayltics","link":"/tags/GoogleAnayltics/"},{"name":"SPA","slug":"SPA","link":"/tags/SPA/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Prometheus","slug":"Prometheus","link":"/tags/Prometheus/"},{"name":"contructor","slug":"contructor","link":"/tags/contructor/"},{"name":"ngOninit","slug":"ngOninit","link":"/tags/ngOninit/"},{"name":"엑셀","slug":"엑셀","link":"/tags/엑셀/"},{"name":"csv","slug":"csv","link":"/tags/csv/"},{"name":"ubuntu","slug":"ubuntu","link":"/tags/ubuntu/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"material-ui","slug":"material-ui","link":"/tags/material-ui/"},{"name":"react-router","slug":"react-router","link":"/tags/react-router/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Algorithm","slug":"Programming/Algorithm","link":"/categories/Programming/Algorithm/"},{"name":"Elastic","slug":"Programming/Elastic","link":"/categories/Programming/Elastic/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"Basic","slug":"Programming/Basic","link":"/categories/Programming/Basic/"},{"name":"JavaScript","slug":"Programming/JavaScript","link":"/categories/Programming/JavaScript/"},{"name":"etc","slug":"Programming/etc","link":"/categories/Programming/etc/"},{"name":"Android","slug":"Programming/Android","link":"/categories/Programming/Android/"},{"name":"Angular","slug":"Programming/Angular","link":"/categories/Programming/Angular/"},{"name":"Server","slug":"Programming/Server","link":"/categories/Programming/Server/"},{"name":"ElasticSearch","slug":"Programming/ElasticSearch","link":"/categories/Programming/ElasticSearch/"},{"name":"React","slug":"Programming/React","link":"/categories/Programming/React/"}]}