{"pages":[{"title":"","text":"","link":"/404.html"},{"title":"About","text":"About Me Mina Choi","link":"/about/index.html"},{"title":"Archives","text":"","link":"/archive/index.html"},{"title":"Tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"Angular의 Component에 대한 정리","text":"Angular5 / Components https://codecraft.tv/courses/angular/components/overview/ 의 글을 번역했다. 컴포넌트는 앵귤러 앱의 기본적인 빌딩블록이다. 우리는 작은 컴포넌트를 사용해 큰 컴포넌트를 만들 수 있다. 앵귤러는 이러한 컴포넌트의 트리라고 할 수 있다. 각 컴포넌트가 렌더링될 때, 해당 컴포넌트의 하위 컴포넌트까지 렌더링한다. 루트 컴포넌트는 이 컴포넌트 트리의 최상단에 있는 컴포넌트다. 우리가 앵귤러 앱을 실행할 때, 우리는 브라우저에게 루트 컴포넌트를 렌더링하라고 알려준다. 그리고 루트 컴포넌트는 그 안에 포함된 하위 컴포넌트를 렌더링한다. 이 포스트를 통해 아래의 사항들을 정리해보자! 컴포넌트를 사용해 앱을 설계하는 방법 @Component에 대해 깊게 알아보기 Content Projection 컴포넌트 lifecycle hooks View Childres vs Content Children Component 설계 앵귤러 앱을 설계하는 법을 알아보자. 앵귤러 앱을 만들 때, 우리는 다음과 같은 과정을 거친다. 몇 개의 컴포넌트로 앱을 나눈다. 각 컴포넌트의 역할(기능)을 정리한다. 그 다음, 각 컴포넌트의 input, output을 정리한다. 아래의 예시를 보면 Header, Sidebar, Content구역을 가진 기본적인 앱이다. 각 컴포넌트는 자체 구성 요소로 구현한다. 그리고나서 각 컴포넌트의 responsibilities, inputs, outputs 등등을 리스트업한다. HeaderComponent Responsibilities 유저 로그인, 회원가입, 로그아웃과 관련된 모든 인증 기능들 Inputs 입력받는 것은 없음. Outputs -LoginChanged : 유저 로그인 상태가 변경되었을 때 발생되는 이벤트 SidebarComponent Responsibilities 검색관련 기능 Inputs 입력받는 것은 없음. Outputs -SearchTermChanged : 유저가 검색을 할 때 발생되는 이벤트, $event는 검색어를 담고있다. ContentComponent Responsibilities 검색 결과를 보여주는 역할 Inputs -SearchTerm : 필터링할 검색어를 입력받음. Outputs 아웃풋 없음 이렇게 inputs, outputs, 각 컴포넌트가 담당하는 기능들을 리스트업하는 것은 컴포넌트의 정확한 설계를 도와준다. 이렇게 하는 목적은 각각의 컴포넌트가 잘 정의된 기준을 가지도록 하는 것!!! 데이터 흐름 위의 컴포넌트를 루트컴포넌트와 연결하고 나면 데이터의 흐름이 아래 그림과 같을거다. inputs, outputs의 바인딩은 실제적으로 HTML(컴포넌트의 템플릿)에서 일어난다. 루트 컴포넌트의 템플릿은 아래와 같을거다. &lt;header (loginChanged)=\"loggedIn = $event\"&gt;&lt;/header&gt;&lt;sidebar (searchTermChanged)=\"searchTerm = $event\"&gt;&lt;/sidebar&gt;&lt;content [searchTerm]=\"searchTerm\"&gt;&lt;/content&gt; 데이터 흐름은 inputs, outputs를 통해 컴포넌트를 어떻게 연결하는지 보여준다. 위의 데이터흐름 다이어그램을 들여다보면 단방향 데이터 바인딩에 대해 흥미로운 점을 발견할 수 있다. inputs는 아래방향으로 전달되고, outputs은 위방향으로 전달된다. 단방향 데이터 바인딩을 통해 앱이 훨씬 심플해지고, 앱의 이벤트 흐름을 쉽게 추적할 수 있다. 정리해보면, 앵귤러 앱을 설계한다는 것은 컴포넌트 트리라는 것을 이해한다는 거다. 각각의 컴포넌트는 몇 개의 inputs, outputs를 가지고 있다. 분명한 기능도 가지고 있다. 컴포넌트는 구성될 수 있다. HeaderComponent에 LoginButtonComponent를 추가할 수 있다. LoginButtonComponent를 재사용하고 싶을 경우에만 이렇게 구성한다. 이번에는 @Component 데코레이터에 대해 알아보자 templateURL 앵귤러에서는 HTML코드를 ts파일 안에 inline으로 작성할 필요가 없다. 대신에 HTML파일을 따로 저장하고 templateURL 프로퍼티를 사용해서 컴포넌트에서 그 HTML을 읽어들일 수 있다. @Component({ selector: 'joke-form', templateUrl: 'joke-form-component.html'})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} 이런 식으로, templateUrl 프로퍼티를 사용해서 외부의 템플릿 파일을 해당 컴포넌트에 지정한다. styles 커스텀 css파일도 styles 프로퍼티를 통해 지정할 수 있다. styles는 스트링 배열을 가질 수 있는데, 백틱을 사용해서 여러줄로도 표현가능하다. @Component({ selector: 'joke-form', template: 'joke-form-component.html', styles: [ ` .card { background-color: gray; } ` ],})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} 뷰 캡슐화(View Encapsulation) 위의 예에서 보면 .card를 통해 배경색을 회색으로 바꿨다. 하지만 첫 번째 컴포넌트에만 적용된 것을 볼 수 있는데, 보통의 경우 css class의 적용범위는 앱 전체이지만, 이 경우 해당 컴포넌트에서만 적용된다. 이를 View Encapsulation 이라고 한다. 앵귤러는 쉐도우 돔이 주 기능인 웹 컴포넌트에서 영감을 얻었는데, 쉐도우 돔을 사용하면 컴포넌트 외부에는 스타일이 적용되지 않고 해당 웹 컴포넌트에서만 스타일이 적용되도록 할 수 있다. 앵귤러는 이러한 기능들을 encapsulation의 프로퍼티로 제공한다. ViewEncapsulation.Native ViewEncapsulation.Emulated ViewEncapsulation.None 기본 값은 ViewEncapsulation.Emulated 이고, 위와 같이 동작한다. ViewEncapsulation.Emulated 브라우저 개발자도구를 사용해서 폼 엘리먼트에 어떤 변화가 있는지 살펴보면, JokeFormComponent에 자동적으로 어트리뷰트가 생성된 것을 볼 수 있다. “_ngcontent-qwe-3” 이라는 어트리뷰트를 추가했다. 다른 컴포넌트에는 해당 어트리뷰트가 추가되지 않았고, JokeFormComponent에만 추가된 것을 알 수 있다. style 탭을 보면, “_ngcontent-qwe-3” 에 스타일이 입혀진 것을 볼 수 있다. _css 셀렉터 .card[ngcontent-qwe-3]는 JokeFormComponent만 타켓팅했다. 왜냐면 _ngcontent-qwe-3 어트리뷰트는 JokeFormComponent에만 있다. ViewEncapsulation.Emulated 모드에서 앵귤러는 자동으로 생성되는 어트리뷰트를 이용함으로써 일반적인 (전역) css 클래스 셀렉터가 특정 컴포넌트에만 적용되도록 변경한다. 이 때문에, 다른 모든 JockComponent가 같은 card 클래스를 사용했음에도 불구하고 JokeFormComponent의 배경색만 회색으로 바뀐다. 컴포넌트에 정의한 모든 스타일은 나머지 앱 부분에 적용되지 않지만 컴포넌트는 여전히 트위터 부트스트랩의 전역스타일을 상속한다. JokeFormComponent는 트위터 부트스트랩의 전역 스타일을 적용시키면서, 컴포넌트 자체의 캡슐화된 스타일도 적용시킨다. ViewEncapsulation.Native 앵귤러에서 쉐도우 돔을 사용하기를 원한다면 ViewEncapsulation.Native을 사용하도록 캡슐화 매개변수를 설정할 수 있다. @Component({ selector: 'joke-form', templateUrl: 'joke-form-component.html', styles: [ ` .card { background-color: gray; } ` ], encapsulation: ViewEncapsulation.Native # &lt;!&gt;})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} 하지만!! 여전히 배경색은 회색이지만, 전역적인 트위터 부트스트랩 스타일이 적용 안된 것을 볼 수 있다!! ViewEncapsulation.Native을 사용하면 우리가 컴포넌트에 설정한 스타일이 다른 부분에 적용되지 않도록 할 수 있다. 독립적인 제 3의 스타일을 정의할 때 사용하는 것이 좋다. 우리가 설정한 스타일이 누출되어 앱의 나머지에 영향을 끼칠 수 있다는 걱정을 안해도 된다. 그러나, ViewEncapsulation.Native을 사용하면 우리가 앱에 설정한 전역 스타일과 분리되기 때문에, 트위터 부트스트랩 스타일을 상속받지 않는다. 그래서 컴포넌트 데코레이터에 필요한 스타일을 전부다 정의해줘야한다. ViewEncapsulation.Native 은 모든 브라우저에서 지원하지 않는, 쉐도우 돔이라고 불리는 기능이 필요하다. ViewEncapsulation.None 만약 스타일을 캡슐화하고 싶지 않다면 ViewEncapsulation.None을 사용하면 된다. card클래스를 사용하는 모든 컴포넌트에 배경색이 회색으로 변경될 거다. 브라우저 개발자도구로 살펴보면, 앵귤러가 HTML의 head 영역에 .card 클래스를 전역스타일로 추가한 것을 볼 수 있다. 아무것도 캡슐화하지 않고, 우리가 컴포넌트에서 정의한 스타일이 흘러나와 앱 전체에 적용될 거다. styleURLs @Component({ selector: 'joke-form', templateUrl: 'joke-form-component.html', styleUrls: [ 'joke-form-component.css' ]})class JokeFormComponent { @Output() jokeCreated = new EventEmitter&lt;Joke&gt;(); createJoke(setup: string, punchline: string) { this.jokeCreated.emit(new Joke(setup, punchline)); }} templateUrl프로퍼티처럼 외부 스타일파일을 사용하고 싶다면 styleUrls 프로퍼티를 사용하면 된다. 배열을 값으로 받는다. Depreciated Properties @Component의 프로퍼티로 directives, pipes, inputs, outputs를 포함하는 글도 볼 수 있는데 이는 베타버전에 앵귤러에 추가됐다가 2.0 최종 릴리즈 버전에서는 빠진 기능이다. shadow DOM 이란? http://d2.naver.com/helloworld/188655","link":"/2018/04/27/angular-component-overview/"},{"title":"Angular에서 ObjectUnsubscribedError 해결방법","text":"ObjectUnsubscribedError 해결방법 어떤 페이지에서 Event나 Observable을 subscribe하고 있다가 페이지를 벗어날 때는 unsubscribe를 해줘야 한다!! 그렇지 않으면 메모리릭이 발생할 수 있다. 보통 ngOnInit()에서 subscribe하고 ngOnDestroy()에서 unsubscribe를 하는데 다른 페이지에서 해당페이지로 돌아오기 위해 백버튼을 누르면 ObjectUnsubscribedError 에러 발생했다. 해결방법 eventEmitter를 바로 ngOnInit()에서 subscribe하는 게 아니라, eventEmitter를 subscribe한 subscriber를 해당 컴포넌트 변수에 담아서 사용하고, 그걸 unsubscribe해야한다. changedMyWalletList: EventEmitter&lt;any&gt; = new EventEmitter&lt;any&gt;(); changedMyWalletList을 구독한다고치면, 나는 그동안 ngOnInit() { this.changedMyWalletList.subscribe(()=&gt; { ~~~~ });}ngOnDestroy() { this.changedMyWalletList.unsubscribe();} 이런 식으로 작성했었는데, subscriberForMyWalletList: any;...ngOnInit() { this.subscriberForMyWalletList = this.changedMyWalletList.subscribe(()=&gt; { ~~~~ });}ngOnDestroy() { if(!this.subscriberForMyWalletList.closed) this.subscriberForMyWalletList.unsubscribe();} 이렇게 사용해야 한다. rxjs의 takeWhile을 사용 import ‘rxjs/add/operator/takeWhile’ 를 하고 this.isSubscribing이 true일 때만 구독을 하도록 하면 된다. isSubscribing: boolean = true;...ngOnInit() { this.moveToSendCard .takeWhile(()=&gt;this.isSubscribing) .subscribe(() =&gt; { ~~~~ });}ngOnDestroy() { this.isSubscribing = false;} 첫번째 방법은 구독해야할 것들마다 일일이 subscriber변수를 할당해줘야 해서 번거로우므로 takeWhile을 사용하는 게 더 간편하겠다!","link":"/2018/04/23/angular-ObjectUnsubscribedError/"},{"title":"앵귤러 아키텍쳐","text":"이번에 앵귤러 프로젝트를 리뉴얼하면서 구조를 어떻게 짜야 다른 개발자가 봐도 이해하기 쉬우면서도 협업하기 좋고, 확장성있게 구성할 수 있을까에 대한 고민을 했다. 여러 레퍼런스들을 검토하던 중 GFT팀에서 앵귤러 프로젝트의 구조를 어떤 식으로 짜는지에 대한 좋은 아티클이 있길래 번역을 하면서 내 식대로 정리를 해보았다. (번역 실력이 부족해 이해하기 힘들 수 있다…아래 첨부한 원본사이트를 참고하세요.) GFT팀의 아키텍쳐 규칙 Project structure - 프로젝트 파일들을 어떤 방식으로 체계화하고, 앵귤러모듈과 의존성 을 정의하고 활용할지 Data flow architecture - 애플리케이션 단에서 데이터가 흐르는 방식을 어떻게 할 것인지 State management - GUI의 상태를 어떻게 관리하고, 그것을 다른 앱에서도 활용할 수 있도록 할 것인지 What is a scalable architecture ? (여기서 GUI라고 표현한 것은 client application을 의미하는 듯? GUI는 일반적으로 그래픽 유저인터페이스의 줄임말이지만…) 일단, GUI 애플리케이션이 확장성이 있다는 말은 어떤 의미일까? GUI는 항상 모든 사용자에 대해 하나의 별도의 응용 프로그램으로 실행되므로 백엔드 응용 프로그램의 일반적인 &quot;높은 사용자 수&quot;문제는 없습니다. 대신 GUI는 아래와 같은 확장성 요소를 신경써야한다. 앱에 로딩되는 데이터 사이즈가 커지고, 프로젝트의 복잡성과 사이즈가 커짐으로 인해 로딩시간이 길어진다는 것…. 외부에서는 잘 보이지 않지만, 프로그래머의 관점에서 앱을 어떻게 확장되는지에 대해서도 신경써야한다. 확장성이 없고 나쁜 아키텍쳐의 앱은 일정시간이 지나면 개발하기 힘들어진다. 복잡성의 증가, 기술적 debt부채, 지저분한 코드… 이런 것들은 프로젝트의 견적, 비용, 솔루션 전체의 질에 직접적으로 영향을 준다. 좋은 아키텍처가 위의 문제들이 발생하는 것을 다 막아주는 것은 아니지만 개발팀에게 그들이 직면할지도 모르는 이슈들을 줄이거나 심지어 제거하는 강력한 툴을 제공한다. 간단히 말해, 잘 디자인된 아키텍처는 크고 작은 프로젝트 어디에서든 잘 동작해야하고 좋은 유저인터페이스를 제공해야한다. 앱의 사이즈나 처리하는 데이터의 양에 상관없이. 그리고, 프로젝트의 품질을 유지하기 위해 개발자들에게 명확하고 쉬운 규칙을 제공해야한다. 마지막으로 그 아키텍쳐는 기본적으로 널리 받아들여지는 디자인패턴을 따라야한다. 앱의 학습곡선을 가능한 작게하기 위해서. 자, 이제 잘 디자인된 앵귤러 애플리케이션의 규칙을 알아보자. Structure of the application 보통 새로운 프로젝트를 세팅할 때 첫번째로 해야하는 것이 애플리케이션의 구조를 정하는 일이다. 많은 방법들이 있지만, 공식적으로 추천되는 방식이 있다. 바로 module-oriented 구조다. 이런 식으로 접근하면, 앱의 모듈들을 파일트리구조에서 분리된 디렉토리로 명확하게 보인다. 각 모듈디렉토리에는 각 모듈과 연관된 모든 파일을 포함하고 있다.(code, styles, templates…etc). 이러한 방법에서 매우 중요한 요소는&quot;모듈의 독립성&quot;이다. 각 모듈은 독립적이고, 다른 모듈에 있는 파일들을 참조하지 않는다. 그래서, 이론적으로 하나의 모듈을 지운다고 해도 앱이 아무런 문제없이 제대로 동작할 수 있다. 사실, 하지만 모듈의 독립성은 실제상황에서는 엄격히 지켜지지는 않는다. 적어도 몇개의 서비스나 컴포넌트는 앱전체에서 공통적으로 사용해야한다. 그러므로 앱기능의 일부분을 &quot;Core&quot;와 &quot;Shared&quot;모듈로 분리한다. 앱의 구조는 아래와 같아진다. 위의 그림을 보면 3가지 메인 모듈이 있다. AppModule - 앱을 시작하고 다른 모듈을 합치는 부트스트랩 모듈 CoreModule - global Service 같은 앱전체에서 공통적으로 사용하는 코어 기능들. 앱의 다른 모듈에 import되지 않는다. SharedModule - 보통 다른 앱에서도 재활용할 수 있는고, 전역적으로 사용되지 않는 컴포넌트와 서비스의 세트로 구성된다. Featured Module기능모듈로 import된다. 나머지 모듈들은 (보통 기능모듈이라고 불림) 분리되어있고 독립적이다. 이러한 구조는 관심사 분리해 줄 뿐만 아니라 확장성있는 앱 아키텍처에 중요한 부분인 lazy loading을 구현하기도 쉽다. Lazy Loading 유저가 겪을 수 있는 가장 눈에 띄는 성능 문제는 바로 앱의 로딩시간이다! 코드량이 증가함에 따라 앱의 번들사이즈도 증가한다. 번들크기가 클수록 브라우저가 코드를 로딩하고 구문을 분석하는데 시간이 많이 걸린다. 다행스럽게도, 로딩시간 이슈를 해결하기 위한 패턴이 있다. 바로 Lazy Loading 이다. 실제로 필요할 때까지 앱의 특정부분의 로딩을 늦출 수 있다. (보통 유저가 앱의 특정부분을 액세스하려고 할 때) 앵귤러는 Lazy Loading 기능이 내장되어있다. Route 정의할 때 올바르게 모듈을 정의하면 lazy loading되는 모듈파일을 가르킬 수 있다. 위에서 설명한 프로젝트 구조를 따랐다면, 앱이 초기화된 후 기능모듈들은 필요할 때 지연로드할 수 있다. 이것은 앱의 초기화시간을 크게 줄여 전반적인 UX를 개선한다. 게다가 앱이 확장될 수록 더 효과를 볼 수 있다. 앱이 커지더라도 지연로드 모듈만 추가되는 식으로 확장된다면 앱의 코어번들과 시작 시간은 계속 똑같을 거다. 만약 기본적으로 제공되는 lazy loading으로도 충분하지 않을 경우, 주어진 앱에서 모듈이 로딩되는 방식을 커스터마이징할 수 있는 Preloading 전략을 사용할 수도 있다. Data flow and state management 아키텍처는 구조, 파일, 모듈에 대한 것만이 아니다. 복잡한 애플리케이션에서 직면하는 가장 큰 문제는 데이터와 상태정보의 흐름을 관리하는 것이다. 그것은 앱에서 매우 빠르게 복잡해지고 자주 수정되는 부분 중 하나다. 그러므로 잘 디자인된 데이터, 상태정보 관리체계를 갖는 것은 모든 아키텍트가 해야할 중요한 체크포인트다. Data flow 앵귤러1과는 달리 앵귤러2부터는 단방향 데이터 flow를 선호한다. 이러한 접근은 양방향 데이터바인딩보다 유지보수하기가 수월하다. 단뱡향 데이터 바인딩이 해당 모듈에 있는 데이터소스가 어떤 것인지, 시스템을 통해 어떤 변화가 생겼는지 더 분명하게 알 수 있다. 앵귤러에서는 데이터의 흐름이 위에서 아래로 전해진다. 부모컴포넌트에서 자식컴포넌트로 전달되고, 컴포넌트에서 템플릿으로 전달된다. 아직까지는 데이터흐름에 기본적인 규칙외에 추가적인 규칙을 설정하는 것이 좋다. smart, dummy컴포넌트 개념을 도입했다. 스마트컴포넌트는 Container라고도 불린다. 이러한 구분은 로직을 포함하고 서비스와 소통하고 사이드이펙트를 발생시키는(서비스 실행, 상태변경 등등) 앱의 파트를 명확히 정의하기 위해서다. 모든 액션은 컨테이너에서만 일어난다. 반대로 stupid컴포넌트는 거의 또는 전혀 로직이 없다. 모든 데이터는 @input 파라미터를 통해 전달된다. 만약 이 컴포넌트가 다른 컴포넌트와 소통하려면 @output을 통해 이벤트를 발생시킨다. 이러한 아키텍처 접근방식은 컨테이너의 수를 가능한한 작게 유지하기 위함이다. 더 많은 컴포넌트가 dummy일 수록 데이터흐름이 간단해지고 작업이 쉬워진다. 어떤 컴포넌트가 컨테이너의 역할을 맡을 지 선택하는 것은 간단한 작업이 아니다. 특정 경우마다 해결해야한다. 그러나, 보통 첫번 째 단계는 주화면요소가 스마트컴포넌트이다. 아래의 화면에서 파란색이 스마트컴포넌트이고, 회색이 더미컴포넌트다. 그 후에, 적은 수의 컨테이너와 단일책임원칙을 잘 유지하는 것이 중요하다. 대시보드 화면은 단일화면에 표시되는 여러스마트 컨테이너의 완벽한 예다. 각 대시보드의 구성들은 스마트컴포넌트이고, 각자의 행동, 데이터, 로직을 담당한다. 아키텍쳐에 대한 이러한 접근은 코드의 가독성과 조직화된 데이터흐름을 위한 것만이 아니다. 더미컴포넌트는 테스트하기 쉽다. 그들의 상태는 전적으로 제공받는 입력에 의해 정해지고, 사이드이펙트가 없다. 적절한 이벤트가 발생되면 컴포넌트 동작결과가 보여진다. 게다가 이러한 행동은 앵귤러의 변경감지프로세스의 성능최적화와잘 일치한다. 더미컴포넌트의 변경감지전략은 &quot;onPush&quot;로 설정된다. onPush는 input 프로퍼티가 수정되었을 때만 컴포넌트의 변경감지 프로세스를 트리거한다. 앵귤러 애플리케이션의 최적화는 쉽고 효율적인 방법인다. State management 애플리케이션에 흐르는 특수한 타입의 데이터가 있다. 바로 State상태다 GUI는 모두 상태에 대한 것이다. 유저가 화면을 통해보는 모든 것은 앱의 상태를 반영한 것이다. 만약 유저가 어떤 동작을 한다면 어떤 데이터는 로딩되거나 다른 이벤트를 발생시키거나 한다. 앱의 로직은 실행된다. 그리고 GUI 상태는 변경된다. 이러한 수정은 보통 렌더링프로세스를 트리거하고 뷰는 업데이트된다. 그래서 유저는 수행된 작업의 결과물을 볼수 있게 된다. 이러한 싸이클이 앱의 실행중에 여러 번 발생한다. 기본적으로 GUI 애플리케이션의 모든 상호작용의 기본구조다. 프로세스 자체는 매우 간단하지만, 복잡한 애플리케이션에서는 상태관리에 관련된 많은 어려움을 겪는다. 일반적인 상호작용이 애플리케이션의 모든 레이어를 거쳐 진행되기 때문에 발생한다. 주어진 상태는 보통 공유된다 그리고 거기에 저장된 정보는 여러 컴포넌트와 심지어 화면에 영향을 미친다. 이미 언급했듯이 상태 관리는 보통 매우 복잡하고 자주 수정되는 것들이다. Single store to rule them all 이러한 이슈를 다루기 위한 방법중 하나는 애플리케이션 레벨에서 단방향데이터흐름을 활용하는 것이다.! 앵귤러커뮤니티는 Redux 아키텍쳐 패턴을 채택했다. Redux의 아이디어는 전체 애프리케이션의 상태가 앱의 현재 상태를 대표하는 객체인 단일 저장소에 저장된다는 것이다. Store는 변경할 수 없고 수정될 수 없다. 상태를 변경할 때마다 새로운 객체를 만들어야한다. 전체 앱의 상태에 대한 하나의 단일 참조지점은 앱의 다른 파트간의 동기화문제를 단순화한다. 다른 모듈이나 컴포넌트에서 주어진 정보를 찾을 필요가 없다. 모든 것은 store에서 사용할 수 있다. Actions and Reducers Store는 직접 액세스하고 수정할 수 없다. Reducers가 수정된 데이터를 가지고 새로운 상태를 만드는 역할을 한다. Reduces는 대개 액션을 인수로 받고 제공된 데이터를 기반으로 새로운 상태를 리턴하는 간단한 function이다. State propagation (상태전이) 앵귤러에서 Redux패턴을 구현하는 방법에는 여러가지가 있다. 가장 유명한 것은 바로 ngrx/store다. 여기서는 ngrx/state의 구현에 대해서는 자세하게 다루지 않고 앱을 통해 state가 어떻게 수정되고 전파되는지 보겠다. 일단 Store에 수정이 적용되면 모든 subscriber에게 변경사항이 전달된다. State가 변경되지 않는 다는 사실 덕분에 세부검사를 진행할 필요가 없다. 만약 상태가 수정되면, subscriber는 새로운 객체를 전달받는다. 이 중앙집중화된 패턴덕분에 모든 상태변화들은 앱의 각 파트에 적절히 전파된다. 반드시 따라야하는 규칙은 Store에 모든 state변경을 변영하는 것이다. 분리된 컴포넌트에 보관되지 않도록. State Service 뷰 레이어와 직접적으로 관련이 없는 다른 로직들과 마찬가지로 전용 service에 Store 작업을 캡슐화하는 것이 좋다. 이러한 서비스는 모듈이나 앱에서 재사용할 수 있다. 컴포넌트는 state의 세부작업에 대해 인식하지 않아도 된다. Combining state management and data flow 설명된 패턴은 서로 결합될 때 정말 강력하다. Redux기반의 state 관리는 앱의 다양한 파트와 불변의 state 사이에 중요한, 믿을만한 동기화를 제공한다. 단방향 데이터 흐름과 스마트컨테이너는 애플리케이션에서 잘 정의된 책임(중요 로직)과 하위에 있는 더미컴포넌트에 전달되는 state 변경을 어떤 전파방버을 제공한다. 공유데이터의 불변성은 앵귤러 변경감지 알고리즘의 최적화 패턴에 적합하다. 이 방식으로 설계된 애플리케이션은 중앙 상태관리 시스템을 통해 상태와 데이터를 동기화하는 캡슐화된 자율 컴포넌트로 구성된다. [참고] https://bulldogjob.pl/articles/539-scalable-angular-application-architecture","link":"/2018/08/09/angular-architecture/"},{"title":"앵귤러에서 커스텀 디렉티브 만들기","text":"Angular5 / Custom Directive 빌트인 디렉티브처럼 사용할 수 있는 커스텀 디렉티브를 만들어보자. https://codecraft.tv/courses/angular/custom-directives/overview/ 참고. 우리는 이미 커스텀 디렉티브를 이미 생성해봤을거다. 왜냐면 컴포넌트도 디렉티브이기 때문! 컴포넌트는 디렉티브의 모든 특징을 가지고 있다. 거기에 view를 가지고 있는 것이 컴포넌트다. that is to say they have a template and some HTML that is injected into the DOM when we use it. 또다른 차이점은 하나의 html 엘리먼트에 하나의 컴포넌트만 가질 수 있는데, 디렉티브의 경우 하나의 엘리먼트에 여러 디렉티브를 연결할 수 있다. 이번 글에서 아래와 같은 것을 알아보자. 1. @Directive 데코레이터를 사용해서 커스텀 디렉티브를 만드는 법 2. 디렉티브가 이벤트를 인지하고 연관된 host element의 프로퍼티변경을 인지하는 법 3. 엘리먼트에 정의된 input을 가져올 수 있도록 디렉티브를 구성하는 방법 [aDirective]={config: 'value'} 와 같이. Creating a custom directive 1. @Directive 데코레이터를 사용해서 기본 디렉티브를 만드는 방법 2. 셀렉터를 사용해서, 어트리뷰트를 기반으로 하는 디렉티브와 엘리먼트를 연결하는 법 3. 디렉티브와 연결된 엘리먼트의 raw DOM 엘리먼트와 상호작용하는 방법 Directive decorator &lt;div class=\"card card-block\" ccCardHover&gt;...&lt;/div&gt; 위와 같이 ccCardHover라는 디렉티브를 card 블록에 붙일 수 있다. [참고] 앵귤러팀은 디렉티브를 어트리뷰트로 사용할 때, 디렉티브의 이름에 접두어를 붙이는 것을 추천했다. 여기서는 'cc’를 접두어로 사용했다. Class에 @Directive라는 데코레이터를 붙이면 디렉티브를 만들 수 있다. import { Directive } from '@angular/core';...@Directive({ selector:\"[ccCardHover]\"})class CardHoverDirective { } Attribute selector 컴포넌트를 만드는 것과 비슷한 데, selector를 []으로 감싼 것이 다르다. 이것을 이해하기 위해서 우리는 selector attribute는 CSS 매칭 규칙을 사용해서 컴포넌트/디렉티브를 HTML 요소와 매치한다는 것을 먼저 이해할 필요가 있다. 특정 element를 매치하려면 CSS에서는 아래와 같이 element의 이름으로 스타일 매칭한다. input { 스타일 설정 }p {…​}….// selector:\".ccCardHover\"// 위와 같은 경우 class로 쓰임&lt;div class=\"card card-block ccCardHover\"&gt;...&lt;/div&gt; 디렉티브를 특정 속성을 가진 엘리먼트에 연관시키고자 한다. CSS에서 이를 수행하려면 속성이름을 []으로 감싸야한다. 그래서 selector는 [ccCardHover]이다. Directive constructor 디렉티브가 생성될 때, 앵귤러는 ElementRef를 주입할 수 있다. ElementRef는 디렉티브가 연결된 DOM 요소에 직접 액세스를 할 수 있게 한다. el.nativeElement.style.backgroundColor = &quot;gray&quot;; 위는 card의 배경색을 회색으로 변경한다. ElementRef는 nativeElement 프로퍼티를 통해 액세스할 수 있는 실제 DOM 엘리먼트의 래퍼다. ElementRef는 지시어가 첨부 된 DOM 요소에 직접 액세스 할 수있게합니다. 카드의 배경색을 회색으로 변경하는 데 사용합시다. ElementRef 자체는 다음과 같이 nativeElement 속성을 통해 액세스 할 수있는 실제 DOM 요소의 래퍼입니다. 그러나 이것은 앱이 항상 브라우저환경에서 동작하는 것을 가정한다. 앵귤러는 노드를 통한 서버사이드, 모바일디바이스 등등 다양한 환경에서 동작하도록 설계되었다. 그래서 앵귤러는 Renderer를 통해 엘리먼트에 어트리뷰트를 세팅함으로써 플랫폼에 독립적인 방법을 제공한다. import { Renderer } from '@angular/core';...class CardHoverDirective { constructor(private el: ElementRef, private renderer: Renderer) { renderer.setElementStyle(el.nativeElement, 'backgroundColor', 'gray'); }} HostListener &amp; HostBinding 1. 디렉티브를 붙인 host element에서 발생된 이벤트에 반응하는 방법 2. 인풋 프로퍼티에 바인딩하여 host element를 조작하는 방법 HostListener 위에서 우리는 ccCardHover라는 디렉티브를 만들었는데, ccCardHover가 있는 엘리먼트의 배경색을 단순히 회색으로 바꾸었다. 하지만 디렉티브의 네이밍처럼 hover가 되었을 때만 배경색을 바꾸기 위해서는 유저가 host element를 hover하는지를 감지해야한다. 앵귤러에서는 @HostListener 데코레이터를 통해 이를 쉽게 할 수 있다. 이것은 인자로 넘긴 이벤트를 받아들이는 function 데코레이터다. Host element에서 해당 이벤트가 발생하면 연결된 functions을 실행한다. @HostListener('mouseover') onHover() { window.alert(\"hover\");} HostBinding Host element에서의 이벤트발생을 캐치할 수 있는 거처럼 host element에 있는 input 프로퍼티에도 @HostBinding을 통해 바인드할 수 있다. 이 디렉티브는 host element의 프로퍼티를 바꿀 수 있다. host element에 적용된 클래스 리스트와 같은… @HostBinding 데코레이터를 사용해 디렉티브는 내부 프로퍼티를 host element 에 있는 input 프로퍼티에 연결할 수 있다. 그래서 내부 프로퍼티가 변경되면 host element에 있는 input 프로퍼티도 변경될 거다. 그러기 위해서는 바인드의 재료로 사용할 수 있는 디렉티브의 프로퍼티가 필요하다. Boolean형의 ishovering이라는 프로퍼티를 선언해서, onmouseover(), onmouseout()에 따라 true, false값을 세팅하자. 이제 host element의 input프로퍼티에 소스프로퍼티를 연결해야하는데, Ishovering에 @HostBinding데코레이터를 붙인다. @HostBinding은 하나의 파라미터를 가지는데, host element에 바인드할 프로퍼티의 이름이다. [class.&lt;class-name&gt;] 프로퍼티를 사용해 ngClass 문법을 이용할 수도 있다. @HostListener와 @HostBinding 데코레이터를 사용하면 호스트 요소의 출력 이벤트를 수신 할 수 있으며 호스트 요소의 입력 속성에도 바인딩 할 수 있습니다. Inputs &amp; Configuration 1. 디렉티브를 구성가능하게 만드는 방법을 알아보자 Configuration 위에서 ccCardHover 디렉티브를 완성했는데 이는 재사용하기 불편하다. 이번에는 ccCardHover를 구성가능하도록 바꿔서 다른 상황에서도 사용할 수 있게끔 해보자. 구성 파라미터 중 하나는 숨기거나 보이길 원하는 element를 선택할 수 있는 query selector다. let part = this.el.nativeElement.querySelector('.card-text'); 첫번째로 해야할 것은 query selector를 디렉티브의 속성으로 이동하는거다. 객체의 속성으로 세팅하면 되겠다. config: any = { querySelector: '.card-text'} 이런 식으로 config에 매개변수를 추가하고 싶다면 config 객체에 프로퍼티를 추가하면 된다. 하드코딩된 selector대신 config객체를 이용해 select할 수 있다. let part = this.el.nativeElement.querySelector(this.config.querySelector); 마지막으로 config 프로퍼티를 디렉티브의 input binding으로 만든다. @Input() config: Object = { querySelector: '.card-text'} 위와 같이 표준 Input 프로퍼티 바인딩을 사용해서 디렉티브를 구성할 수 있다.","link":"/2018/07/23/angular-custom-directive/"},{"title":"Angular에서 특정 div 이외의 영역 클릭이벤트 탐지","text":"Angular에서 특정 div 이외의 영역 클릭이벤트 탐지하는 방법 회사 프로젝트 진행하던 중, 드롭박스 이외의 영역을 클릭했을 때 드롭박스를 닫히도록 하는 기능이 필요했다. select태그를 사용했더라면 신경 쓸 필요가 없는 일이었지만 원활한 스타일적용을 위해 select태그가 아니라 button, li 태그로 드롭박스를 구현한 상태였다. 해당 기능을 제공하는 ng4-click-outside, ng-click-outside 모듈이 앵귤러 5 프로젝트 내에서는 제대로 동작을 하지않아 직접 구현하는 수 밖에 없었다. swap.component.html &lt;div class=\"swap-coin-inp-wrap\" #fromDiv&gt; ... &lt;/div&gt; swap.component.ts constructor( ) { document.addEventListener('click', this.offClickHandler.bind(this)); // bind on doc}offClickHandler(event: any) { if (!this.fromDiv.nativeElement.contains(event.target)) { // check click origin this.fromListShow = false } if (!this.toDiv.nativeElement.contains(event.target)) this.toListShow = false} 이렇게 구현했더니, fromDiv, toDiv 이외의 영역을 클릭했을 때 드롭박스가 제대로 닫히는 것을 확인할 수 있었다.","link":"/2018/06/19/angular-detect-click-outside/"},{"title":"Angular의 Content Projection","text":"Angular5 / Components / Content Projection https://codecraft.tv/courses/angular/components/content-projection/ 의 글을 번역했다. JokeComponent를 재사용하려는 개발자는 어떻게 Joke를 렌더링할 지 구성할 수 있다. Content Projection이 무엇인지, 그리고 우리가 그걸 왜 사용하는지 알아보자 ng-content 태그를 사용해서 컨텐트를 적용시키는 방법을 알아보자 css selector를 사용해서 여러 컨텐트를 적용시키는 방법을 알아보자 이런 상황을 가정해보자 JokeComponent를 재활용하길 원하는데, p태그 대신 h1태그를 사용하고 싶다면 어떻게 해야할까? 지금 현재의 Component로는 그대로 재사용할 수가 없다. 그러나!! content projection이라고 불리는 걸 이용해서 컴포넌트를 커스텀가능하도록 설계할 수 있다. Content Projection &lt;ng-content&gt; &lt;/ng-content&gt; 태그를 템플릿의 HTML 어디에나 추가하면 된다. ng-content 태그내부에 우리가 정의한 컴포넌트가 적용된다. JokeComponent를 수정해보면 &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt;{{ data.setup }}&lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; //이 부분 원래는 {{data.punchline}} 이었던 것을 ng-content로 변경 &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; JokeComponent를 위와 같이 변경한 후, JokeListComponent 를 &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt;&lt;/joke&gt; 에서 &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt; &lt;h1&gt;{{ j.punchline }}&lt;/h1&gt; // j.punchline 을 h1태그로 감싸줬다.&lt;/joke&gt; 으로 변경한다. &lt;h1&gt;&lt;/h1&gt; 는 상위컴포넌트인 JokeListComponent에서 정의되었고, JokeComponent에서 &lt;ng-content&gt;&lt;/ng-content&gt; 태그로 변환된다. 이것을 Content Projection이라고 부른다. 상위컴포넌트에서 현재의 컴포넌트로 컨텐트를 투영하는 것을 의미한다. Content Projection을 사용하면, 컴포넌트를 우리가 바라는대로 정확히 렌더링될 수 있게 할 수 있다. 그러나, Content Projection의 단점은 JokeListComponent가 JokeComponent의 프로퍼티나 메소드를 액세스할 수 없다는 것… 그래서 우리가 투영하는 컨텐트는 JokeComponent의 프로퍼티, 메소드에 바인딩할 수 없고, JokeListComponent에서만 가능하다. (위의 예에서 보면, JokeListComponent에서 j.punchline를 h1 태그로 감싼 것을 볼 수 있다. JokeComponent에서 이렇게 표현했던 것을) Multi-content Projection 만약 여러 컨텐트 영역을 정의하고 싶다면? JokeComponent에서 와 에 둘다 Content Projection을 적용시키고 싶다면?? 이 방법은 단지 Multi-content Projection을 설명하기 위한 용도라고 생각하자. 이 방법보다 더 쉽게 해결할 수 있는 다른 방법들이 있다. JokeListComponent을 아래와 같이 바꾸고 싶다. &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt; &lt;span&gt;{{ j.setup }} ?&lt;/span&gt; &lt;h1&gt;{{ j.punchline }}&lt;/h1&gt;&lt;/joke&gt; 하지만 JokeComponent를 둘 다 &lt;ng-content&gt;&lt;/ng-content&gt; 로 변환하는 식으로 바꿀 수는 없다. &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content&gt;&lt;/ng-content&gt; &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; JokeListComponent의 어떤 컨텐트(j.setup인지, j.punchline인지)가 JokeComponent의 &lt;ng-content&gt;&lt;/ng-content&gt;에 투영되어야 하는지 앵귤러는 알지 못한다. 이를 위해서 select라는 속성을 이용한다. select에 전달된 태그와 일치하는 부분에 매칭된다. &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt; &lt;ng-content select=\"span\"&gt;&lt;/ng-content&gt; // &lt;span&gt;{{ j.setup }} ?&lt;/span&gt;와 매칭된다. &lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content select=\"h1\"&gt;&lt;/ng-content&gt; // &lt;h1&gt;{{ j.punchline }}&lt;/h1&gt; 와 매칭 &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; 약간의 트릭을 써서 클래스 이름과 같은 의미있는 규칙을 정할 수도 있다. &lt;div class=\"card card-block\"&gt; &lt;h4 class=\"card-title\"&gt; &lt;ng-content select=\".setup\"&gt;&lt;/ng-content&gt; &lt;/h4&gt; &lt;p class=\"card-text\" [hidden]=\"data.hide\"&gt; &lt;ng-content select=\".punchline\"&gt;&lt;/ng-content&gt; &lt;/p&gt; &lt;a class=\"btn btn-primary\" (click)=\"data.toggle()\"&gt;Tell Me &lt;/a&gt;&lt;/div&gt; 위를 적용시키기 위해서 상위 컴포넌트인 JokeListComponent는 아래와 같이 변경하면 된다. &lt;joke *ngFor=\"let j of jokes\" [joke]=\"j\"&gt; &lt;span class=\"setup\"&gt;{{ j.setup }} ?&lt;/span&gt; &lt;h1 class=\"punchline\"&gt;{{ j.punchline }}&lt;/h1&gt;&lt;/joke&gt; 정리 어떤 경우에는 컴포넌트의 특성에 따라, 사용자는 뷰, 데이터를 보여주는 방식을 각 케이스별로 커스텀하고 싶어할 수 있다. 모든 케이스를 커버하기 위해서 모든 구성 프로퍼티를 셋팅하는 대신 Content Projection을 사용할 수 있다. 사용자에게 그들이 원하는 대로 컴포넌트의 프레젠테이션을 구성할 수 있도록 권한을 준다.","link":"/2018/05/01/angular-component-overview2/"},{"title":"formGroup 하위에 [(ngModel)] 사용시 발생하는 error","text":"Angular에서 formGroup 하위에 [(ngModel)] 사용 문제 상황 Form태그 안에 있는 select에 [(ngModel)]을 넣으니까 아래와 같은 에러 발생했다. 해결 방법 formGroup 안에서는 ngModel 쓰지말고 formControlName 디렉티브를 사용한다. (ts파일에서 FormBuilder를 통해 group 생성시 formControlName에 있는 값들도 전부 넣어줘야 함.) 굳이 ngModel을 사용하고 싶다면, [ngModelOptions]=&quot;{standalone: true}&quot; 와 함께 사용해야한다. # 1번 방법&lt;select class=\"form-control\" formControlName=\"selectedToken\"(change)=\"selectSendToken()\" [(ngModel)]=\"global.sendInfo.token\"&gt; &lt;option *ngFor=\"let token of global.sendTokenOptions\" [ngValue]=\"token\"&gt; {{token.symbol}}({{token.name}}) &lt;/option&gt;&lt;/select&gt;# 2번 방법&lt;select class=\"form-control\" (change)=\"selectSendToken()\"[(ngModel)]=\"global.sendInfo.token\" [ngModelOptions]=\"{standalone: true}\"&gt;....&lt;/select&gt;","link":"/2018/08/06/angular-formgroup-error/"},{"title":"Angular의 Forms 제대로 사용하기","text":"Angular5 / Forms 그동안 서버 통신할 때 content-type을 json형태로 주로 통신하다보니 앵귤러 forms을 제대로 사용하지 않고 [(ngModel)] 양방향 데이터바인딩을 통해 값을 취득하는 방식을 취했다. 그래서 값의 validation도 직접 구현했는데, Forms을 사용하면 Forms가 제공하는 validation을 이용함으로써 편리하겠다싶어 Forms을 검토해봤다. 앵귤러 마스터북의 Forms예제와 https://codecraft.tv/courses/angular/forms/overview/ 을 참고했다. 성, 이름, 이메일, 비밀번호, 언어선택 박스가 있는 회원가입 폼을 만들어보자. 유저가 필드별 입력값을 제대로 입력했는지 알려주기 위한 visual feedback도 추가할거다. 템플릿 기반 폼이 더 단순하지만, 실제적으로 자동으로 생성된 모델 기반 폼으로 동작한다. 그래서 먼저 모델 기반 폼을 먼저 설명하고 템플릿 기반 폼을 설명하겠다. 마지막으로 RxJS를 이용해reactive model 기반 폼을 구현하는 메소드를 보여주겠다. Model Driven Forms 모델기반으로 폼을 구현하는 것은 컴포넌트 파일에 FormGroup, FormControl의 인스턴스 객체를 변수로 선언해 html에서 해당 변수를 참조함으로써 form을 구현하는 방식을 의미한다. &lt;!-- signup.component.ts --&gt; myForm: FormGroup; firstName: FormControl; lastName: FormControl; email: FormControl; password: FormControl; language: FormControl; ngOnInit() { this.myform = new FormGroup({ name: new FormGroup({ firstName: new FormControl('', Validators.required), lastName: new FormControl('', Validators.required), }), email: new FormControl('', [ Validators.required, Validators.pattern(\"[^ @]*@[^ @]*\") ]), password: new FormControl('', [ Validators.required, Validators.minLength(8) ]), language: new FormControl() }); }&lt;!-- signup.component.html --&gt; &lt;form [formGroup]=\"myForm\" class=\"ui form error\" (ngSubmit)=\"onSubmit(myForm.value)\"&gt; ... &lt;input type=\"password\" id=\"password\" [formControl]=\"myForm.controls.password\"&gt; ... &lt;/form&gt; Model Driven Form Validation 1. Form model을 통해 유효성 체크를 어떻게 추가할까 2. 유효성체크 결과를 유저에게 visual feedback을 어떻게줄까 3. 유효성 에러메시지 어떻게 추가할까 validators 를 적용하려면 템플릿에 어트리뷰트를 추가하거나 모델에 FormControl를 정의하면 된다. 우리는 여기서 2번째 방법으로 적용시켜보겠다. 앵귤러는 이미 built-in된 validators가 있다( 예를 들면 required, minLength, maxlength, pattern) FormControl 생성자의 첫번째 파라미터는 컨트롤의 초기값이고 그 값은 빈 값으로 둘 수 있다. 두번째 파라미터는 single validator이거나 multi validators를 적용시키고 싶으면 validators의 리스트일 수도 있다. ngOnInit() { this.myform = new FormGroup({ name: new FormGroup({ firstName: new FormControl('', Validators.required), //싱글 validators lastName: new FormControl('', Validators.required), }), email: new FormControl('', [ // validators 여러개 Validators.required, Validators.pattern(\"[^ @]*@[^ @]*\") ]), password: new FormControl('', [ Validators.required, Validators.minLength(8) ]), language: new FormControl() });} 1.Form control state 폼 컨트롤 객체는 컨트롤자체의 상태를 캡슐화했다. (현재 유효한지, 터치된 적이 있는지에 대한) &lt;pre&gt;Dirty? {{ myform.controls.email.dirty }}&lt;/pre&gt;&lt;pre&gt;Pristine? {{ myform.controls.email.pristine }}&lt;/pre&gt; Dirty가 true이면 유저가 컨트롤의 값을 변경한 적이 있다는 의미. Pristine이 true이면 유저가 값을 변경한 적이 없다는 의미. &lt;pre&gt;Touched? {{ myform.controls.email.touched }}&lt;/pre&gt; Touched는 유저가 폼을 터치한 적이 있을 때… Touched, dirty의 차이점은 touched는 실제로 값을 변경안해도 touched가 true &lt;pre&gt;Valid? {{ myform.controls.email.valid }}&lt;/pre&gt; 모든 validator를 통과하면 valid는 true 2.Validation Styling [ngClass]=\"{'error' : myForm.controls.email.invalid &amp;&amp; myForm.controls.email.dirty,'success' : myForm.controls.email.valid &amp;&amp; myForm.controls.email.dirty}\" Dirty가 true인지 체크하는 이유는 아무런 입력을 받지 않았을 때, 최초로딩에서 validation style이 적용되는 것을 막기 위해. 3.Writing shorter validation expressions 위의 방법은 FormGroup이 중첩되었을 경우, 사용하기 복잡할 수 도 있다. &lt;div class=\"form-group\"[ngClass]=\"{'has-danger': myform.controls.name.controls.firstName.invalid &amp;&amp; myform.controls.name.controls.firstName.dirty,'has-success': myform.controls.name.controls.firstName.valid &amp;&amp; myform.controls.name.controls.firstName.dirty}\"&gt; 아래와 같이 표현을 짧게 하기 위해서 Ts파일에 로컬프로퍼티를 생성해서 참조할 수도 있다. createFormControls() { this.firstName = new FormControl('', Validators.required); this.lastName = new FormControl('', Validators.required); this.email = new FormControl('', [ Validators.required, Validators.pattern(\"[^ @]*@[^ @]*\") ]); this.password = new FormControl('', [ Validators.required, Validators.minLength(8) ]); this.language = new FormControl('', Validators.required); }createForm() { this.myform = new FormGroup({ name: new FormGroup({ firstName: this.firstName, lastName: this.lastName, }), email: this.email, password: this.password, language: this.language }); }&lt;div class=\"form-group\" [ngClass]=\"{ 'has-danger': firstName.invalid &amp;&amp; firstName.dirty, 'has-success': firstName.valid &amp;&amp; firstName.dirty }\"&gt; 4.Validation messages 폼을 스타일링하는 것과 마찬가지로 유저가 유효하지 않은 값을 넣었을 때 hint를 주면 어떻게 유효한 값을 입력할 지 알 수 있게 된다. Validator가 여러개일 때, 각각에 맞는 에러메시지를 보여주려면 어떻게 해야할까? formControl의 errors 프로퍼티를 체크해서 처리할 수 있다. 만약 errors 객체의 required 키가 있는 경우, 이것은 유저가 필수입력값을 입력하지 않았다는 의미이다. &lt;div class=\"form-control-feedback\" *ngIf=\"password.errors &amp;&amp; (password.dirty || password.touched)\"&gt; &lt;p *ngIf=\"password.errors.required\"&gt;Password is required&lt;/p&gt; &lt;p *ngIf=\"password.errors.minlength\"&gt;Password must be 8 characters long&lt;/p&gt;&lt;/div&gt; Submitting &amp; Resetting Submit을 클릭했을 때 컴포넌트에 있는 함수를 어떻게 콜할 것인가? 그리고, 어떻게 원래상태로 되돌릴 것인가? 1. Submitting Form태그 안에 Type=submit인 button 이 필요하다. 일반적인 HTML5는 submit을 클릭하면 바로 해당 폼을 POST형식으로 현재 url에 전달한다. 그러나 POST형식으로 전달하는 거 말고 함수를 호출할 수도 있다. Form태그에 추가된 ngSubmit 디렉티브를 통해 할 수 있다. (ngSubmit)=&quot;onSubmit(myForm.value)&quot; 현재 폼의 값을 함수로 전달할 수 있다. 2. Resetting 모델기반 폼에서 폼을 리셋하기위해서 myForm.reset()메소드만 호출하면 된다. 인풋 값이 초기값으로 리셋되고, valid, touched or dirty 프로퍼티도 초기화된다. Reactive Model Form 1. formControl 디렉티브를 어떻게 사용하는가? 2. FormGroup / FormControl observable을 어떻게 구독할까? 3. RxJS의 debounceTime, distinctUntilChanged를 어떻게 사용하는가? FormControls와 FormGroups는 valuesChanged 라는 observable을 노출한다. valuesChanged를 구독함으로써 실시간으로 폼의 값이 바뀌는 걸 캐치할 수 있다. ngOnInit() { this.searchField = new FormControl(); this.searchField.valueChanges .subscribe(term =&gt; { this.searches.push(term); });} ngOnInit() { this.searchField = new FormControl(); this.searchField.valueChanges .debounceTime(400) // 400밀리초의 디바운스 타임을 준다. .distinctUntilChanged() //값이 이전값과 달라졌을 때만 구독한다. .subscribe(term =&gt; { this.searches.push(term); });} Summary 폼을 제출했을 때 함수를 호출한 다음 폼액션을 처리하는 방식으로 모델기반폼을 처리할 수 있다. 그러나 앵귤러를 이용하면 observable을 구독함으로써 폼을 처리할 수도 있다. 리액티브폼과 몇가지 RxJS 오퍼레이터를 사용하면 단 몇줄의 코드로 강력한 기능을 구현할 수 있다. 실시간으로 유저가 입력하는 폼을 처리해야할 때 Reactive Form이 더 유용하다. 유저가 버튼을 클릭했을 때만 폼을 처리해야하면 Model driven Form이 더 유용하다. 두가지 방법이 상호배타적인 것이 아니므로 적절히 잘 섞어서 사용하면 되겠다. Template Driven Forms 1. Template driven form과 model driven form의 차이점을 알자. 2. 템플릿 input 컨트롤을 컴포넌트의 프로퍼티로 연결하기 위해 ngModel 디렉티브를 어떻게 사용할 것인가. 3. Template driven form에서 폼 유효성체크를 어떻게 구현할 것인가. 4. Template driven form에서 submit, reset을 어떻게 할 것인가. 템플릿 기반이나 모델기반이나 모델을 사용한다는 걸 이해하자. 템플릿기반 폼은 템플릿에 디렉티브를 이용해 FormGroups, FormControls로 모델을 생성한다. 1.Directives 템플릿 기반 폼을 만들 때 필요한 디렉티브는 FormsModule에 있다. ReactiveFormsModule이 아니라. FormsModule에서 가져온 디렉티브 중 하나는 ngForm이다. This instance of ngForm is hidden but we can expose it with a local template reference variable attached to the form element, like so: &lt;form #f=&quot;ngForm&quot;&gt; ... &lt;/form&gt; 변수 f는 템플릿에서 지역변수로 쓸 수 있는데 f는 ngForm 디렉티브의 객체를 가르킨다. &lt;pre&gt;{{f.value | json}}&lt;/pre&gt; 을 찍어보면 {} 빈 객체가 찍히는데 ngForm 디렉티브는 자동으로 form태그안에 있는 모든 컨트롤을 감지하지 않기 때문이다. 그래서 최상위 FormGroup이 만들어졌지만 비어있다. 그래서 명시적으로 ngForm디렉티브를 이용해 컨트롤을 등록을 해줘야하는데, ngForm디렉티브는 FormControl 객체를 만들어내고 FormGroup에 매칭시킨다. To do that we need to do two things to each template form control: 1. Add the NgModel directive 2. Add the name attribute. &lt;input name=&quot;foo&quot; ngModel&gt; 모델기반 폼에서는 아래와 같이 해줬다. let model = new FormGroup({ \"foo\": new FormControl()}); 2.Two way data binding The [( )] syntax is a combination of the syntax for input property binding [] and output event binding () The long form of writing the above would be: &lt;input ... [ngModel]=&quot;email&quot; (ngModelChange)=&quot;email = $event&quot; &gt; But the [()] syntax is shorter and clearly shows we are implementing two way data binding on this input control. 3.Domain model 앵귤러에서 일반적으로 간단한 스트링이나 객체에 데이터바인딩을 하지 않지만 클래스를 통해 정의한 도메인 모델을 통해서는 데이터바인딩을 한다. class Signup { constructor(public firstName: string = '', public lastName: string = '', public email: string = '', public password: string = '', public language: string = '') { }}model: Signup = new Signup(); 4.Validation 모델기반폼에서는 validator를 ts파일에다 정의했다. 템플릿 기반폼에서는 디렉티브를 통해 validate를 한다. HTML5에 빌트인되어 있는 디렉티브이다. &lt;div class=\"field\"&gt; &lt;label&gt;Password&lt;/label&gt; &lt;input type=\"password\" name=\"password\" #password=\"ngModel\" [(ngModel)]=\"model.password\" required minlength=\"8\"&gt; &lt;div class=\"form-control-feedback\" *ngIf=\"password.errors &amp;&amp; (password.dirty || password.touched)\"&gt; &lt;p *ngIf=\"password.errors.required\"&gt;Password is required&lt;/p&gt; &lt;p *ngIf=\"password.errors.minlength\"&gt;Password must be at least 8 characters long&lt;/p&gt;&lt;/div&gt; 5.Resetting the form 모델기반폼에서는 reset()을 사용할 수 있지만, 템플릿기반폼에서는 f.form을 컴포넌트에서 참조할 수 없다 BUT!!! ngForm의 객체를 컴포넌트에서 ViewChild 데코레이터를 이용해 참조할 수 있다!! ViewChild 데코레이터는 템플릿에 있는 변수를 컴포넌트에서 참조할 수 있도록 도와준다. @ViewChild('f') form: any;this.form.reset()","link":"/2018/06/28/angular-forms/"},{"title":"Angular의 injector tree 구조 파악하기","text":"Angular5 / Injector Tree 앵귤러에서 인젝터 트리의 구조가 어떻게 구성되었는지 살펴보았다. (위의 그림을 보면서 아래의 설명을 이해해보자!!) 앵귤러는 컴포넌트 트리의 구조와 동일한 인젝터 트리를 가진다. 위의 그림에서 @NgModule의 provider 배열을 해 설정된 Root Injector가 하나 있다. 루트 인젝터에는 LoginService가 등록되어 있다. 루트 인젝터 아래에는 root Component가 있다. 이 컴포넌트에는 provider배열이 없고 루트 인젝터를 사용한다. 하위 인젝터가 2개 있는데, 각각의 ChatWindow Component를 위한 인젝터다. 각 컴포넌트는 해당 컴포넌트에서 생성한 CharService를 가지고 있다. 세번째 하위 컴포넌트로 Logout/Login Component가 있고, 여기에는 인젝터가 없다. 그리고, 인젝터가 없는 몇몇 개의 하위 컴포넌트가 있다. 각각의 ChatWindow Component에는 하위 컴포넌트로 ChatFeed, ChatInput Component가 있고, Logout/Login Component의 하위 컴포넌트로는 Login Widget Component, Logout Widget Component이 있다. 인젝터 트리는 모든 컴포넌트에 대해서 새로운 인젝터를 생성하지는 않는다. @Component의 메타데이터로 Providers 배열이 있는 컴포넌트에만 새로운 인젝터를 생성한다. Providers배열이 없으면 그 상위컴포넌트의 인젝터에서 찾는다. 만약 상위 컴포넌트에도 없으면 Root Injector에 도달할 때까지 계속 상위 인젝터를 찾는다. 위 그림에서 실선은 Component Tree를 나타내고, 점선은 Injector Tree를 나타내는 데, 두 개의 트리구조가 동일함을 알 수 있다. 경고: provider 배열에 주의하자. 하위 Component가 상위 Component에서도 요청된 의존성을 포함하는 provider 배열로 메타데이터로 가질 경우, 하위 Component가 가지는 의존성은 상위 Component의 의존성을 가린다. 만약 Chat Window Component에서 provider 배열로 LoginService를 새롭게 선언했다면, 이 LoginService는 root injector에 등록된 LoginService와는 다른 인스턴스다.","link":"/2018/05/04/angular-injector-tree/"},{"title":"이진탐색(binary-search)","text":"순차적으로 나열된 배열에서 특정 원소를 빨리 찾는 법!! 만약 1 ~ 100 사이의 숫자 가운데 87을 찾는다고 한다면 1부터 순서대로 추측하면 87번 추측을 해야 우리가 찾고자하는 숫자 87에 도달할 수 있다. (만약 찾고자하는 수가 99라면 99번이나 추측을 해야하겠지요…) 이런 방법을 단순 검색(Simple Search)… 띠리한 방법… 좀 더 나은 방법을 찾아보면! 중간부터 시작하는 것! 1 ~ 100 가운데 87을 찾기위해 중간 숫자 50부터 추측을 해보면, &quot;50이 너무 작다&quot;는 결과를 통해 1~50을 날려버릴 수가 있다. 남은 51 ~ 100의 숫자 중 중간 숫자 75로 추측해보면 &quot;75가 너무 작다&quot; 76 ~ 100의 가운데 숫자 87을 추측해보면 불과 3번만에 우리가 찾는 숫자 &quot;87&quot;을 찾아낼 수 있다!!! 이런 식의 방법을 이진 탐색(Binary Search)이라고 한다. 만약 n개의 원소를 가진 리스트에서 이진탐색을 사용하면 최대 log2의 n번 만에 답을 찾을 수 있다. 기존의 파이썬으로 된 예제를 자바스크립트로 바꿔봤다. binary_search = (list, item) =&gt; { let low = 0; let high = list.length - 1; let count = 1;s while (low &lt;= high) { let mid = Math.floor((low + high) / 2); let guess = list[mid]; if (guess == item) { console.log(`${item}을 ${count}번만에 찾았다!! my_list[${mid}]에 위치해있다.`); return mid; } else if (guess &gt; item) { high = mid - 1; count++; } else { low = mid + 1; count++; } } console.log(`${item}은 my_list에 존재하지 않는다!!`); return;};my_list = [];for(let i = 0; i&lt; 100; i++) { my_list.push(2*i-1);}binary_search(my_list, 117);binary_search(my_list, -3); 결과값 117을 6번만에 찾았다!! my_list[59]에 위치해있다.-3은 my_list에 존재하지 않는다!!","link":"/2018/04/07/binary-search/"},{"title":"빅오 표기법(Big-O Notation)","text":"알고리즘이 얼마나 빠른지 표시하는 방법. 알고리즘의 속도는 시간이 아니라 연산의 횟수가 어떻게 증가하는지로 측정한다. 빅오 표기법을 사용하면 수행해야 할 일이 많아질 때, 알고리즘에 걸리는 시간이 어떤 식으로 증가하는지를 알 수가 있다. 전화번호부에서 사람을 찾기 위해 단순탐색을 사용한다고 하면 단순 탐색의 실행시간 : O(n) Adit이라는 이름을 전화번호부의 맨 앞에서 찾았다고 하더라도 이 경우의 실행시간은 O(n)이다. 빅오 표기법은 최악의 경우에 대한 것! 즉, 단순 탐색이 절대로 O(n)의 시간보다 느려지지 않는다는 일종의 보장! 이진 탐색의 실행시간 : O(log n) O(log n)은 O(n)보다 빠르다. 리스트의 원소 개수가 증가하면 상대적으로 더 빨라진다!! 많이 사용하는 빅오 실행시간의 예 O(1) – 상수 시간 : 알고리즘이 문제를 해결하는데 오직 한 단계만 거칩니다. ex) 해시테이블, 해시함수 O(log n) – 로그 시간 : 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어듭니다. ex) 이진탐색 O(n) – 직선적 시간 : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가집니다. ex) 단순탐색 O(n^2) – 2차 시간 : 문제를 해결하기 위한 단계의 수는 입력값 n의 제곱입니다. ex) 선택정렬 O(C^n) – 지수 시간 : 문제를 해결하기 위한 단계의 수는 주어진 상수값 C 의 n 제곱입니다. (상당히 큰수가 됩니다) O(n!) : 문제를 해결하기 위해 n!번의 연산이 필요하다. ex)외판원 문제 위의 그래프를 통해 데이터의 수가 증가함에 따라 수행시간이 어떤 비율로 증가하는지 한 눈에 비교해 볼 수 있다. 연습문제 1-1. 128개의 이름이 정렬되어 있는 리스트. 이진 탐색으로 이름을 찾을 때 필요한 최대 추측 횟수는? =&gt; log 128 = 7 번 1-2. 만약 리스트의 크기가 두 배가 된다면 최대 추측 횟수는 ? =&gt; log 256 = 8 번! 1-3. 어떤 사람의 이름을 알고 있다. 전화번호부에서 이 사람의 전화번호를 찾고 싶다. =&gt; 이름을 찾은 후에, 그 이름에 해당하는 전화번호를 찾아야하니까 O(n+1) 이거는 결국 O(n)과 실행시간이 같겠지...?? ==&gt;해답 엇... 해답을 보니 O(log n)이네. 이름을 알고 있다는 것은 이진탐색을 할 수 있다는 의미니까! O(log n)이구나... 1-4. 전화번호가 있다. 전호번호부에서 이 전화번호를 가진 사람의 이름을 찾고 싶다.(힌트: 전화번호부를 모두 찾아야 할 수도 있다) =&gt; O(n) 1-5. 전화번호부에 있는 모든 사람의 전화번호를 알고 싶다. =&gt; O(n) 1-6. 알파벳 A로 시작하는 사람들의 전화번호를 알고 싶다… =&gt; O(n) =&gt; 알파벳 A로 시작하는 사람을 찾는 것 역시... 전화번호부 전체를 다 뒤져봐야할 수도 있으니까....? ==&gt; 해답의 좀 더 정확한 해설을 보면 알파벳 26자중 하나의 알파벳만 탐색하면 되니까 O(n/26) 이라고 생각하기 쉬우나, 실행시간에 대해 상수는 무시한다는 규칙!!! O(n/26) -&gt; O(n)으로 표기해야함.","link":"/2018/04/07/big-o/"},{"title":"앵귤러와 ngrx 버전 미스 매치","text":"Angular에서 ngrx도입 시 주의해야할 점 앵귤러 버전5 프로젝트에서 ngrx 버전6을 의존했더니 아래와 같은 에러를 냈다. angular ngrx store error Cannot read property 'schedule' of undefined 해결방법 구글링을 해보니 npm WARN @ngrx/store@6.0.1 requires a peer of @angular/core@^6.0.0 but none is installed. You must install peer dependencies yourself. angular@6 에서만 @ngrx/store@6 을 사용할 수 있다. npm install @ngrx/store@5.2.0 ngrx버전을 5로 낮추니 문제가 해결됐다.","link":"/2018/08/04/angular-ngrx-error/"},{"title":"너비 우선 탐색(breadth-first-search)","text":"너비 우선 탐색을 사용하면 두 항목간의 최단 경로를 찾을 수 있다. 체커 게임에서 가장 적은 수로 승리할 수 있는 방법을 계산하는 인공지능 맞춤법 검사기(실제 단어에서 가장 적은 개수의 글자를 고쳐서 올바른 단어를 만드는 방법을 찾는다.) 여러분의 네트워크에서 가장 가까운 의사 선생님을 찾기 그래프가 뭘까? X축과 Y축을 가지고 있는 그래프가 맨 먼저 떠올랐다. 하지만 여기서 말하는 그래프가 그 그래프는 아니다! 그래프란 항목들이 서로 어떻게 연결되어 있는지를 모형화한 것!! 그래프는 정점과 간선으로 이루어져 있다. 정점은 여러 개의 다른 정점과 이어질 수가 있고, 바로 이어진 정점을 이웃neighbor라고 한다. 위의 그림에서 보면, 알레스는 라마에게 돈을 빚지고 있다. 라마와 아디트, 라마와 톰, 톰과 아디트는 서로 이웃이고 알렉스와 아디트는 이웃이 아니다. 너비 우선 탐색 너비 우선 탐색은 그래프를 대상으로 하는 다른 종류의 탐색 알고리즘이다. 이 알고리즘을 통해 다음 두 가지 질문에 대답할 수 있다. 정점 A에서 정점 B로 가는 경로가 존재하는가? 정점 A에서 정점 B로 가는 최단 경로는 무엇인가? 예를 들어서, 내 페이스북 친구 중에서 망고 판매상을 찾는 방법은? 먼저 내 친구들 중 망고판매상이 있는지 찾아본다. 내 친구들 중에 없으면 내 친구의 친구목록을 뒤져서 찾는다. 내 친구의 친구 중에도 없으면 내 친구의 친구의 친구목록을 뒤진다. 이런 식으로 망고 판매상을 찾을 때까지 네트워크를 탐색하면 된다! 이러한 알고리즘을 너비 우선 탐색 최단 경로 만약 망고 판매상을 하는 나와 가장 가까운 친구를 찾으려면? 위의 탐색 순서를 잘 지키면 되겠지!!! 내 친구 중에서 망고 판매상이 있으면 굳이 내 친구의 친구목록을 뒤질 필요가 없다. 큐 망고 판매상을 찾기 위한 리스트는 &quot;큐&quot;라는 자료구조에 담기는데, &quot;큐&quot;는 마치 버스 정류장 대기줄과 같다. 먼저 줄 선 사람이 먼저 버스를 타는 것과 마찬가지로, 망고 판매상 탐색리스트에 먼저 들어온 내 친구목록을 먼저 탐색하고 그 다음 내 친구의 친구목록을 탐색하게 된다. 큐는 선입선출(먼저 들어온 것이 먼저 나가고) 스택은 후입선출(나중에 들어온 것이 먼저 나간다) 그래프의 구현 코드로 그래프를 구현해보자. &quot; 여러분 -&gt; 밥&quot; 과 같은 관계를 어떻게 표현할까? 우리가 앞에서 공부했던 관계를 표시하는 자료구조, 해시테이블을 이용하면 되겠다! graph = {};graph[\"you\"] = [\"alice\", \"bob\", \"claire\"]; graph[&quot;you&quot;]라고 하면 여러분의 모든 이웃을 알 수 있다. 위의 그래프를 코드로 표현해보면, graph = {};graph[\"you\"] = [\"alice\", \"bob\", \"claire\"];graph[\"bob\"] = [\"anuji\", \"peggy\"];graph[\"claire\"] = [\"thom\", \"jonny\"];graph[\"alice\"] = [\"peggy\"];graph[\"peggy\"] = [];graph[\"jonny\"] = [];graph[\"anuji\"] = [];graph[\"thom\"] = []; 돌발퀴즈! 키/값 쌍들을 넣을 때 순서는 중요할까? 중요하지 않다. 해시 테이블은 순서를 가지지 않는다!! 위의 그래프에서 보면, 아누지, 페기, 조니, 톰은 이웃이 없다. 이들을 향하는 화살표는 있어도 이들에게서 다른 이로 나가는 화살표는 없다. 이처럼 방향을 가지는 그래프를 방향 그래프directed graph, 방향을 가지지 않는 것을 무방향 그래프undirected graph. 만약, 페기 -&gt; 앨리스, 앨리스 -&gt; 페기 이면 앨리스 - 페기 라고 표현할 수 있고 페기와 앨리스는 서로 이웃이라고 말한다. 알고리즘의 구현 정리해보면 아래의 그림과 같다. // concat() : 배열합치기// shift() : 배열의 앞부분에서 데이터를 삭제person_is_seller = (name) =&gt; name[name.length - 1] == \"m\" //사람 이름이 m으로 끝나면 망고판매상이다graph = {};graph[\"you\"] = [\"alice\", \"bob\", \"claire\"];graph[\"bob\"] = [\"anuji\", \"peggy\"];graph[\"claire\"] = [\"thom\", \"jonny\"];graph[\"alice\"] = [\"peggy\"];graph[\"peggy\"] = [];graph[\"jonny\"] = [];graph[\"anuji\"] = [];graph[\"thom\"] = [];search_queue = [];searched = [];search = (name) =&gt; { search_queue = graph[name]; while(search_queue.length &gt; 0) { person = search_queue[0]; search_queue.shift(); if(searched.indexOf(person) &lt; 0) { // 이전에 확인하지 않은 사람만 확인 if (person_is_seller(person)) { console.log(`${person} 망고상이다.`) return true; } else { search_queue = search_queue.concat(graph[person]) searched.push(person); // 확인한 사람 추가. } console.log(\"search_queue, searched\",search_queue, searched) } } return false;}search(\"you\");//결과search_queue, searched [ 'bob', 'claire', 'peggy' ] [ 'alice' ]search_queue, searched [ 'claire', 'peggy', 'anuji', 'peggy' ] [ 'alice', 'bob' ]search_queue, searched [ 'peggy', 'anuji', 'peggy', 'thom', 'jonny' ] [ 'alice', 'bob', 'claire' ]search_queue, searched [ 'anuji', 'peggy', 'thom', 'jonny' ] [ 'alice', 'bob', 'claire', 'peggy' ]search_queue, searched [ 'peggy', 'thom', 'jonny' ] [ 'alice', 'bob', 'claire', 'peggy', 'anuji' ]thom 망고상이다. 실행시간 망고 판매상을 찾기 위해서 네트워크 전체를 탐색한다는 것은 모든 정점을 따라 움직인다는 뜻! 실행시간은 최소한 O(간선의 개수)! 그리고, 탐색할 사람을 저장하는 큐도 있다. 여기에는 상수시간, O(1)시간이 걸린다. 이걸 모든 사람에게 적용하면 O(사람의 수)! 따라서 너비 우선 탐색은 O(사람의 수 + 간선의 수), O(V+E)라고 표현한다. 6장에서 배운 내용 1. 너비 우선 탐색은 A에서 B로 가는 경로가 있는지 알려준다. 2. 만약 경로가 존재한다면 최단 경로도 찾아준다. 3. 만약 X까지의 최단 경로를 찾는 문제가 있다면 그 문제를 그래프로 모형화해보자. 그리고 너비 우선 탐색으로 문제를 풀자. 4. 방향 그래프는 화살표를 가지며, 화살표 방향으로 관계를 가진다. 5. 무방향 그래프는 화살표가 없고, 둘 간의 상호관계를 나타낸다. 6. 큐는 선입선출 7. 스택은 후입선출 8. 탐색 목록에 추가된 순서대로 사람을 확인해야 한다. 그래서 탐색목록은 큐가 되어야 한다. 그렇지 않으면 최단 경로는 구할 수 없다. 9. 누군가를 확인한 다음에는 두 번 다시 확인하지 않도록 해야한다. 그렇지 않으면 무한반복이 될 수도 있다.","link":"/2018/05/02/breadth-first-search/"},{"title":"constructor와 ngOnInit 차이점","text":"constructor와 ngOnInit 차이점 앵귤러의 lifecycle의 ngOnInit()과 constructor의 차이점을 정리해보려 한다. constructor를 사용할 수 있는데도 ngOnInit이 필요한 이유가 뭘까? https://toddmotto.com/angular-constructor-ngoninit-lifecycle-hook 의 글을 참고했다. constructor와 ngOnInit은 뭐가 다른걸까? ES6 클래스(앵귤러에서는 TypeScript)에서 constructor 메소드는 클래스 자체의 기능이다. 반면 ngOnInit()은 앵귤러의 기능. constructor가 호출될 때는 앵귤러의 컨트롤을 벗어난다. 이 의미는, 앵귤러가 컴포넌트 초기화를 마쳤는지 알기에는 적당한 위치가 아니다. 컴포넌트를 살펴보면 import { Component } from '@angular/core';@Component({})class ExampleComponent { // this is called by the JavaScript engine // rather than Angular constructor() { console.log('Constructor initialised'); }}// internally calls the constructornew ExampleComponent(); 여기서 가장 중요한 점은! 앵귤러가 아니라 JavaScript 엔진이 constructor를 호출한다는 것! 이 때문에 ngOnInit이라는 lifecycle이 생겼다. 이 lifehook을 추가하면서, 컴포넌트의 초기화가 끝난 후 앵귤러는 그 메소드를 실행시킨다. ngOnInit()이라는 네이밍에서 알 수 있듯이 이 메소드는 컴포넌트의 lifecycle 중 하나다. import { Component, OnInit } from '@angular/core';@Component({})class ExampleComponent implements OnInit { constructor() {} // called on demand by Angular ngOnInit() { console.log('ngOnInit fired'); }}const instance = new ExampleComponent();// Angular calls this when necessaryinstance.ngOnInit(); Constructor의 용도 constructor는 컴포넌트에 의존성 주입을 하기에 알맞은 위치다. constructor는 자바스크립트 엔진이 초기화하는데, 필요한 의존성을 어떤 프로퍼티에 매핑할지 앵귤러에 알려준다. import { Component, ElementRef } from '@angular/core';import { Router } from '@angular/router';@Component({})class ExampleComponent { constructor( private router: Router, private el: ElementRef ) {}} 위의 코드에서 Router는 this.router에 바인드되고, 컴포넌트 클래스 안에서 this.router로 접근가능하다. ngOnInit ngOnInit은 앵귤러가 컴포넌트를 초기화를 완료했다는 것을 우리에게 알려주기 위해서 만들어졌다. 이 단계는 컴포넌트에서 바인드한 프로퍼티에 첫 변경 감지가 되는 범위까지 포함되어 있다. @Input() 데코레이터를 사용하는 경우를 예로 들 수 있다 이 때문에 @Input()프로퍼티는 ngOnInit에서 읽어들일 수 있고, constructor에서는 undefined가 된다. import { Component, ElementRef, Input, OnInit } from '@angular/core';import { Router } from '@angular/router';@Component({})class ExampleComponent implements OnInit { @Input() person: Person; constructor( private router: Router, private el: ElementRef ) { // undefined console.log(this.person); } ngOnInit() { this.el.nativeElement.style.display = 'none'; // { name: 'Todd Motto', location: 'England, UK' } console.log(this.person); }} ngOnInit()는 바인딩한 값을 읽어들이는 것을 보장하는 lifecycle hook이다. contructor에서는 의존성 주입에 대한 작업을 하고, 변수 초기화 작업은 ngOnInit()에서 하도록하쟈~! [참고] 변경감지(Change Detection)가 일어나는 순서 1. update bound properties for all child components/directives 2. call ngOnInit, OnChanges and ngDoCheck lifecycle hooks on all child components/directives 3. update DOM for the current component 4. run change detection for a child component call ngAfterViewInit lifecycle hook for all child components/directives","link":"/2018/04/26/constructorVsNgOnInit/"},{"title":"clipboard.js 문자열 복사 에러 해결","text":"문제 상황 clipboard.js 라이브러리를 사용해서 문자열을 복사하는데 특정 경우에 아래와 같은 에러가 떴다. ERROR DOMException: Failed to execute ‘querySelector’ on ‘Document’: ‘#1Aivvfv3etgiaVvSqSFNrGoFAyyxLbHyWL1’ is not a valid selector. &lt;input type=\"text\" [value]=\"address.addr\" id=\"{{ address.addr + 1 }}\" /&gt;&lt;button type=\"button\" (click)=\"copyAddr(address.addr)\" id=\"copyWalletAddr\" attr.data-clipboard-target=\"#{{ address.addr + 1 }}\" data-clipboard-action=\"copy\"&gt;&lt;/button&gt; 해결 방법 attr.data-clipboard-target 속성을 통해, 해당 id의 input value를 복사한다. id 값은 숫자로 시작할 수 없다. 지갑주소가 숫자로 시작해서 버그가 발생했다. 지갑주소 앞에 &quot;wallet&quot;이라는 문자열을 추가해줌으로써 해결했다. &lt;input type=\"text\" [value]=\"address.addr\" id=\"{{ 'wallet' + address.addr + 1 }}\" /&gt;&lt;button type=\"button\" (click)=\"copyAddr(address.addr)\" id=\"copyWalletAddr\" attr.data-clipboard-target=\"#{{'wallet' + address.addr + 1 }}\" data-clipboard-action=\"copy\"&gt;&lt;/button&gt;","link":"/2018/08/10/clipboardjs-error/"},{"title":"크로스 도메인 이슈 해결하기","text":"동일 출처 정책 Same Origin Policy(SOP)이란? 만약 나의 api서버를 외부 웹서비스에서 막 접근해서 가져다 쓴다면 보안상으로도 이슈가 있고 트래픽 과부하 문제도 발생할 수 있다. 따라서 이런 행위를 차단하기 위해 동일한 도메인이 아니면 아래처럼 크로스 도메인 이슈를 발생시킨다. 다음과 같은 에러 메시지가 나면 서버에서 CORS 허용을 해줘야 한다. Failed to load 요청하려는 api 주소: No 'Access-Control-Allow-Origin' header is present on the requested resource. Origin 'http://localhost:4200' is therefore not allowed access. 1. 서버의 CORS 허용 이를 해결하기 위해서 보통의 서버단에서 처리를 하는데 CORS Cross Origin Resource Sharing 로 외부요청을 허용하면 외부에서도 사용이 가능하다. CORS로 요청하기 위해서는 먼저 preflight라는 사전 요청을 보내야한다. 1. 클라이언트는 서버에게 preflight라는 사전 요청을 보낸다. 2. HTTP메소드는 OPTIONS를 사용하며, HOST에 클라이언트 주소를, Origin에 서버주소를 넣어서 보낸다. 이를 통해 권한이 있는지를 확인한다. 3. 서버는 preflight 요청을 핸들링하며 CORS를 설정해주면 된다. 1 -1. 모든 요청 허용 preflight 요청을 받기 위해 OPTIONS 메소드를 추가한다. 헤더에 아래 내용들을 포함시키면 된다. Access-Control-Allow-Origin: *Access-Control-Allow-Methods: GET,POST,PUT,DELETE,OPTIONSAccess-Control-Max-Age: 3600Access-Control-Allow-Headers: Origin,Accept,X-Requested-With,Content-Type,Access-Control-Request-Method,Access-Control-Request-Headers,Authorization 1 -2. 선별적 허용 클라이언트의 헤더값을 보고 서버에서 응답헤더에 해당 출처를 허용하는 걸 담아주면 된다. //클라이언트 요청 헤더Origin: 요청을 보내는 페이지의 출처(도메인)Access-Control-Request-Method: 실제 요청하려는 메소드Access-Control-Request-Headers: 실제 요청에 포함되어 있는 헤더명// 서버의 응답 헤더Access-Control-Allow-Origin : 허용할 출처Access-Control-Allow-Credentials: 클라이언트 요청이 쿠키를 통해서자격 증명을 해야 하는 경우에 true. true를 응답 받은 클라이언트는 실제요청시서버에서 정의된 규격의 인증값이 담긴 쿠키를 같이 보내야 한다.Access-Control-Expose-Headers: 클라이언트 요청에 포함되어도 되는 사용자 정의 해더.Access-Control-Max-Age: 클라이언트에서 preflight의 요청 결과를 캐시하는 시간(초)Access-Control-Allow-Methods: 요청을 허용하는 메소드.기본값은 GET,POST이며 클라이언트에서는 헤더 값에 해당하는 메서드일 경우에만 실제 요청을 시도하게 된다.Access-Control-Allow-Headers: 요청을 허용하는 헤더. [참고] http://sjh836.tistory.com/93 2. 앵귤러에서 CORS 허용하기 추가적으로 localhost에서 우리 서비스 api 서버로 요청을 보냈을 때 제대로 응답을 받으려면 앵귤러의 root 디렉토리에 proxy.conf.json파일을 생성해야한다. { \"/*\" : { \"target\" : \"서버api주소\", \"secure\" : false, \"logLevel\" : \"debug\" }} 그리고 로컬에서 테스트할 때 npm start 명령어를 사용하면 바로 저 설정파일이 적용되도록 package.json파일을 수정해주면 된다. { \"scripts\" : { \"start\" : \"ng serve --proxy-config proxy.conf.json\" }} [참고] https://juristr.com/blog/2016/11/configure-proxy-api-angular-cli/","link":"/2018/05/29/cors/"},{"title":"for문, foreach문, for~in문, for~of문 차이점","text":"for문, foreach문, for~in문, for~of문 차이점 for문의 가독성을 좀 더 좋게 하기 위해서 foreach가 나왔지만 아래와 같은 문제가 있었다. foreach You can’t break out of this loop using a break statement or move to the next iteration with continue. (break로 loop를 빠져나오지 못하고, continue로 그다음 반복으로 이동하지 못함) You can’t return from the enclosing function using a return statement. (return을 사용해 해당 function을 마무리하지 못함) for~in Object 프로퍼티를 반복하기 위해 만들어졌다. 물론 array를 반복시킬 수도 있다. index값이 string형이므로 주의가 필요하다. Important If you are expecting a number but in fact have a string this can cause problems, for example “1” + “2” is the string “12” and not the number 3. for~of ES6부터 for~of구문 사용가능하다. for~of구문에서는 break, continue, return을 모두 사용할 수 있다. 현재 사용가능한 가장 간결한 방법이다!","link":"/2018/05/13/for-foreach-forin-forof/"},{"title":"엑셀에서 json파일 추출하기","text":"회사서비스에서 다국어를 지원하기 위해 번역 데이터를 하나로 정리해 둘 필요가 생겼다. 앵귤러에서 다국어 서비스를 하기 위해서는 i18n 모듈을 사용하는데 나라별로 json파일이 필요하다. ( ko.json, en.json, cn.json 등등) 약간의 검토를 해보니 excel파일에서 json을 추출하는 방법이 있다는 것을 알게되어 정리를 해두게 되었다. 1. excel에서 데이터를 정리 후 csv파일로 저장 2. http://www.convertcsv.com/csv-to-json.htm 에서 변환 작업 2-1. Option1 : 변환할 csv 파일 선택 2-2. Options2 : First row is column names 옵션 체크 2-3. Options4 : 출력할 형태 만들기 http://www.convertcsv.com/csv-to-template-output.htm 참고해서 형태 만들기 {lb} : left bracket { {br} : Line break {rb} : right bracket } {f1} : 첫번째 필드값 {h1} : 첫번째 헤드값 3. “Convert CSV To JSON via Template” 버튼 클릭하면 결과물이 나온다.","link":"/2018/05/28/excel-to-json/"},{"title":"else if문과 switch문의 차이점","text":"else if문과 switch문의 차이점 if문은 branch statement, switch문은 jump statement에 기반을 두고 있다. 즉, if문은 조건이 만족하면 실행/만족하지 않으면 무시 (실행을 할 것이냐 말것이냐?) switch문은 입력된 값을 보고 특정 위치로 점프 (어떤 코드를 실행할 것이냐?) branch statement : 레지스터 2개를 비교해서(혹은 레지스터와 상수를 비교해서) 특정 메모리 번지로 이동할 것이냐 말것이냐?를 결정 jump statement : 즉시 특정 메모리 번지로 이동하는 기능 else if 문과 switch 문의 차이점은, 순차적으로 모든 if 문을 도느냐. 아니면 해당하는 case 로 바로 가서 불필요한 연산을 줄이느냐의 차이이다. var regimnet = 3;if (regiment == 1) { ...} else if (regiment == 2) { ...} else if (regiment == 3) { // 앞 1,2 를 거쳐 3으로 온다. ...}switch (regiment) { case 1: ... case 2: ... case 3: // 3으로 바로 온다. ...}","link":"/2018/05/09/elseif-vs-switch/"},{"title":"다익스트라 알고리즘(dijkstra-algorithm)","text":"그래프의 간선에 가중치를 준 가중 그래프weighted graph을 배우자. 가중 그래프에서 X까지의 최단 경로를 구하는 다익스트라 알고리즘을 배우자. 그래프에 사이클 cycle이 있을 경우 다익스트라 알고리즘을 사용할 수 없다. 너비 우선 탐색 vs 다익스트라 알고리즘 너비 우선 탐색으로 최단 경로(가장 적은 수의 구간을 지나는)를 찾을 수 있었다. 다익스트라 알고리즘으로는 최단 시간 경로를 구할 수 있다! 다익스트라 알고리즘은 각 구간에 대해 숫자 혹은 가중치를 줄 수 있다. 전체 가중치의 합이 가장 작은 구간을 찾는다. 다익스트라 알고리즘 4단계 가장 가격이 싼 정점, 즉 도달하는 데 시간이 가장 적게 걸리는 정점을 찾는다. 이 정점의 이웃 정점에 대해 현재의 가격보다 더 싼 경로가 존재하는 지 확인, 만약 존재한다면 가격을 수정. 그래프 상의 모든 정점에 대해 이러한 일을 반복 최종 경로를 계산 위의 그래프는 라마가 바꿀 수 있는 물건들을 정점으로 나타냈다. 간선의 가중치는 물건을 바꾸는 데 드는 돈이다. 라마가 돈을 가장 적게 쓰면서 악보를 피아노와 바꾸려면 어떤 경로를 택해야할까? 일단 각 정점에 대한 가격표를 만든다. 정점의 가격이란 그 정점에 도달하기까지 드는 돈을 의미한다. 정점 가격 LP 5 포스터 0 기타 * 드럼 * 피아노 * 알고리즘을 진행하면서 표를 수정하는데, 최종 경로를 계산하려면 부모열이 필요하다. 부모 정점 가격 악보 LP 5 악보 포스터 0 포스터 기타 30 포스터 드럼 35 LP 기타 20 LP 드럼 25 기타 피아노 40 드럼 피아노 35 위이 표를 보면 라마가 가장 싸게 피아노를 구매할 수 있는 가격은 35달러!! 경로를 찾아보면, 악보 -&gt; (5) -&gt; LP -&gt; (20) -&gt; 드럼 -&gt; (10) -&gt; 피아노 간선의 가중치가 음수인 경우 만약 아래의 그래프에서 드럼을 살 수 있는 최소 가격을 다익스트라 알고리즘으로 구해보면? 부모 정점 가격 악보 LP 5 LP 포스터 -2 악보 포스터 0 포스터 드럼 35 포스터에 도달하는 0달러보다 더 싼 경로는 없다고 가정하지만, 실제로 -2달러인 경로가 존재한다. 다익스트라 알고리즘에서는 포스터 정점을 이미 처리했기 때문에 더 싼 경로는 없다고 가정한다. 그래서 드럼에 이르는 더 싼 경로를(33달러) 다익스트라 알고리즘에서는 찾지 못한다. 코드로 구현 위의 그래프를 코드로 구현해보자. //그래프에 대한 해시테이블graph = {};graph[\"start\"] = {};graph[\"start\"][\"a\"] = 6;graph[\"start\"][\"b\"] = 2;graph[\"a\"] = {};graph[\"a\"][\"fin\"] = 1;graph[\"b\"] = {};graph[\"b\"][\"a\"] = 3;graph[\"b\"][\"fin\"] = 5;graph[\"fin\"] = {};//가격에 대한 해시테이블costs = {};costs[\"a\"] = 6;costs[\"b\"] = 2;costs[\"fin\"] = Infinity;//부모를 위한 해시테이블parents = {};parents[\"a\"] = \"start\";parents[\"b\"] = \"start\";parents[\"fin\"] = \"\";// 이미 처리한 정점 배열processed = [];// 아직 처리하지 않은 가장 싼 정점을 찾는다find_lowest_cost_node = (costs) =&gt; { lowest_cost = Infinity; lowest_cost_node = \"\"; for( let node in costs) { const cost = costs[node]; if(cost &lt; lowest_cost &amp;&amp; processed.indexOf(node) &lt; 0) { lowest_cost = cost; lowest_cost_node = node; } } return lowest_cost_node;}let node = find_lowest_cost_node(costs);while(node) { const cost = costs[node]; const neighbors = graph[node] for(let i =0; i&lt; Object.keys(neighbors).length; i++) { const new_cost = cost + neighbors[Object.keys(neighbors)[i]] if( costs[Object.keys(neighbors)[i]] &gt; new_cost ) { costs[Object.keys(neighbors)[i]] = new_cost; parents[Object.keys(neighbors)[i]] = node } } processed.push(node) node = find_lowest_cost_node(costs)}//{ a: 5, b: 2, fin: 6 } 7장에서 배운 내용 1. 너비 우선 탐색은 가중치가 없는 균일 그래프에서 최단 경로를 계산하는 데 사용. 2. 다익스트라 알고리즘은 가중 그래프에서 최단 거리를 계산하는 데 사용. 3. 다익스트라 알고리즘은 모든 가중치가 양수일 때 정상적으로 동작. 4. 만약 가중치가 음수이면 벨만-포드 알고리즘을 사용.","link":"/2018/05/06/dijkstra-algorithm/"},{"title":"해시 테이블(hash table)","text":"가장 유용한 기본 자료구조의 하나인 해시 테이블(hash table)에 대해 공부해보자. 이번 장에서는 해시 테이블의 구현방법, 충돌, 해시 함수 등에 대해 배운다. 해시 테이블의 내부 구조에 대해 알고 있으면 해시 테이블의 성능을 분석하는 데 도움이 된다. 해시 함수의 소개 식료품 가게에서 장부를 통해 상품의 가격을 알 수 있다고 치면, 장부가 정렬되지 않은 채로 적혀있다면 일일이 단순 탐색으로 찾아야 하므로 O(n)시간이 걸리고, 정렬이 되어 있다면 이진 탐색으로 O(log n)시간이 걸릴 것이다. 만약, 물건의 값을 다 외우고 있는 사람이 있다면? 물건 이름만 대면 즉시 상품의 가격을 알 수 있을거다. (빅오표기법으로 실행시간을 나타내면 O(1)) 식료품 가게에서 모든 상품의 가격을 알고 있는 점원!! 이 사람이 바로 **“해시 함수”**라고 할 수 있다!! 해시 함수 책에 나온 설명에 의하면 해시 함수는 문자열을 받아서 숫자를 반환하는 함수. 위키백과에 따르면 해시 함수는 임의의 길이의 데이터를 고정된 길이의 데이터로 매핑하는 함수이다. 1.해시 함수에는 일관성이 있어햐 한다. 만약 &quot;apple&quot;을 넣었을 때 &quot;4&quot;를 반환한다면 &quot;apple&quot;을 넣을 때마다 반환되는 값은 항상 &quot;4&quot;이어야 한다. 그렇지 않으면 해시 함수로서의 역할을 할 수 없다. 2.다른 단어가 들어가면 다른 숫자가 나와야 한다. 어떤 단어를 넣어도 &quot;1&quot;만 나온다면 좋은 해시 함수가 아니다. 가장 좋은 경우는 서로 다른 단어에 대해 모두 서로 다른 숫자가 나와야 한다. 해시 함수를 통해 각 제품의 가격이 담길 인덱스를 반환받아서 그 위치에 제품 가격을 넣어보자. 제품 가격을 담고 있는 해시 테이블을 만들어보면 아래와 같다. const book = {};book[\"apple\"] = 0.67book[\"milk\"] = 1.49book[\"avocado\"] = 1.49console.log(book);//{ apple: 0.67, milk: 1.49, avocado: 1.49 }console.log(book[\"avocado\"]);//1.49 해시 함수와 배열을 합치면 해시 테이블이라는 자료 구조를 얻을 수 있다. 배열과 리스트는 직접 메모리를 할당하지만, 해시 테이블은 해시 함수를 사용해서 더 총명하게 어디에 원소를 저장할지 결정한다. 해시 테이블은 해시 맵(hash maps), 맵(maps), 딕셔너리(dictionary), 연관 배열(associative arrays)라고도 불린다. 해시 테이블은 속도가 빠르다! 해시 테이블은 키(key)와 값(value)를 가진다. 위의 예에서 보면 book[“avocado”]을 통해 바로 아보카도의 가격을 알 수가 있다. 탐색이 필요없다! 해시 테이블을 사용하는 예 해시 테이블로 조회하기 휴대폰의 전화번호부를 생각해보면, 사람의 이름과 그 사람에 관련된 전화번호를 추가한다. 사람 이름을 입력하면 그 이름과 관련된 전화번호를 알려준다. 해시 테이블이 유용할 때 어떤 것을 다른 것과 연관시키고자 할 때 무언가를 찾아보고자 할 때 중복된 항목을 방지하기 투표소에서 어떤 사람이 투표를 했는가 안 했는가를 판단하기 위해서 배열이나 리스트를 사용하면 긴 목록을 뒤져봐야하지만, 이름을 해시 테이블에 저장하면 해시 테이블에 이름이 있는지, 없는지 즉시 알려준다. voted = {};check_voter = (name) =&gt; { if(voted[name]) console.log(\"이미 투표함\"); else { voted[name] = true; console.log(\"아직 투표전\"); }}check_voter(\"tom\") //아직 투표전check_voter(\"mike\") //아직 투표전check_voter(\"mike\") //이미 투표함 해시 테이블을 캐시로 사용하기 캐싱은 작업 속도를 올리는 일반적인 방법이다. 모든 대형 웹사이트는 캐싱을 사용한다. 그리고 그 자료는 바로 해시 테이블에 저장된다. 캐싱된 자료가 있으면 그 자료를 전송하고 없으면 서버에 요청하는 식으로 사용. 해시 테이블의 장점 어떤 것과 다른 것 사이의 관계를 모형화할 수 있다. 중복을 막을 수 있다. 서버에 작업을 시키지 않고 자료를 캐싱할 수 있다. 충돌 해시 테이블의 성능을 이해하려면 우선 충돌에 대해 이해해야 한다. 만약 인덱스 0 위치에 apple의 가격이 할당되어 있었는데 avocado의 가격을 또 넣게 되면… apple의 가격을 덮어쓰게 된다. 이러한 충돌을 해결하기 위해서는 여러가지 방법이 있는데 가장 간단한 방법은 같은 공간에 여러 개의 키를 연결하는 연결 리스트로 만들어 넣는 것! 하지만 위와 같은 해시 테이블 구조에서 만약 A로 시작하는 과일만 엄청나게 많을 경우…결국 linked list를 탐색하는 것과 비슷해져 해시 테이블이 느려지겠다. 해시 함수는 정말 중요하다. 이상적으로는 해시 함수는 키를 해시 테이블 전체에 고르게 할당해야 한다. 만약 연결 리스트가 길어지면 해시 테이블의 속도도 느려진다. 하지만 좋은 해시 함수가 있다면 그런 일은 발생하지 않는다. 성능 해시 테이블의 성능을 높히기 위해서는 충돌을 피해야 한다. 그렇기 위해서는 아래와 같은 조건이 필요. 낮은 사용률 좋은 해시 함수 - 해시 테이블의 사용률(load factor) = (해시 테이블에 있는 항목의 수)/(해시 테이블에 있는 공간의 수) - 좋은 해시 함수란? 배열에 값을 고루 분포시키는 함수!! 5장에서 배운 내용 사실 직접 해시 테이블을 구현할 일은 거의 없을거다. 우리가 사용하는 프로그래밍 언어들이 구현되어 있는 해시 테이블을 제공하기 때문이다. 평균적인 경우에 해시 테이블의 성능은 상수 시간이다. 해시 테이블은 속도가 빠르고 자료를 여러 가지로 모형화할 수 있기 때문에 아주 강력한 자료 구조이다! 1. 해시 테이블은 해시 함수와 배열을 결합해서 만든다. 2. 충돌은 나쁘다. 충돌을 줄이는 해시 함수가 있어야 한다. 3. 해시 테이블은 정말 빠른 탐색, 삽입, 삭제 속도를 가진다. 4. 해시 테이블은 어떤 항목과 다른 항목의 관계를 모형화하는 데 좋다. 5. 사용률이 0.7보다 커지면 해시 테이블을 리사이징할 때이다. 6. 해시 테이블은 (웹 서버등에서) 데이터를 캐싱하는 데도 사용된다. 7. 해시 테이블은 중복을 잡아내는 데도 뛰어나다.","link":"/2018/04/29/hashtable/"},{"title":"탐욕 알고리즘( greedy-algorithm )","text":"불가능한 문제, 즉 빠른 알고리즘 해법이 존재하지 않는 NP-완전 문제를 다루는 법을 배우자 문제 해결이 불가능한지 아닌지 파악하는 법을 배우고, NP-완전 문제에 대한 간략한 해법을 빨리 구할 수 있는 근사 알고리즘도 배우자 아주 간단한 문제 해결 기법의 하나인 탐욕 알고리즘을 공부하자! 수업 시간표 짜기 문제 학교에서 되도록 많은 수업을 듣고 싶어한다고 가정하고, 가장 많은 수업을 듣도록 시간표를 짜는 방법은? (수업마다 시간이 일부 겹치기 때문에 모든 수업을 다 들을 수는 없다.) 1. 가장 빨리 끝나는 과목을 고른다. 이 과목이 첫 번째로 신청해야할 과목! 2. 첫 번째 과목이 끝난 후 시작하는 과목 중 가장 빨리 끝나는 수업을 선택! 이런 식으로 반복하면 가장 많은 수업을 들을 수 있다. 이것이 바로 탐욕 알고리즘greedy-algorithm!! 간단하다!! 각각의 단계에서 최적의 수를 찾으면 된다! 국소 최적해locally optimal solution를 찾음으로써 최종적으로는 전역 최적해globally optimal solution를 구하게 된다!! 배낭 채우기 문제 물론 탐욕 알고리즘이 항상 올바른 답을 찾는 것은 아니다. 스테레오 $3000 30 lbs 노트북 $2000 20 lbs 기타 $1500 15 lbs 35파운드까지 담을 수 있는 배낭에 넣을 물건의 합을 최대한 크게 하려면? 탐욕 알고리즘을 사용하면, 들어갈 수 있는 물건중에서 가장 비싼것을 고르는 것을 반복하면 되는데 이 경우에는 30파운드의 스테레오를 넣을 수 있다. 총 가치는 3000달러! 하지만, 노트북과 기타를 넣으면 총 35파운드의 배낭에 3500달러의 가치를 담을 수 있다. 1. 탐욕 알고리즘은 올바른 답을 내놓지 못할 수도 있지만, 정답에 상당히 가까운 답을 내놓을 수는 있다. 2. 탐욕 알고리즘은 구현이 간단하면서도 보통은 정답에 상당히 가까운 답을 준다! 집합 커버링 문제 라디오 쇼를 시작했다고 가정해보자. 최대한 적은 수의 방송국 방문하면서 모든 주의 사람들에게 방송을 들려주려면 어떻게 해야할까? (각 방송국마다 커버할 수 있는 지역이 서로 다르고 겹치는 지역도 있다.) 1. 가능한 모든 방송국의 부분 집합을 나열하자. 이것을 멱집합이라고 함.(가능한 부분 집합의 수는 2^n개) * 멱집합 : 어떤 집합의 멱집합(冪集合, 영어: power set)은 그 집합의 모든 부분 집합을 모은 집합 2. 이 부분집합 중에서 50개 주 전체를 커버할 수 있으면서 가장 원소의 수가 적은 부분 집합을 고른다! 여기서 문제는 가능한 부분 집합을 계산하는 데 시간이 많이 걸린다. 부분 집합의 수가 2^n이기 때문에 O(2^n) 시간이 걸린다. 이 문제에 대해 충분히 빠른 속도를 가진 알고리즘은 존재하지 않는다. 그렇다면 어떻게 해결할까? 근사 알고리즘 이럴 때는 탐욕 알고리즘을 사용하면 된다! 거의 정답과 비슷한 답을 유추한다. 1. 아직 방송하지 않은 지역 중 가장 많은 지역을 방송할 수 있는 방송국을 선택.(이미 방송되고 있는 지역이 일부 포함되어 있어도 상관없음.) 2. 모든 주에 방송이 될 때까지 반복. 근사 알고리즘의 성능은 1. 얼마나 빠른가 2. 얼마나 최적해에 가까운가 로 판단하는 데 탐욕 알고리즘은 단순해서 실행 속도가 빨라 좋은 선택이라고 할 수 있다. 탐욕 알고리즘의 실행속도는 O(n^2)시간. 코드로 구현해보자. states_needed = new Set([\"mt\", \"wa\", \"or\", \"id\", \"nv\", \"ut\", \"ca\", \"az\"])//set은 리스트와 비슷한데 중복을 허용하지 않는다.// 방송국마다 전파되는 주가 다른다. 해시테이블을 사용.stations = {}stations[\"kone\"] = new Set([\"id\", \"nv\", \"ut\"])stations[\"ktwo\"] = new Set([\"wa\", \"id\", \"mt\"])stations[\"kthree\"] = new Set([\"or\", \"nv\", \"ca\"])stations[\"kfour\"] = new Set([\"nv\", \"ut\"])stations[\"kfive\"] = new Set([\"ca\", \"az\"])// 방문한 방송국 목록final_stations = new Set();while (states_needed.size &gt; 0) { //states_needed이 빌 때까지 best_station = null; //아직 방송되지 않은 주 중에서 가장 많은 주를 커버하고 있는 방송국 states_covered = new Set(); // 이미 방송된 주 for(let ele in stations) { // stations중에서 covered = (union(states_needed, stations[ele])) if(covered.size &gt; states_covered.size) { //많은 주에 방송이 되는 방송국을 찾는다 best_station = ele; states_covered = (covered); } } states_needed = (array_diff(states_needed, states_covered)); //아직 방송이 되지 않은 주에서 해당 방송국이 방송되는 주를 뺀다. final_stations.add(best_station) //방송국리스트에 추가.}console.log(final_stations)function union(a, b) {a = [...a], b=[...b];var tmp={}, res=[];for(var i=0;i&lt;a.length;i++) tmp[a[i]]=1;for(var i=0;i&lt;b.length;i++) tmp[b[i]] +=1;for(var k in tmp) if(tmp[k] ==2 ) res.push(k);return new Set(res);}function array_diff(a, b) { a = [...a], b=[...b]; var tmp={}, res=[]; for(var i=0;i&lt;a.length;i++) tmp[a[i]]=1; for(var i=0;i&lt;b.length;i++) { if(tmp[b[i]]) delete tmp[b[i]]; } for(var k in tmp) res.push(k); return new Set(res);} NP-완전 문제 집단 커버링 문제를 해결하려면 가능한 모든 집합을 계산해야한다. 이전에 나왔던 외판원 문제도 마찬가지였다. 가능한 모든 경로 가운데 최단 경로를 찾기 위해서는 가능한 모든 경로를 계산해야한다(n!). 집단 커버링 문제와 외판원 문제의 공통점! 모든 가능한 경우를 다 따져서 최단/최소를 구해야 한다는 것! 이런 문제를 NP-완전 문제 NP-complete-problem이라고 한다. 어떤 문제가 NP-완전 문제인지 알 수 있는 방법은? NP-완전 문제인지 파악할 수 있는 쉬운 방법은 없다!!! 다만 몇가지 참고사항이 있다. 1. 항목이 적을 때는 빠르다가 항목이 늘어나면 갑자기 느려진다. 2. &quot;X의 모든 조합&quot;이라고 하면 보통 NP-완전 문제 3. 더 작은 하위 문제로 변환할 수 없어서 X의 가능한 모든 버전을 계산해야한다면 아마도 NP-완전 문제 4. 문제가 수열을 포함하고 풀기 어려우면 NP-완전 문제 5. 만약 문제에 집합이 있고 풀기 어려우면 NP-완전 문제 6. 문제를 집합커버링 문제나 외판원 문제로 재정의할 수 있다면 명백하게 NP-완전 문제 8장에서 배운내용 1. 탐욕 알고리즘은 전역 최적화를 목표로 하지만, 실제로는 국소 최적화를 한다. 2. NP-완전 문제는 빠른 해답이 알려져 있지 않다. 3. 만약 NP-완전 문제가 주어지면 근사 알고리즘을 쓰는 것이 최선. 4. 탐욕 알고리즘은 작성하기도 쉽고, 빠르기 때문에 좋은 근사 알고리즘.","link":"/2018/05/13/greedy-algorithm/"},{"title":"타입스크립트에서 json파일 import하기","text":"타입스크립트에서 json파일 import하기 ES6/ES2015에서 json파일을 코드에 import할 수 있다. 만약 example.json이 있다면 { \"name\": \"testing\"} ES6/ES2015에서 아래와 같은 방식으로 import할 수 있다. // ES6/ES2015// app.jsimport * as data from './example.json';const word = data.name;console.log(word); // output 'testing' 하지만 typescript에서는 똑같이 적용하면 에러가 발생한다. Cannot find module 'example.json' 해결방법 TS Definition 파일에 (예를 들면, typings.d.ts파일) 아래를 추가하면 된다. declare module \"*.json\" { const value: any; export default value;} 그럼 아래와 같이 동작할 수 있다. // Typescript// app.tsimport * as data from './example.json';const word = (&lt;any&gt;data).name;console.log(word); // output 'testing'","link":"/2018/05/23/import-json-in-typescript/"},{"title":"앵귤러에서 이미지 경로 세팅","text":"앵귤러에서 이미지 경로 세팅 앵귤러 프로젝트에서 css파일에 백그라운드 이미지 경로를 넣었더니 assets폴더에 있는 이미지를 제대로 불러들이지 못하는 에러가 발생했다. .intro { background: url(\"./images/overlay.png\"), url(\"./images/intro.jpg\") } 이미지의 경로를 이렇게 넣었더니 이미지 파일을 찾지 못하고 GET http://localhost:4200/images/overlay.png 404 (Not Found) 에러가 발생했다. (실제로 저 위치에 이미지는 존재했는데도 불구하고 이미지를 찾지못함.) .intro { background: url(\"assets/css/images/overlay.png\"), url(\"assets/css/images/intro.jpg\") }.intro { background: url(\"../../assets/css/images/overlay.png\"), url(\"../../assets/css/images/intro.jpg\") } 위와 같이 경로를 넣어주니까 아래와 같이 이미지를 제대로 불러오는 것을 알 수가 있다. 그리고 html에서도 아래와 같이 경로지정을 해줬더니 이미지를 잘 불러온다. &lt;a href=\"assets/css/images/fulls/01.jpg\" class=\"image fit\"&gt; &lt;img src=\"assets/css/images/thumbs/01.jpg\" title=\"The Anonymous Red\" alt=\"\" /&gt;&lt;/a&gt; [참고]절대경로와 상대경로 절대경로 작업 디렉토리와 관계없이 절대적인 위치를 가리키는 경로 상대경로 작업 디렉토리를 기준으로 상대적인 위치를 가리키는 경로 / : 최상위 경로를 의미 ./: 현재 디렉토리를 의미 …/: 상위 디렉토리를 의미","link":"/2018/05/11/img-path/"},{"title":"MSBUILD - error MSB3428 에러 해결","text":"“MSBUILD : error MSB3428” 에러 해결 npm을 통해 모듈들을 다운받다보면 가끔 “MSBUILD : error MSB3428” 에러가 발생하면서 npm install이 제대로 동작하지 않을 때가 있다. 에러 MSBUILD : error MSB3428: Visual C++ 구성 요소 &quot;VCBuild.exe&quot;을(를) 로드할 수 없습니다. 이 문제를 해결하려면 1) .NET Framework 2.0 SDK를 설치하거나, 2) Microsoft Visual Studio 2005를 설치하거나, 3) 해당 구성 요소 가 다른 위치에 설치되어 있는 경우에는 그 위치를 시스템 경로에 추가하십시오. [c:\\Users\\JooYoung\\workspace\\js\\server_side_javascript\\node_modules\\orientjs-native\\build\\binding.sln] 해결방법 npm install --global --production windows-build-tools (관리자 모드로 실행한 커맨드 창에서 실행해야 한다. 시간이 좀 걸림) node-gyp이 python 2.x를 사용하여 python 2.7을 설치한다음에, node-gyp이 그 2.7을 사용도록 설정. 위에서 'npm install --global --production windows-build-tools’을 실행하면, 사용자 홈디렉토리 밑에 .windows-build-tools\\python27이 이미 설치되어 있다. npm config set python &lt;파이썬설치디렉토리&gt;를 설정.","link":"/2018/05/14/msbuild-errorMSB3428/"},{"title":"타입스크립트에서 interface와 class의 차이점","text":"타입스크립트에서 interface와 class의 차이점 노마드 코더의 typechain 강의를 듣던 중 타입스크립트에서 인터페이스와 클래스의 차이점에 대해 설명하는 부분의 해석이 되지 않아(리스닝 부족…) 블로그로 정리하게 되었다. https://toddmotto.com/classes-vs-interfaces-in-typescript 의 글을 번역했다. Classes vs Interfaces in TypeScript 클래스와 인터페이스는 객체지향 프로그래밍에서 뿐만 아니라 타입스크립트에서 타입체크를 쉽게해주는 편리한 도구다. 클래스는 동일한 구성(속성 및 메소드)을 공유하는 객체를 만들 수 있는 blueprint다. 인터페이스는 객체를 설명하는 관련 속성 및 메소드의 그룹이지만 구현이나 초기화는 제공하지 않는다. 두 구조 모두 객체가 어떻게 생겼는지 정의하기 떄문에 두 개 모두 타입스크립트에서 변수의 타입을 체크하는 용으로 쓰일 수 있다. 클래스나 인터페이스 중 무엇을 사용할지는 사용케이스에 따라 다르다. 타입 체크만 하는 경우, 새로운 인스턴스를 생성하거나, 아니면 둘다 해야하거나에 따라. 클래스를 사용하면 타입을 체크하고 구현(인스턴스 생성)까지 할 수 있지만 인터페이스를 통해서는 할 수 없다. 각 구조에서 우리가 얻을 수 있는 것을 제대로 이해하면 코드를 향상시키고 개발자 경험을 향상시킬 수 있다. Using Typescript class ES6부터 class를 사용할 수 있다. 타입스크립트는 타입체크와 정적 프로퍼티같은 추가 기능으로 자바스크립트 클래스를 향상시킨다. 우리 코드를 자바스트립트로 트랜스파일할 때마다 모든 클래스 코드를 transpiled 파일에 보관한다는 것을 의미한다. 그러므로, 클래스는 트랜스파일된 자바스크립트에서도 존재한다. 우리는 클래스를 객체팩토리로 사용한다. 클래스는 객체가 어떻게 보여야하고 어떻게 행동하는지에 대해 정의한 다음 클래스 프로퍼티를 초기화하고 메소드를 정희함으로써 구현한다. 그러므로 클래스의 인스턴스를 생성할 때, 우리는 실행할 수 있는 메소드와 정의된 프로퍼티를 가진 객체를 얻는다. PizzaMaker라는 클래스를 보자. class PizzaMaker { static create(event: { name: string; toppings: string[] }) { return { name: event.name, toppings: event.toppings }; }} PizzaMaker는 간단한 클래스다. create라는 정적 메소드가 있다. 이 클래스의 인스턴스를 생성하지 않고도 create 메소드를 사용할 수 있다. 우리는 클래스에 직접 메소드를 호출한다. Array.from같이. const pizza = PizzaMaker.create({ name: 'Inferno', toppings: ['cheese', 'peppers'],});console.log(pizza);// Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] } 그런 다음, PizzaMaker.create()는 클래스가 아닌 인수로 전달된 객체로부터 정의된 name, topping 프로퍼티를 가진 새로운 객체를 리턴한다. 만약 정적 메소드가 아니었다면, PizzaMaker 인스턴스를 생성한 후에 create메소드를 사용할 수 있다. class PizzaMaker { create(event: { name: string; toppings: string[] }) { return { name: event.name, toppings: event.toppings }; }}const pizzaMaker = new PizzaMaker();const pizza = pizzaMaker.create({ name: 'Inferno', toppings: ['cheese', 'peppers'],});console.log(pizza);// Output: { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] } 위와 같이 하면 정적 메소드를 사용했던 것과 동일한 결과를 얻을 수 있다. 클래스의 인스턴스가 있든 없든 타입스크립트 클래스를 사용할 수 있다는 점에서 매우 유연하다. 정적 프로퍼티와 메소드를 추가하면 싱글톤으로 동작하도록 할 수 있다. 반대의 경우에는 팩토리처럼 동작하게 한다. 타입스크립트에서 유티크한 특징은 타입체크를 위해 클래스를 사용할 수 있다는 것이다. Pizza가 어떻게 생겼는지 정의한 클래스를 선언해보자. class Pizza { constructor(public name: string, public toppings: string[]) {}} Pizza클래스의 정의를 보면, 생성자의 인수에서 우리는 클래스 프로퍼티를 정의하는 편리한 방법을 사용할 수 있다. 타이핑을 절약할 수 있다. Pizza는 이름과 토핑 프로퍼티를 가진 객체를 생성할 수 있다. const pizza = new Pizza('Inferno', ['cheese', 'peppers']);console.log(pizza);// Output: Pizza { name: 'Inferno', toppings: [ 'cheese', 'peppers' ] } Pizza 클래스의 인스턴스라는 것을 보여주는 것 외에는 new Pizza(…)와 PizzaMaker.create(…)의 결과는 동일하다. 두가지 모두 동일한 구조를 산출한다. 그래서 우리는 Pizza클래스를 타입체크용으로 PizzaMaker.create(…)의 인수로 사용할 수 있다. class Pizza { constructor(public name: string, public toppings: string[]) {}}class PizzaMaker { static create(event: Pizza) { return { name: event.name, toppings: event.toppings }; }} 위와 같이 하면 PizzaMaker를 좀 더 선언적으로 만들었고 읽기 쉽게 만들었다. 뿐만아니라, 피자에 정의된 똑같은 객체구조를 다른 곳에서 사용할 필요가 있다면, 저렇게 함으로써 우리는 이동가능한 구조를 가진다. Pizza 의 정의를 export해서 앱 내의 모든 곳에서 접근할 수 있다. Pizza를 클래스로 사용하는 것은 우리가 피자를 정의하고 인스턴스를 생성하기 원한다면 좋지만, 만약 Pizza의 구조를 정의하기 원하지만 인스턴스를 생성할 필요가 없을 때는 interface를 사용하는 것이 편리하다. Using Typesript interface 클래스와 달리 인터페이스는 Typescript 컨텍스트 내에만 존재하는 가상구조이다. typescript컴파일러는 타입체크 목적으로만 인터페이스를 사용한다. 자바스크립트로 트랜스파일 된 후에는 코드에서 인터페이스는 사라진다. 클래스는 프로퍼티 초기화와 메소드구현을 제공함으로써 팩토리나 싱글톤을 정의할 수 있었던 반면, 인터페이스는 객체의 프로퍼티를 정의하는 단순히 구조계약이다. 어떻게 구현하든, 어떻게 인터페이스에 정의된 프로퍼티를 초기화하든 인터페이스와 관련이 없다. Pizza 클래스를 어떻게 Pizza 인터페이스로 변환하는지 보자. interface Pizza { name: string; toppings: string[];}class PizzaMaker { static create(event: Pizza) { return { name: event.name, toppings: event.toppings }; }} Pizza가 클래스이든 인터페이스이든, PizzaMaker 클래스의 타입체크를 위해 사용되기 때문에, Pizza를 인터페이스로 리펙토링하는 것은 PizzaMaker 클래스의 본문에 전혀 영향을 미치지 않는다. Pizza 인터페이스가 name, toppings 프로퍼티를 어떻게 나열하고 PizzaMaker에 어떻게 타입을 제공하는지 관찰해보라. 또 바뀐부분은, Pizza 인스턴스를 더이상 생성할 수 없다. Using Typesript class vs using Typescript interface Pizza를 인터페이스로 선언하면 타입체크는 할 수 있지만 인스턴스를 생성할 수 없다. 이렇게 되면 코드를 명확하게 하고 가독성을 향상시킬 수 있는 기회를 놓치게 된다. PizzaMaker.create()는 피자처럼 보이는 객체를 반환하는데 이것을 Pizza로 반환하면 더 이해하기 쉽지 않을까? 다시 Pizza를 클래스로 만들어서 피자 인스턴스를 반환해보자. class Pizza { constructor(public name: string, public toppings: string[]) {};}class PizzaMaker { static create(event: Pizza) { return new Pizza(event.name, event.toppings); }}const pizza = PizzaMaker.create({ name: 'Inferno', toppings: ['cheese', 'peppers'] }; Conclusion 커스텀 객체를 생성할 필요가 있으면서 타입체크의 이점을 얻으려면 클래스를 사용하고, 인스턴스를 생성하지 않을 경우에는 인터페이스를 사용할 수 있는데, (트랜스파일된 자바스크립트에서는) 코드를 생성하지 않으면서 &quot;가상&quot;으로 타입체크를 할 수 있다. 인터페이스와 클래스 모두 객체의 구조를 정의하고 경우에 따라 서로 교환해서 사용할 수 있다. 다양한 클래스 간에 구조정의를 공유해야할 경우, 우리는 인터페이스에서 구조를 정의한다. 그리고 각 클래스에서 인터페이스를 구현할 수 있다. 이것이 바로 타입스크립트의 힘이고, 엄청 유연하다. 타입스크립트는 포괄적인 객체지향 설계과 다양한 타입체크 기능을 제공한다.","link":"/2018/05/18/interface-vs-class-in-typescript/"},{"title":"재귀(recursion)","text":"여러가지 알고리즘에 쓰이는 코딩 테크닉인 재귀(recursion)을 배운다. 하나의 문제를 기본단계와 재귀단계로 나누는 방법을 배운다. 프로그래밍을 하면서 재귀라는 용어를 종종 접해왔지만 완벽히 이해하지 못한 채 항상 얼버무리듯이 대충 넘어가곤 했었는데 이번에는 기필코!!! 재귀를 완전히 내 것으로 만들자! &quot;재귀&quot;를 한 눈에 보여주는 그림을 찾았다!!! 러시아 인형 속에 더 작은 러시아 인형이 있고 또 그 인형 안에 더 작은 인형이 있는데, 이는 러시아 인형이 너무 작아서 다른 인형을 담지 못할 때까지 계속 된다. 이처럼 어떤 문제를 해결하기 위해 알고리즘을 설계할 때 동일한 문제의 조금 더 작은 경우를 해결함으로써 그 문제를 해결하는 것이다. 문제가 간단해져서 바로 풀 수 있는 문제로 작아질 때까지!! 이런 테크닉을 바로 **재귀!!**라고 한다! 기본 단계와 재귀 단계 재귀함수는 자기 자신을 호출하기 때문에 실수로 무한 반복을 하는 함수를 만들기 쉽다. 재귀함수를 만들 때는 언제 재귀를 멈출지를 알려줘야 한다. 그래서 모든 재귀함수는 기본단계와 재귀단계로 나눠져있다. 재귀단계 - 함수가 자기 자신을 다시 호출하는 부분. 기본단계 - 자기 자신을 다시 호출하지 않는 부분. 즉, 무한 반복에 빠지지 않게 하는 부분 countdown = i =&gt; { console.log(i); if (i &lt;= 0) // 기본단계 return; else countdown(i - 1); //재귀단계};countdown(5); 스택 스택은 리스트의 한쪽 끝으로만 자료의 삽입, 삭제 작업이 이루어지는 자료 구조이다. 스택은 가장 나중에 삽입된 자료가 가장 먼저 삭제되는 후입선출 방식으로 자료를 처리한다. 포스트잇을 생각하면 새로운 포스트잇을 가장 위에다 붙이고(push), 뗄 때도 가장 위에 있는 것부터 떼어낸다(pop). 호출 스택 컴퓨터는 호출 스택이라고 불리는 스택을 사용. greet2 = (name) =&gt; { console.log(`how are you, ${name}?`);}bye = () =&gt; { console.log(`ok bye!`);}greet = (name) =&gt; { console.log(`hello, ${name}!`); greet2(name); console.log(`getting ready to say bye...`); bye();}greet('mina'); // 결과 hello, mina! how are you, mina? getting ready to say bye... ok bye! 1. greet(name)함수를 실행하기 위해서 컴퓨터는 메모리상자를 하나 할당 2. name이라는 변수의 값이 &quot;mina&quot;가 되었으므로 이 값을 메모리에 저장 3. greet2(name)함수를 호출하기 위해 또다른 메모리상자를 할당 4. `how are you, name?`을 찍고 함수 호출 상태에서 반환하여 돌아옴 5. 함수가 반환되면 가장 위에 있는 상자는 POP 연산으로 없어짐 6. 다시 greet(name)함수로 돌아옴 (**어떤 함수를 호출하여 완전히 실행을 완료하기 전이라도 그 함수를 잠깐 멈추고 다른 함수를 호출할수 있다. 중지된 함수의 변수의 값은 모두 메모리에 저장되어 있다!!!**) 1. bye() 함수 실행 후 다시 return 2. 현재 greet(name)함수. 더이상 실행할 것이 없으므로 greet함수에서도 반환하여 돌아옴 이런 식으로 여러 개의 함수를 호출하면서 사용되는 변수를 저장하는 스택을 호출 스택Call Stack이라고 한다. 재귀 함수에서 호출 스택 사용 fact = x =&gt; { if (x == 1) return 1; else return x * fact(x - 1);};console.log(fact(5)); fact(5)를 호출하면 그 위에 fact(4)가 쌓이고 또 그 위에는 fact(3) …fact(2) fact(1)이렇게 함수가 호출된다. fact(1)에 다다르면 1을 리턴하고 스택에서 pop된다. 나머지 함수에 대해서도 동일한 작업이 진행된다. 스택을 사용하면 모든 정보를 저장해야 하므로 메모리를 많이 소비, 스택이 너무 커졌다는 것은 과다한 함수 호출정보를 저장하고 있다는 의미… stack overflow 에러가 발생할 것이다. 적절하게 잘 사용해야겠다… 3장에서 배운 내용 1. 재귀는 함수가 스스로를 호출하는 것 2. 모든 재귀 함수는 기본 단계와 재귀 단계라는 두 부분으로 나누어져 있다 3. 스택에는 push와 pop이라는 두 가지 연산이 있다 4. 모든 함수 호출은 호출 스택을 사용 5. 호출 스택은 너무 커져서 메모리를 엄청나게 소비할 수도 있다","link":"/2018/04/23/recursion/"},{"title":"앵귤러에서 뒤로가기 에러 해결 (routing)","text":"앵귤러에서 routing 설정 회사 프로젝트를 진행하던 중, 브라우저에서 뒤로가기 버튼을 클릭했을 때 뒤로 가기가 제대로 동작하지 않는 문제가 있었다. 문제상황 { path: 'home', component: HomeComponent,},{ path: 'home/:platform', component: HomeComponent},{ path: 'home/:platform/:lang', component: HomeComponent},{ path: 'new-account', component: NewAccountComponent},{ path: 'new-account/:lang', component: NewAccountComponent}, 라우팅을 위와 같이 Optional하게 파라미터를 설정하는 방식으로 구성했더니. home페이지로 들어오면 url이 /home -&gt; /home/platform -&gt; /home/platform/lang 이렇게 이중, 삼중으로 변경되었다. new-account페이지에서 home페이지로 온 뒤, 브라우저의 뒤로가기 버튼을 클릭하면 new-account페이지가 아니라, /home/platform -&gt; /home/platform/lang으로 redirect되어 뒤로가기가 제대로 동작하지 않는 문제가 발생했다. 해결방법 우리 사이트의 경우 url에 플랫폼과 언어정보가 붙는 것은 필수적이므로 아래와 같이 라우팅을 변경했다. {path: 'home/:platform/:lang',component: HomeComponent},{path: 'new-account/:lang',component: NewAccountComponent }, 위와 같이 변경했더니 원하는대로 뒤로가기를 할 수 있었다. 앵귤러의 라우팅에 대해 좀 더 상세히 정리할 필요가 있겠다. 결국 Optional하게 파라미터를 추가하는 방식을 잘못 사용했기 때문에 위와 같은 문제가 발생한 것이다! 제대로 알고 사용하자! &lt;참고블로그&gt; https://codecraft.tv/courses/angular/routing/parameterised-routes/ https://www.sitepoint.com/component-routing-angular-router/","link":"/2018/05/24/routing-error/"},{"title":"매개변수(parameter)와 인수(argument)의 차이","text":"매개변수(parameter)와 인수(argument)의 차이 매개변수(parameter)는 함수 서명 괄호부에 정의하여 함수 내에서 사용하는 변수를, 인수(argument)는 호출자(caller)가 함수를 호출할 때 매개변수에 전달하는 값을 가리킨다!","link":"/2018/05/16/parameter-argument/"},{"title":"퀵 정렬(quicksort)","text":"분할 정복(divide-and-comquer) 문제 해결 방법 중에서 가장 유명한 재귀적 기술인 분할 정복 전략에 대해서 알아보자! 문제를 분할 정복 전략으로 풀기 위해서는 아래의 두 가지 단계를 거친다. 기본 단계를 해결한다. 이 부분은 가능한 한 간단한 문제이어야만 한다. 문제가 기본 단계가 될 때까지 나누거나 작게 만든다. 가로세로 1680 * 640 인 땅을 똑같은 크기의 정사각형으로 나누는데 정사각형 토지의 크기를 최대한 크게하려면 어떻게 나누면 될까? 위의 분할 정복 전략 단계에 따라서 첫번째로 가장 간단한 기본 단계를 찾아보면… 한 변의 길이가 다른 변의 길이의 2배이면 두 개의 정사각형으로 나눌 수 있겠다!! 640m길이의 정사각형으로 2개를 만들고 남은 640 * 400 크기의 토지. 남은 토지를 400m의 정사각형으로 나누고 남은 400 * 240 크기의 토지… 이런 식으로 반복하다보면, 160 * 80 크기의 토지를 나눠야 하는 경우에 도달하고, 이 경우는 우리가 처음에 찾았던 가장 간단한 기본 단계이다. 160 * 80 토지는 2개의 80m의 정사각형 토지로 나눌 수 있다. 그러므로 1680 * 640 크기의 토지를 똑같은 크기의 정사각형으로 나눌 때 가장 큰 정사각형의 크기는 80 * 80이다. 이런 식으로 풀이해나가는 과정을 분할정복이라고 한다. 책에 나온 배열의 숫자를 모두 합하는 예제를 보자. forLoopSum = (arr) =&gt; { let total = 0; for ( let x of arr) total += x; return total;}recursiveSum = (arr) =&gt; { if (arr.length == 0) return 0; return arr[0] + recursiveSum(arr.slice(1));}console.log(\"forLoopSum\", forLoopSum([1, 2, 3, 4, 5]));console.log(\"recursiveSum\", recursiveSum([1, 2, 3, 4, 5])); 단순히 for문을 돌려도 되지만, 두번째 방법처럼 재귀적인 방법을 사용할 수도 있다. 재귀를 잘 이해하고 있으면 함수형 프로그래밍을 좀 더 쉽게 익힐 수 있다고 한다. 퀵 정렬 퀵 정렬은 정렬 알고리즘이다. 선택 정렬보다 훨씬 빠르고 실제로도 자주 사용된다. 기준 원소(pivot)을 선정 기준 원소보다 작거나 같은 원소는 모두 왼쪽 배열로, 기준 원소보다 큰 원소는 모두 오른쪽 배열로 분할 각각 따로 정렬한 후, 다시 합병하며 정렬 quickSort = array =&gt; { if (array.length &lt; 2) // 정렬할 필요가 없는 기본단계 return array; else { // 재귀단계 const pivot = array[0]; //기준점(여기에서는 첫번째 원소를 기준점으로 잡음) const less = []; const greater = []; for (let ele of array.slice(1)) { if (ele &lt;= pivot) less.push(ele); // 기준원소보다 작거나 같은 원소배열 else greater.push(ele); //기준원소보다 큰 원소배열 } return quickSort(less) + [pivot] + quickSort(greater); }};console.log(\"quickSort\", quickSort([10, 3, 7, 2])) 빅오표기법으로 퀵정렬의 시간복잡도를 나타내면? 퀵 정렬은 선택한 기준 원소에 따라 처리 속도가 달라진다는 특징이 있다. 퀵 정렬은 빠른 정렬로 평균적으로 O(n log n)의 시간복잡도를 가지게 된다. 하지만 최악의 경우 O(n^2)의 시간 복잡도를 가지게 된다. 또한, 퀵 정렬은 추가 메모리 공간을 필요로 하지 않으며 정렬된 리스트에 대해서는 오히려 수행시간이 더 많이 걸리는 단점도 있다. 이러한 불균형 분할을 방지하기 위해 피벗을 선택할 때 단순히 리스트의 왼쪽 데이터를 사용하는 대신 리스트 내의 중간 값을 피벗으로 선택하기도 한다. (왼쪽, 오른쪽, 중간의 세 값중 중간 값을 택해서 선택하는 방법을 많이 사용합니다.) 4장에서 배운 내용 1. 분할 정복은 문제를 더 작은 조각으로 나누어 푼다. 만약 리스트에 분할 정복을 적용한다면 기본 단계는 원소가 없는 빈 배열이거나 하나의 원소만 가진 배열이 된다. 2. 퀵 정렬을 구현하려면 기준 원소를 무작위로 선택, 퀵 정렬의 평균적인 실행시간은 O(n log n) 3. 빅오표기법에서 가끔씩 상수가 중요해질 때도 있다. 퀵 정렬이 병합정렬보다 빠른 이유도 상수 때문. 4. 단순 탐색과 이진 탐색을 비교할 때는 상수항이 전혀 문제가 되지 않았다. 왜냐면, 리스트가 길어지면 O(log n)이 O(n)보다 훨씬 빨라지니까!","link":"/2018/04/24/quicksort/"},{"title":"선택 정렬(selection-sort)","text":"01. 메모리가 동작하는 방법 메모리에 무언가를 저장해야 할 때마다 컴퓨터에게 공간의 요청! 그러면 컴퓨터는 무언가를 저장할 수 있는 주소를 알려준다. 만약 여러 개의 원소를 저장해야 한다면 배열과 리스트라는 두 가지 방법 중 하나를 사용해야 한다. 02. 배열과 연결 리스트 배열 : 여러 개의 원소를 나란히 저장. 만약 원소 3개를 가진 배열에 새로운 원소를 하나 추가하려는데 만약 바로 옆자리가 없다면, 컴퓨터에게 4개의 자리가 있는 다른 메모리 공간을 요청하고 4개의 원소를 그 자리로 옮긴다. 연결된 리스트 : 여러 개의 원소를 메모리의 어느 곳에나 둘 수 있다. 각 원소에는 목록의 다음 원소에 대한 주소가 저장되어 있다. 마치 보물찾기처럼… 첫번째 주소에 가면 &quot;다음 원소는 주소 123에 있다&quot;고 알려주고 주소 123을 찾아가면 “다음 원소는 주소 654에 있다” 이렇게 알려주는 것처럼. 연결된 리스트를 사용하면 원소를 추가하는 일이 쉽다. 그냥 메모리의 아무 곳에나 원소를 넣고, 그 주소를 바로 앞의 원소에 저장해두면 된다. 특정원소를 바로 읽으려면…?!! 배열은 모든 원소의 주소를 다 알고 있어서 특정위치의 원소를 바로 읽을 수 있다. 연결된 리스트의 경우, 마지막 원소를 읽고싶으면 첫번째 원소부터 차례로 읽어 그 다음 주소를 알아내고, 그 다음을 찾아가고…이렇게해서 마지막 원소를 읽을 수가 있다. 리스트의 가운데 삽입하기에는…?!! 리스트의 가운데, 어떤 원소를 삽입할 때는 연결된 리스트를 사용하면 좋다. 리스트는 이전 원소가 무엇을 가리키는지 바꾸기만 하면 되니까!! 배열같은 경우는 추가된 원소 그 다음에 오는 모든 원소의 위치를 바꿔야한다. 자리가 모자르다면 새로운 장소에 배열의 처음부터 끝까지 옮겨놓아야하니까… 매우 불편하다 삭제할때는…?!! 삭제할 때에도 마찬가지로 리스트가 낫다! 이전 원소가 가리키는 위치만 바꾸면 되니까!!! 배열은 원소 하나만 삭제하고 싶어도 그 뒤에 오는 모든 원소를 다 옮겨야한다. 어떤 자료구조가 더 많이 쓰일까…?!! 물론 경우에 따라 다르겠지만 보통 임의 접근이 가능한 배열이 더 자주 쓰인다. 배열의 읽기 속도가 빠른 이유는 배열에서는 임의 접근이 가능하기 때문이지요! 배열과 리스트의 연산에 대한 실행시간을 표로 나타내보면 배열에서 읽기는 임의 접근으로 바로 읽을 수 있으니까 O(1), 삽입, 삭제의 경우 n개의 원소를 모두 옮겨야하는 경우도 있으므로 O(n) 리스트에서 읽기는 n번 만큼 읽어야만 n의 위치를 알 수 있으므로 O(n), 삽입, 삭제의 경우 맨처음과 맨마지막 원소에 대해서만 바로 접근하여 추가 혹은 삭제 가능하므로 그 경우에만 O(1) *O(n)시간은 목록의 모든 원소를 한 번씩 건드려야 한다는 뜻! 03. 선택정렬 무작위로 정렬된 음악리스트를 많이 들은 순으로 정렬하는 방법은…?!! 리스트의 모든 항목을 살펴보고, 많이 들은 순대로 정렬하는 방법! 처음에는 n개의 항목을 점검하고 그 다음에는 n-1, n-2, …, 2, 1 로 줄어든다. 평균적으로 1/2 _ n번 점검! n _ (1/2 *n) -&gt; 상수는 무시되므로 실행시간은 O(n^2)!! 선택정렬은 깔끔한 알고리즘이지만 빠르지 않다… 퀵정렬의 경우 O(n log n) 시간밖에 걸리지 않는다. 파이썬 예제 -&gt; 자바스크립트로 변환해보기 findSmallest = (arr) =&gt; { let smallest = arr[0]; let smallest_index = 0; for(let i = 1; i&lt; arr.length; i++) { if(arr[i] &lt; smallest) { smallest = arr[i]; smallest_index = i; } } return smallest_index;}selectionSort = (arr) =&gt; { const newArr = []; for(let i = 0; arr.length; i++) { const smallest_index = findSmallest(arr); const splice = arr.splice(smallest_index, 1); newArr.push(splice[0]); } return newArr;}console.log(selectionSort([5, 3, 6, 2, 10])); 2장에서 배운 내용 1. 컴퓨터 메모리는 거대한 서랍장과 같다. 2. 여러 개의 항목을 저장하고 싶을 때는 배열이나 리스트를 사용하세요. 3. 배열을 쓰면 모든 항목을 이웃하는 위치에 저장한다. 4. 리스트를 쓰면 모든 항목이 흩어지지만, 각 항목은 다음 항목의 주소를 저장하고 있다. 5. 배열은 읽기가 빠르다. 6. 연결 리스트는 삽입과 삭제가 빠르다. 7. 배열의 모든 원소는 같은 자료형(예를 들면, 모두 정수형이거나 모두 실수형)이어야 한다.","link":"/2018/04/12/selection-sort/"},{"title":"앵귤러에서 GA달기","text":"SPA에 GA 달기 문제상황 1. 추적 코드 누락 error 메시지. &quot; 유효한 추적 코드를 찾을 수 없습니다.&quot; 2. 활성 사용자 집계는 안 되고 있음. 3. 사용자 이벤트발생 추적은 정상적 원인 일반적인 웹사이트의 경우는 페이지를 이동할 때마다 서버에서 리소스를 다운받기 때문에 구글에서 제공하는 아래와 같은 추적코드를 헤더(header) 혹은 푸터(footer)같은 웹사이트 내 (거의) 모든 페이지에서 동일하게 실행되는 영역에 붙이면 사용자 트래킹이 가능하다. (사용자가 새 페이지로 이동할 때마다 추적코드가 실행되기 때문에 사용자의 행동을 추적가능하다) &lt;script&gt; (function(i,s,o,g,r,a,m) {i['GoogleAnalyticsObject'] = r; i[r]=i[r]||function(){ (i[r].q = i[r].q || []).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,'script','//www.google-analytics.com/analytics.js','ga'); ga('create', 'UA-xxxxxxxx-x', 'auto'); ga('send', 'pageview'); // Pageview event&lt;/script&gt; 하지만 앵귤러와 같은 SPA(Single Page Application)의 경우, 처음 페이지로드를 할 때 사이트 전체를 탐색하는 데 필요한 모든 리소스를 로드하기 때문에 위의 추적코드가 앱이 최초 실행될 때 딱 한번만 실행된다. 그래서 추가적으로 앵귤러 앱내에서 페이지 이동이 일어날때 GA에 알려주는 코드가 필요! 해결방법 앵귤러는 라우터모듈을 통해서 페이지 이동을 하는데 이 때, Router.events 발생시킨다. 이 이벤트를 받아서 GA에 알려주면 되겠다. app.component.ts의 constructor에 this.router.events.subscribe(event =&gt; { if (event instanceof NavigationEnd) { (&lt;any&gt;window).ga('set', 'page', event.urlAfterRedirects); (&lt;any&gt;window).ga('send', 'pageview'); } }); 사용자의 페이지 이동을 추적할 수 있다. 위 코드를 추가하니, 활성사용자 집계도 정상적으로 동작한다.","link":"/2018/05/09/spa-ga/"},{"title":"이직 준비 시이작~!","text":"퇴사를 결정하고 이직 준비를 시작했다. 남은 시간들 동안 마무리해야할 일들을 잘 마무리하고, 이직을 위한 공부를 시작해야겠뜨아~!","link":"/2019/11/23/Essay/이직일기/"},{"title":"안드로이드 에러 - x86 emulation currently requires hardware acceleration","text":"문제 상황 emulator: ERROR: x86 emulation currently requires hardware acceleration! 위와 같은 에러가 나면서 에뮬레이터가 실행되지 않았다. 해결 방법 Tools - SDK manager - SDK tools에서 Intel x86 emulator accelerator (HAXM installer)가 설치되어 있는지 체크, 설치가 안되었다면 설치. 만약 설치해도 똑같은 에러가 발생한다면, emulator accelerator를 다운로드 완료했음에도 안드로이드 SDK Manager가 자동으로 emulator accelator를 설치하지 못한다는 의미다. 수동으로 설치해줘야한다. Hardware_Accelerated_Execution_Manager가 설치된 위치를 찾아가서 실행파일을 실행시키면 된다. 내경우에는 아래의 경로에 있었다. C:\\Users\\cmina\\AppData\\Local\\Android\\Sdk\\extras\\intel\\Hardware_Accelerated_Execution_Manager 설치를 완료하고 나면 아래와 같은 화면이 뜬다. 위의 과정을 모두 마친 뒤, 다시 앱을 실행시켜보면 에뮬레이터에서 잘 동작하는 것을 확인할 수 있다.","link":"/2018/08/01/Programming/Android/android-hardware-acceleration/"},{"title":"android.view.InflateException 해결","text":"문제 상황 Activity에 두 개의 fragment를 구성한 프로젝트를 build하려고 하자 아래와 같은 에러를 뿜으면서 앱이 build 실패했다. Caused by: android.view.InflateException: Binary XML file line #25: Binary XML file line #25: Error inflating class fragmentCaused by: android.view.InflateException: Binary XML file line #25: Error inflating class fragmentCaused by: java.lang.NullPointerException 검색을 통해 알아보니 android.view.InflateException 에러는 아래와 같은 경우 발생한다고 한다. xml에 값을 잘못 넣었을 경우 CustomView의 생성자 함수를 제대로 만들어주지 않았을 경우 [참고] CustomView 생성자의 매개변수에 context가 꼭 들어가야 한다고 함! public CustomView(Context context, AttributeSet attrs){ super(context, attrs);} 해결 방법 내 경우에는 위의 2가지 사례에 해당하지 않았고, 좀 더 찾아보니 fragment에 class 속성을 명시하지 않아서 생기는 문제였다. &lt;fragmentandroid:id=\"@+id/mapFragment\"android:layout_width=\"match_parent\"android:layout_height=\"wrap_content\"app:layout_constraintLeft_toLeftOf=\"parent\"app:layout_constraintRight_toRightOf=\"parent\"app:layout_constraintTop_toBottomOf=\"@+id/guideline\"app:layout_constraintBottom_toBottomOf=\"parent\"class=\"com.example.minachoi.findjuyou.fragment.MapFragment\"/&gt; 이렇게 class값을 넣어주니 제대로 build되었다.","link":"/2018/08/01/Programming/Android/android-inflateException/"},{"title":"Android Render Problem 해결","text":"문제 상황 constraintlayout을 적용하던 중에 testview를 세팅했음에도 design 탭 화면에 나타나지 않는 문제를 발견했다. 에러 메시지를 확인해보니 Render problem!!! 해결 방법 app - build.gradle 에서 # 수정전compileSdkVersion28targetSdkVersion28dependencies{...implementation'com.android.support:appcompat-v7:28.0.0-alpha3'…}# 수정후compileSdkVersion27targetSdkVersion27dependencies{...Implementation 'com.android.support:appcompat-v7:27.0.2'…} Sdk버전을 낮춰주면 된다. 수정 후, File -&gt; Invalidate Caches/Restart -&gt; Invalidate and Restart 하면 정상적으로 동작하는 것을 확인할 수 있다. 아직 com.android.support:appcompat-v7:28.0.0-alpha3이 안정화가 안돼서 생기는 문제인 듯하다.","link":"/2018/07/31/Programming/Android/android-render-error/"},{"title":"이진탐색트리 구현","text":"이진탐색트리를 구현해보자. 그전에 자료구조 트리의 개념을 먼저 살펴보면, 트리 (Tree) 란? 트리: Node와 Branch를 이용해서, 사이클을 이루지 않도록 구성한 데이터 구조 이진 트리 : Node가 가질 수 있는 Branch가 최대 2개인 트리 이진 탐색 트리 : 이진트리 중에서 Branch를 만들 때, 자기 노드보다 작은 것은 왼쪽, 큰 것은 오른쪽에 위치하도록 하는 트리. [참고]알아둘 용어 Node: 트리에서 데이터를 저장하는 기본 요소 (데이터와 다른 연결된 노드에 대한 Branch 정보 포함) Root Node: 트리 맨 위에 있는 노드 Level: 최상위 노드를 Level 0으로 하였을 때, 하위 Branch로 연결된 노드의 깊이를 나타냄 Parent Node: 어떤 노드의 다음 레벨에 연결된 노드 Child Node: 어떤 노드의 상위 레벨에 연결된 노드 Leaf Node (Terminal Node): Child Node가 하나도 없는 노드 Sibling (Brother Node): 동일한 Parent Node를 가진 노드 Depth: 트리에서 Node가 가질 수 있는 최대 Level 실제로 어디에 많이 사용되나? 트리 중 이진 트리 (Binary Tree) 형태의 구조로, 탐색(검색) 알고리즘 구현을 위해 많이 사용된다. 탐색시 시간복잡도 depth (트리의 높이) 를 h라고 표기한다면, O(h) n개의 노드를 가진다면, ℎ=𝑙𝑜𝑔2𝑛 에 가까우므로, 시간 복잡도는 𝑂(𝑙𝑜𝑔𝑛) 참고: 빅오 표기법에서 𝑙𝑜𝑔𝑛 에서의 log의 밑은 10이 아니라, 2이다. 한번 실행시마다, 50%의 실행할 수도 있는 명령을 제거한다는 의미. 즉 50%의 실행시간을 단축시킬 수 있다는 것을 의미한다. 하지만 위와 같은 시간복잡도는 이진트리가 균형잡혀 있을 때의 평균 시간복잡도이다. 최악의 경우 링크드 리스트와 동일한 성능을 보여주기도 한다. 이진탐색트리 구현 class Node { constructor(data) { this.data = data this.right = null this.left = null }}class BinarySearchTree { constructor() { this._head = null } insert(data) { if (this._head) { let currNode = this._head while (true) { if (data &lt; currNode.data) { if (currNode.left) { // 비교할 대상 바꾸기 currNode = currNode.left } else { currNode.left = new Node(data) break } } else { if (currNode.right) { // 비교할 대상 바꾸기 currNode = currNode.right } else { currNode.right = new Node(data) break } } } } else { this._head = new Node(data) } } search(data) { let curr = this._head while (curr) { if (curr.data === data) { return true } else if (data &lt; curr.data) { curr = curr.left } else { curr = curr.right } } return false } /* 복잡하므로 경우를 나눠서 생각하는게 좋다. 1. 삭제할 노드가 leaf node일 경우 2. child node가 하나인 노드 삭제 3. child node가 두개인 노드 삭제 (둘중에 하나의 전략으로) 전략 1. 삭제할 노드의 오른쪽 자식중, 가장 작은 값을 삭제할 노드의 parent노드가 가리키도록 한다. 전략 2. 삭제할 노드의 왼쪽 자식중, 가장 큰 값을 삭제할 노드의 parent 노드가 가리키도록 한다. 아래의 코드에서는 전략1을 사용 */ delete(data) { let searched = false let currNode = this._head let parentNode = this._head // 1. 삭제할 노드 있는 체크 while (currNode) { if (currNode.data === data) { searched = true break } else if (data &lt; currNode.data) { parentNode = currNode currNode = currNode.left } else { parentNode = currNode currNode = currNode.right } } if (!searched) return false // case 1 : leaf node 인지 체크 if (currNode.left === null &amp;&amp; currNode.right === null) { // 삭제할 노드가 왼쪽노드인지 오른쪽노드인지 체크 if (data &lt; parentNode.data) { parentNode.left = null } else { parentNode.right = null } // delete currNode } // case 2 : child 노드를 하나만 가지고 있을 때 if (currNode.left !== null &amp;&amp; currNode.right === null) { if (data &lt; parentNode.data) { parentNode.left = currNode.left } else { parentNode.right = currNode.left } } else if (currNode.left === null &amp;&amp; currNode.right !== null) { if (data &lt; parentNode.data) { parentNode.left = currNode.right } else { parentNode.right = currNode.right } } /* case 3 전략 1 삭제할 노드의 오른쪽 자식중, 가장 작은 값을 삭제할 노드의 parent노드가 가리키도록 한다. */ if (currNode.left !== null &amp;&amp; currNode.right !== null) { // case 3-1 : 삭제할 Node가 Parent Node 왼쪽에 있을 때 if (data &lt; parentNode.data) { let changeNode = currNode.right let changeNodeParent = currNode.right while (changeNode.left !== null) { changeNodeParent = changeNode changeNode = changeNode.left } // 오른쪽 노드들중 가장 작은 값의 노드가 right child가 있는지 체크 if (changeNode.right !== null) { changeNodeParent.left = changeNode.right } else { changeNodeParent.left = null } parentNode.left = changeNode changeNode.right = currNode.right changeNode.left = currNode.left } // case 3-2 : 삭제할 Node가 Parent Node 오른쪽에 있을 때 else { let changeNode = currNode.left let changeNodeParent = currNode.left while (changeNode.left !== null) { changeNodeParent = changeNode changeNode = changeNode.left } // 오른쪽 노드들중 가장 작은 값의 노드가 right child가 있는지 체크 if (changeNode.right !== null) { changeNodeParent.left = changeNode.right } else { changeNodeParent.left = null } parentNode.right = changeNode changeNode.left = currNode.left changeNode.right = currNode.right } } }} 이진검색트리 테스트 // 임의의 숫자 100개 준비const numset = new Set()while (numset.size != 100) { numset.add(Math.floor(Math.random() * 1000))}// 헤드값을 500을 가지는 이진검색트리 생성const bst = new BinarySearchTree()bst.insert(500)// 선택된 100개의 숫자를 이진 탐색 트리에 입력for (let item of numset) { bst.insert(item)}// 입력한 100개의 숫자 검색 (검색 기능 확인)for (let item of numset) { if (bst.search(item) === false) { console.log(\"search failed\", item) }}// 10개 임의로 삭제해보기const deleteNums = new Set()const numArray = [...numset]while (deleteNums.size != 10) { const index = Math.floor(Math.random() * 100) deleteNums.add(numArray[index])}for (let item of deleteNums) { if (bst.delete(item) === false) { console.log(\"delete failed\") }}","link":"/2019/12/26/Programming/Algorithm/binary-search-tree-implement/"},{"title":"build.gradle (Project)와 build.gradle (Module)의 차이점","text":"1년만에 안드로이드 스튜디오를 켰더니만…모든 것이 새롭다. 머릿속에 확실히 정리가 안 된 내용들은 글로 정리를 해두자. [참고] build.gradle이란? 모듈의 빌드 방법이 정의된 빌드스크립트이다. 빌드에 사용할 SDK버전부터 애플리케이션 버전, 사용하는 라이브러리 등 다양한 항목을 설정할 수 있다. Build.gradle(Project : MyApplication) Top-level build file where you can add configuration options common to all sub-projects/modules. 이 파일에 정의된 설정은 Project의 모든 모듈에 적용된다. 모듈은 프로젝트를 구성하는 하나의 구성품! 보통 대부분의 안드로이드 프로젝트에는 하나의 모듈인 app모듈만 있다. Build.gradle(Module:app) Build file of your specific module (where you add your dependencies, signing configs, build types, flavors, etc) 이 빌드 설정은 앱모듈에만 적용된다. 모든 모듈은 각자의 특정한 gradle파일을 가지고 있다. [참고] https://stackoverflow.com/questions/28295933/difference-between-build-gradleproject-and-build-gradlemodule","link":"/2018/07/15/Programming/Android/android-build-gradle/"},{"title":"스택/큐 - 기능개발","text":"문제 프로그래머스 팀에서는 기능 개선 작업을 수행 중입니다. 각 기능은 진도가 100%일 때 서비스에 반영할 수 있습니다. 또, 각 기능의 개발속도는 모두 다르기 때문에 뒤에 있는 기능이 앞에 있는 기능보다 먼저 개발될 수 있고, 이때 뒤에 있는 기능은 앞에 있는 기능이 배포될 때 함께 배포됩니다. 먼저 배포되어야 하는 순서대로 작업의 진도가 적힌 정수 배열 progresses와 각 작업의 개발 속도가 적힌 정수 배열 speeds가 주어질 때 각 배포마다 몇 개의 기능이 배포되는지를 return 하도록 solution 함수를 완성하세요. 제한 사항 1. 작업의 개수(progresses, speeds배열의 길이)는 100개 이하입니다. 2. 작업 진도는 100 미만의 자연수입니다. 3. 작업 속도는 100 이하의 자연수입니다. 4. 배포는 하루에 한 번만 할 수 있으며, 하루의 끝에 이루어진다고 가정합니다. 예를 들어 진도율이 95%인 작업의 개발 속도가 하루에 4%라면 배포는 2일 뒤에 이루어집니다. 풀이 과정 먼저 각 기능별로 완료까지 걸리는 일수를 구한다. done배열을 forloop을 돌리면서 첫 번째 값부터 larger값과 비교해서 larger보다 같거나 작으면 answer[answer.length - 1]++ 이렇게 원래있던 값에 +1을 해주고 아니면 answer[answer.length] = 1 새로운 값을 넣어준다. 나의 풀이 function solution(progresses, speeds) { var answer = [] const done = [] progresses.forEach((progress, index) =&gt; { const days = Math.ceil((100 - progress) / speeds[index]) done.push(days) }) let larger for (let i = 0; i &lt; done.length; i++) { if (larger &gt;= done[i]) { answer[answer.length - 1]++ } else { larger = done[i] answer[answer.length] = 1 } } return answer}","link":"/2019/12/02/Programming/Algorithm/feature-develop/"},{"title":"LinkedList - Add two numbers","text":"문제 2개의 양의 정수를 나타내는 링크드리스트가 주어진다. 각각 일의 자리부터 역순으로 숫자 하나씩 저장되어 있다. 두 숫자를 더한 후 링크드리스트로 리턴하시오. 0을 제외하고는 [0, 0, 0] 이런 식의 숫자는 없는 것으로 가정한다. Example: Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4) Output: 7 -&gt; 0 -&gt; 8 Explanation: 342 + 465 = 807. 출처 - https://leetcode.com/problems/add-two-numbers/ 풀이 과정 숫자를 더할 때 1의 자리부터 더해서 10이 넘어가는 값은 다음 자릿수 더할 때 올려주는 식으로 계산을 하니까 문제에서 주어진 리버스 링크드리스트 그대로 사용하면 된다. l1, l2 둘 중에 하나라도 값이 있다면 계속 while 문을 돈다. 일의 자리부터 더하는데, 9를 넘어가는 값은 올림값으로 prevNum에 담아두고, 일의 자리값만 answerNode에 추가한다. 링크드 리스트를 더할 때, 이전 계산값에서 올려보낸 값이 있을 수도 있으니 항상 prevNum을 같이 더한다. 그리고 while 문을 다 돌고도 prevNum 값이 존재할 수도 있다. 값이 존재하면 링크드리스트에 값을 추가한다. 나의 풀이 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} l1 * @param {ListNode} l2 * @return {ListNode} */var addTwoNumbers = function(l1, l2) { let node1 = l1 let node2 = l2 let answerNode = null // 올림한 값 let prevNum = 0 while (node1 || node2) { // 링크드 리스트의 크기가 같지 않을 수도 있다. val가 없다면 0으로 셋팅 const sum = (node1 ? node1.val : 0) + (node2 ? node2.val : 0) const temp = sum + prevNum prevNum = 0 // 일의 자리만 const num = temp % 10 if (answerNode) { addNode(answerNode, new ListNode(num)) } else { answerNode = new ListNode(num) } //num + prevNum도 10넘는지 체크 if (temp &gt; 9) { prevNum = Math.floor(temp / 10) } node1 = node1 ? node1.next : null node2 = node2 ? node2.next : null } if (prevNum) { addNode(answerNode, new ListNode(prevNum)) } return answerNode}const addNode = (node, data) =&gt; { if (node) { while (node.next) { node = node.next } node.next = data }}","link":"/2019/12/11/Programming/Algorithm/add-two-numbers/"},{"title":"Unique Number of Occurrences","text":"문제 소문자로 이루어진 문자열 배열 A가 주어졌을 때, 모든 문자열에 등장하는 문자의 리스트를 리턴하세요. 중복도 포함해서. Example 1: Input: [“bella”,“label”,“roller”] Output: [“e”,“l”,“l”] Example 2: Input: [“cool”,“lock”,“cook”] Output: [“c”,“o”] Note: 1 &lt;= A.length &lt;= 100 1 &lt;= A[i].length &lt;= 100 A[i][j] is a lowercase letter 출처 - https://leetcode.com/problems/find-common-characters/ 풀이과정 먼저 가장 짧은 길이의 문자열을 { &quot;b0&quot;: 1, &quot;e1&quot;: 1, &quot;l2&quot;: 1, &quot;l3&quot;: 1, &quot;a4&quot;: 1 } 이런 식의 object로 만들었다. key는 중복된 문자도 유니크하게 만들기 위해 문자+index로 구성했고, 이 때의 값은 등장횟수다. 이제 가장 짧은 문자열을 forloop으로 돌면서 그 안에서 주어진 문자열 배열을 forloop으로 돈다. 기준이 되는 가장 짧은 문자는 제외하기 때문에 j=1부터 시작한다. 만약 찾는 문자가 존재한다면 shortestObj[shortest[i] + i] += 1을 통해 등장횟수를 1만큼 더해주고 그 문자가 다시 카운트되지 않도록 array.splice(idx, 1) 문자열에서 삭제한다. 마지막으로, shortestObj의 값이 sorted.length와 같다면 모든 문자열에 등장한 것이므로 그 때의 문자 shortest[i]를 정답 배열에 추가한다. 이 방법은 이중 forloop를 돌아서 효율이 좋진 않다… discuss를 보며 새로운 방법을 찾아봐야할 것 같다. 나의 풀이 /** * @param {string[]} A * @return {string[]} */var commonChars = function(A) { const sorted = A.sort((a, b) =&gt; a.length - b.length) // 가장 짧은 스트링 찾기 const shortest = sorted[0] const shortestObj = {} for (let i = 0; i &lt; shortest.length; i++) { shortestObj[shortest[i] + i] = 1 } for (let i = 0; i &lt; shortest.length; i++) { const value = shortest[i] for (let j = 1; j &lt; sorted.length; j++) { const array = sorted[j].split(\"\") const idx = array.indexOf(value) if (idx &gt; -1) { shortestObj[shortest[i] + i] += 1 array.splice(idx, 1) sorted[j] = array.join(\"\") } } } let answer = [] for (let i = 0; i &lt; shortest.length; i++) { if (shortestObj[shortest[i] + i] === sorted.length) { answer.push(shortest[i]) } } return answer} 더 공부할 내용 : splice의 정확한 사용법 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/splice","link":"/2019/12/15/Programming/Algorithm/find-common-characters/"},{"title":"해시테이블 구현","text":"제일 간단한 형태의 해시테이블을 코드로 구현해보면 아래와 같다. 해시테이블의 크기를 임의로 10이라고 설정. 가장 간단한 해시테이블 구현 class HashTable { constructor() { this.storageLimit = 10 this.table = new Array(this.storageLimit) } // data -&gt; index getHash(data) { let hash = 0 for (let i = 0; i &lt; data.length; i++) { /* charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수 */ hash += data.charCodeAt(i) } console.log(\"hash\", hash) return hash % this.storageLimit } /* data 와 value를 넣으면, 해당 data에 대한 key를 찾아서 해당 key에 대응하는 해쉬주소에 value를 저장 */ add(data, value) { const index = this.getHash(data) this.table[index] = value } get(data) { const index = this.getHash(data) return this.table[index] } remove(data) { const index = this.getHash(data) delete this.table[index] }}const hashTable = new HashTable()hashTable.add(\"john\", \"111222333\")hashTable.add(\"dave\", \"222333444\")hashTable.add(\"stella\", \"333444555\")hashTable.add(\"mike\", \"444555666\")console.log(hashTable.table)/* [ &lt;1 empty item&gt;, '111222333', '444555666', &lt;2 empty items&gt;, '333444555', '222333444', &lt;3 empty items&gt; ] */ 해시테이블의 장단점 해시테이블은 (충돌이 없다고 가정할 경우) 읽기, 쓰기에 대한 시간복잡도가 O(1)로 데이터 저장/읽기 속도가 매우 빠르다. 그래서 검색 속도도 빠르고 데이터의 중복 확인도 쉽다. 반면 일반적으로 저장공간이 좀 더 많이 필요하다는 단점이 있다. 또 해시충돌이 있을 경우 이를 해결하기 위한 별도의 자료구조가 필요하다는 점도 단점이다. 해시테이블의 주요 용도 검색이 많이 필요한 경우 저장, 삭제, 읽기가 빈번한 경우 캐쉬 구현시 (중복 확인이 쉽기 때문) 해시테이블의 가장 큰 문제는 충돌(Collision)의 경우다. 해시충돌을 어떻게 해결할 것인가? 충돌이 일어나면, 링크드 리스트라는 자료 구조를 사용해서, 링크드 리스트로 데이터를 추가로 뒤에 연결시켜서 저장하는 방식으로 해결을 해보았다. 위의 코드에서 add, get, remove 함수를 변형했다. 해시충돌 해결한 해시테이블 구현 class HashTable { constructor() { this.storageLimit = 10 this.table = new Array(this.storageLimit) } // data -&gt; index getHash(data) { let hash = 0 for (let i = 0; i &lt; data.length; i++) { // charCodeAt() 메서드는 주어진 인덱스에 대한 UTF-16 코드를 나타내는 0부터 65535 사이의 정수 hash += data.charCodeAt(i) } return hash % this.storageLimit } // data 와 value를 넣으면, 해당 data에 대한 key를 찾아서, 해당 key에 대응하는 해쉬주소에 value를 저장 add(data, value) { const index = this.getHash(data) // 이미 해당 index에 데이터 존재 if (this.table[index]) { for (let i = 0; i &lt; this.table[index].length; i++) { if (this.table[index][i][0] === data) { this.table[index][i][1] = value return } } this.table[index].push([data, value]) } else { this.table[index] = [[data, value]] } } get(data) { const index = this.getHash(data) if (this.table[index]) { for (let i = 0; i &lt; this.table[index].length; i++) { if (this.table[index][i][0] === data) { return this.table[index][i][1] } } return null } else { return null } } remove(data) { const index = this.getHash(data) if (this.table[index].length === 1 &amp;&amp; this.table[index][0][0] === data) { delete this.table[index] } else { for (let i = 0; i &lt; this.table[index].length; i++) { if (this.table[index][i][0] === data) { this.table[index].splice(i, 1) } } } }}const hashTable = new HashTable()// 일부러 충돌이 나는 data를 입력했다. evad, davehashTable.add(\"evad\", \"111222333\")hashTable.add(\"dave\", \"222333444\")hashTable.add(\"stella\", \"333444555\")hashTable.add(\"mike\", \"444555666\")console.log(hashTable.table)/* [ &lt;2 empty items&gt;, [ [ 'mike', '444555666' ] ], &lt;2 empty items&gt;, [ [ 'stella', '333444555' ] ], [ [ 'evad', '111222333' ], [ 'dave', '222333444' ] ], &lt;3 empty items&gt; ] */console.log(hashTable.get(\"dave\"))// 222333444hashTable.remove(\"evad\")console.log(hashTable.table)/* [ &lt;2 empty items&gt;, [ [ 'mike', '444555666' ] ], &lt;2 empty items&gt;, [ [ 'stella', '333444555' ] ], [ [ 'dave', '222333444' ] ], &lt;3 empty items&gt; ] */ 시간 복잡도 일반적인 경우(Collision이 없는 경우)는 O(1) 최악의 경우(Collision이 모두 발생하는 경우)는 O(n) 해쉬 테이블의 경우, 일반적인 경우를 기대하고 만들기 때문에, 시간 복잡도는 O(1) 이라고 말할 수 있다. 만약 해시테이블의 사이즈를 크게하면 충돌이 일어날 가능성이 줄어든다. 대신 공긴의 효율성이 떨어지겠지만. 저장할 데이터의 크기에 따라 적당한 해시테이블의 사이즈를 셋팅하는 것도 중요하겠다. 검색에서 해쉬 테이블의 사용 예 16개의 배열에 데이터를 저장하고, 검색할 때 O(n) 16개의 데이터 저장공간을 가진 위의 해쉬 테이블에 데이터를 저장하고, 검색할 때 O(1) 이렇게 자바스크립트로 해시테이블을 구현해봤다. 이제 해시테이블 관련한 문제를 많이 풀어봐야겠다!","link":"/2019/12/25/Programming/Algorithm/hash-table-implement/"},{"title":"해시 - 베스트앨범","text":"문제 스트리밍 사이트에서 장르 별로 가장 많이 재생된 노래를 두 개씩 모아 베스트 앨범을 출시하려 합니다. 노래는 고유 번호로 구분하며, 노래를 수록하는 기준은 다음과 같습니다. 속한 노래가 많이 재생된 장르를 먼저 수록합니다. 장르 내에서 많이 재생된 노래를 먼저 수록합니다. 장르 내에서 재생 횟수가 같은 노래 중에서는 고유 번호가 낮은 노래를 먼저 수록합니다. 노래의 장르를 나타내는 문자열 배열 genres와 노래별 재생 횟수를 나타내는 정수 배열 plays가 주어질 때, 베스트 앨범에 들어갈 노래의 고유 번호를 순서대로 return 하도록 solution 함수를 완성하세요. 제한사항 genres[i]는 고유번호가 i인 노래의 장르입니다. plays[i]는 고유번호가 i인 노래가 재생된 횟수입니다. genres와 plays의 길이는 같으며, 이는 1 이상 10,000 이하입니다. 장르 종류는 100개 미만입니다. 장르에 속한 곡이 하나라면, 하나의 곡만 선택합니다. 모든 장르는 재생된 횟수가 다릅니다. 풀이과정 장르를 key로 하고 고유번호 id와 재생된 횟수 playCount를 프로퍼티로 가지는 객체를 value로 셋팅한다. 각 장르별로 재생횟수의 합을 reduce메소드를 사용해서 구하고 재생횟수의 합이 큰순으로 정렬한다. 각 장르별로 2곡씩, 만약 장르에 속한 곡이 하나라면 하나의 곡만 배열 answer에 담아준다. 나의 풀이 function solution(genres, plays) { var answer = [] const items = {} genres.forEach((genre, i) =&gt; { if (items[genre]) { items[genre].push({ id: i, playCount: plays[i] }) } else { items[genre] = [{ id: i, playCount: plays[i] }] } }) const values = Object.values(items) // order by sum values.sort((a, b) =&gt; { const sumOfB = b.reduce((a, b) =&gt; a + b.playCount, 0) const sumOfA = a.reduce((a, b) =&gt; a + b.playCount, 0) return sumOfB - sumOfA }) values.forEach(value =&gt; { value.sort((a, b) =&gt; b.playCount - a.playCount) answer.push(value[0].id) if (value.length &gt; 1) { answer.push(value[1].id) } }) return answer} 이번에 정리해야할 것 reduce메소드의 정확한 용법 const sumOfB = b.reduce((a, b) =&gt; a.playCount + b.playCount, 0) 처음에 위와 같이 짰다가 에러가 발생했다. const reducer = (accumulator, currentValue) =&gt; accumulator + currentValue// reducer함수의 첫번째 매개변수는 accumlator(지금까지의 합)이다.// 위에서 playCount의 합을 구하는 것은 아래와 같이 되어야 한다.const sumOfB = b.reduce((a, b) =&gt; a + b.playCount, 0)// 그러면 a에 초기값 0이 셋팅된 후, 그 다음 playCount를 더한 값이 a가 되고...배열b를 전부 다 돌 때까지 반복 [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce push push() 메서드는 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환합니다. [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/push","link":"/2019/11/26/Programming/Algorithm/hash-bestalbum/"},{"title":"자바에서 Incompatible types error","text":"ArrayList의 타입을 제네릭을 통해 명시하기 문제 상황 private ArrayList findUnAskedPermissions(ArrayList wanted) { ArrayList result = new ArrayList(); for (String perm : wanted) { if(!hasPermissions(perm)) { result.add(perm); } } return result;} for (String perm : wanted) 이 부분에서 Incompatible types required java.lang.string found java.lang.object 이러한 에러가 발생했다. 해결 방법 findUnAskedPermissions 의 파라미터 타입을 ArrayList wanted 에서 ArrayList&lt;String&gt; wanted으로 변경하니 에러가 사라졌다. ArrayList를 사용할 때 제너릭으로 타입형을 명시해 주는 것을 잊지말자!","link":"/2018/08/12/Programming/Android/java-incompatible-type-error/"},{"title":"해시 - 완주하지 못한 선수","text":"앞으로 2달동안 하루에 하나씩이라도 알고리즘 문제를 풀어보자. 알고리즘 문제는 프로그래머스에서 얻었다. (https://programmers.co.kr/learn/challenges?tab=algorithm_practice_kit) 1. 문제 마라톤에 참여한 선수들 중 단 한명의 선수를 제외하고 모두 마라톤을 완주했다. 마라톤 참여선수 배열 participant과 마라톤 완주선수 배열 completion이 주어졌을 때, 완주하지 못한 선수 한명을 return하는 Solution 함수를 작성하시오. 제한사항 1. 마라톤 경기에 참여한 선수의 수는 1명 이상 100,000명 이하입니다. 2. completion의 길이는 participant의 길이보다 1 작습니다. 3. 참가자의 이름은 1개 이상 20개 이하의 알파벳 소문자로 이루어져 있습니다. 4. 참가자 중에는 동명이인이 있을 수 있습니다. 2. 풀이과정 participant 배열과 completion 배열을 각각 오름차순으로 정렬한 후 차례대로 이름을 비교해 다른 이름이 발견되면 그 이름의 선수가 마라톤을 완주하지 못한 선수다. 처음에는 participant의 배열을 돌리는데 forEach를 사용하려고 했다. function solution(participant, completion) { var answer = \"\" participant.sort() completion.sort() participant.forEach((item, i) =&gt; { if (item !== completion[i]) { answer = item // 이름이 다른 경우를 발견하고 forEach문을 빠져나오기 return } }) return answer} 위와 같이 코드를 작성하니 participant = [mislav, stanko, mislav, ana] completion = [stanko, ana, mislav] 일 경우에 예외가 발생했다. 그 이유는 forEach문은 중간에 멈출 수가 없다. 그래서 첫번째로 일치하지 않는 mislav 이름을 찾고도 그다음 forloop이 진행되어 answer에 stanko가 담겨 테스트를 통과하지 못했다. [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach 예외를 던지지 않고는 forEach()를 중간에 멈출 수 없습니다. 중간에 멈춰야 한다면 forEach()가 적절한 방법이 아닐지도 모릅니다. 그래서 forEach대신에 find 메서드를 사용했다. find() 메서드는 주어진 판별 함수를 만족하는 첫 번째 요소의 값을 반환합니다. 그런 요소가 없다면 undefined를 반환합니다. 3. 내가 작성한 코드 function solution(participant, completion) { var answer = \"\" participant.sort() completion.sort() answer = participant.find((item, i) =&gt; { return item !== completion[i] }) return answer} 엇, 그런데 해시문제인데 해시를 사용하지 않았다…","link":"/2019/11/24/Programming/Algorithm/hash-no-completion/"},{"title":"스택/큐 - 쇠막대기","text":"문제 여러 개의 쇠막대기를 레이저로 절단하려고 합니다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자릅니다. 쇠막대기와 레이저의 배치는 다음 조건을 만족합니다. - 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있습니다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓습니다. - 각 쇠막대기를 자르는 레이저는 적어도 하나 존재합니다. - 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않습니다. 아래 그림은 위 조건을 만족하는 예를 보여줍니다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향입니다. 이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있습니다. (a) 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 '()'으로 표현합니다. 또한 모든 '()'는 반드시 레이저를 표현합니다. (b) 쇠막대기의 왼쪽 끝은 여는 괄호 '('로, 오른쪽 끝은 닫힌 괄호 ')'로 표현됩니다. 위 예의 괄호 표현은 그림 위에 주어져 있습니다. 쇠막대기는 레이저에 의해 몇 개의 조각으로 잘리는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘리고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘립니다. 쇠막대기와 레이저의 배치를 표현한 문자열 arrangement가 매개변수로 주어질 때, 잘린 쇠막대기 조각의 총 개수를 return 하도록 solution 함수를 작성해주세요. 제한사항 arrangement의 길이는 최대 100,000입니다. arrangement의 여는 괄호와 닫는 괄호는 항상 쌍을 이룹니다. 풀이 과정 어떻게 풀어야할지 감이 안잡혀 시간을 꽤나 쓴 문제다. 열린괄호와 닫힌괄호 사이에 있는 숫자의 합에 +1을 한 것이 절단한 쇠막대기의 갯수다. 일단 레이저를 뜻하는 ()을 1로 치환하고 forEach문을 돌리기 위해 split(&quot;&quot;)을 통해 배열로 만든다. forloop을 돌면서 ) 을 만나면 역순으로 forloop을 안에서 한번 더 돌린다. 1을 만나면 num에 더해준다. 작은 forloop을 돌 때마다 num+1한 값을 answer에 더한다. ( 을 만나면 forloop을 빠져나온다. 이미 카운트한 ( 을 str[j] = &quot;|&quot;와 같이 다른 문자로 치환해서 재카운트되지 않도록 한다. 이 문제가 왜 스택/큐 파트로 분류되어 있는지는 잘 모르겠다. 나의 풀이 function solution(arrangement) { var answer = 0 const str = arrangement.replace(/\\(\\)/g, 1).split(\"\") console.log(str) const data = [] str.forEach((s, i) =&gt; { if (s === \")\") { // 가장 가까운 ( 을 찾아서 없애기 let num = 0 for (let j = i - 1; j &gt; -1; j--) { if (str[j] === \"1\") { num += Number(str[j]) } else if (str[j] === \"(\") { str[j] = \"|\" break } } answer += num + 1 } }) return answer}","link":"/2019/12/02/Programming/Algorithm/iron-rod/"},{"title":"해시 - 위장","text":"문제 스파이들은 매일 다른 옷을 조합하여 입어 자신을 위장합니다. 예를 들어 스파이가 가진 옷이 아래와 같고 오늘 스파이가 동그란 안경, 긴 코트, 파란색 티셔츠를 입었다면 다음날은 청바지를 추가로 입거나 동그란 안경 대신 검정 선글라스를 착용하거나 해야 합니다. 종류 이름 얼굴 동그란 안경, 검정 선글라스 상의 파란색 티셔츠 하의 청바지 겉옷 긴 코트 스파이가 가진 의상들이 담긴 2차원 배열 clothes가 주어질 때 서로 다른 옷의 조합의 수를 return 하도록 solution 함수를 작성해주세요. 제한사항 1. clothes의 각 행은 [의상의 이름, 의상의 종류]로 이루어져 있습니다. 2. 스파이가 가진 의상의 수는 1개 이상 30개 이하입니다. 3. 같은 이름을 가진 의상은 존재하지 않습니다. 4. clothes의 모든 원소는 문자열로 이루어져 있습니다. 5. 모든 문자열의 길이는 1 이상 20 이하인 자연수이고 알파벳 소문자 또는 '\\_' 로만 이루어져 있습니다. 6. 스파이는 하루에 최소 한 개의 의상은 입습니다. 풀이과정 2차원 배열 clothes을 받아서 Object의 프로퍼티를 이용해서 key, value값을 세팅헸다. 의상종류를 key로 하고 의상 이름을 배열에 추가하여 value로 했다. 의상종류별로 선택할 수 있는 경우의 수가 의상갯수 + 1 (입지않을 경우의 수 추가)가 된다. 그러므로 의상종류 별로 경우의 수를 구해 곱한 다음 의상을 하나도 걸치지 않았을 경우 1를 빼주면 된다. 나의 풀이 function solution(clothes) { var answer = 1 const obj = {} clothes.forEach(element =&gt; { if (obj[element[1]]) { obj[element[1]].push(element[0]) } else { obj[element[1]] = [element[0]] } }) var objKeyArr = Object.keys(obj) for (let i = 0; i &lt; objKeyArr.length; i++) { const value = obj[objKeyArr[i]].length answer = (value + 1) * answer } return answer - 1}","link":"/2019/11/25/Programming/Algorithm/hash-camouflage/"},{"title":"Middle of the Linked List","text":"문제 값이 존재하는 단방향 링크드리스트의 head값이 주어졌을 때, 링크드리스트의 중간 노드를 리턴하시오. 만약 2개의 중간노드가 있다면 두번째 값을 리턴하세요. 출처 - https://leetcode.com/problems/middle-of-the-linked-list/ 풀이 과정 링크드리스트는 길이는 리스트를 전부 순회해야지만 알 수 있다. 리스트 순회를 통해 리스트의 길이를 알아내고 그 길이의 중간값을 구한다. 다시 리스트를 순회해서 그 중간노드를 리턴하면 된다. 나의 풀이 /** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var middleNode = function(head) { let node = head let length = 1 while (node.next) { node = node.next length++ } let n = Math.floor(length / 2) node = head for (let i = 0; i &lt; n; i++) { node = node.next } return node} 추천 방식 내가 전혀 떠올리지 못한 방법 중에 릿코드에서 추천한 2개의 포인터를 이용한 방법이 있다. 링크드리스트를 순회를 slow pointer와 그것보다 2배빠른 fast pointer 두 개의 포인터로 하면 fast pointer가 리스트의 마지막에 닿는 순간에 slow pointer는 리스트의 중간에 위치하게 된다. var middleNode = function(head) { let slow, fast = head while (fast &amp;&amp; fast.next) { slow = slow.next fast = fast.next.next } return slow}","link":"/2019/12/08/Programming/Algorithm/middle-of-linkedlist/"},{"title":"Maximum Number of Balloons","text":"문제 문자열 text가 주어졌을 때, text의 문자를 사용해서 단어 &quot;balloon&quot;을 만들 수 있는 만큼 만들려고 한다. 각 문자는 최대 한번만 쓸 수 있다. 최대 몇 개의 balloon을 만들 수 있는지 리턴하세요. Example 1: Input: text = &quot;nlaebolko&quot; Output: 1 Example 2: Input: text = &quot;loonbalxballpoon&quot; Output: 2 Example 3: Input: text = &quot;leetcode&quot; Output: 0 Constraints: 1 &lt;= text.length &lt;= 10^4 text consists of lower case English letters only. 출처 - https://leetcode.com/problems/maximum-number-of-balloons 풀이과정 balloon의 각 문자열을 key로 하고 value=0으로 셋팅한 balloonObj를 만든다. text의 길이만큼 forloop을 돌면서 balloonObj의 key와 동일한 문자열이 있으면 value를 +1 해준다. balloonObj의 key를 배열로 뽑아내서 key가 l, o 이면 value를 1/2해준다. balloon을 만드는데 l, o는 두개씩 필요하기 때문. 이제 balloonObj의 value값 중 가장 작은 값을 골라 리턴을 하면 우리가 찾는 주어진 text를 이용해 단어 balloon을 만들 수 있는 최대값이다. 나의 풀이 /** * @param {string} text * @return {number} */var maxNumberOfBalloons = function(text) { const balloonString = \"balloon\" const balloonObj = {} for (let i = 0; i &lt; balloonString.length; i++) { balloonObj[balloonString[i]] = 0 } for (let j = 0; j &lt; text.length; j++) { if (balloonObj[text[j]] === 0 || balloonObj[text[j]]) { balloonObj[text[j]] += 1 } } const keys = Object.keys(balloonObj) keys.forEach(key =&gt; { if (key === \"l\" || key === \"o\") { balloonObj[key] = Math.floor(balloonObj[key] / 2) } }) console.log(balloonObj) const values = Object.values(balloonObj) return Math.min(...values)}","link":"/2019/12/16/Programming/Algorithm/maximum-number-of-balloons/"},{"title":"링크드 리스트 구현","text":"자료구조를 공부하는 중에 링크드 리스트의 개념이 잘 와닿지 않아 자바스크립트로 링크드 리스트를 구현해봤다. 겨우겨우 구현을 해봤는데 여전히 많이 헷갈린다. (도식화 이미지 정리 필요) class Node { constructor(data) { this.data = data this.next = null }}class LinkedList { constructor() { this._length = 0 this._head = null } // append(데이터): 리스트의 맨 끝에 데이터를 추가한다. append(data) { const item = new Node(data) let node = this._head if (node) { while (node.next) { node = node.next } node.next = item } else { this._head = item } this._length++ } // removeAt(위치): 해당 위치에 있는 데이터를 삭제한다. removeAt(index) { // index가 유효한 값인지 일단 먼저 체크 if (index &gt; -1 &amp;&amp; index &lt; this._length) { let node = this._head let prev = null // 헤드를 삭제하는 경우라면, 그 다음 값을 헤드로 셋팅 if (index == 0) { this._head = node.next this._length-- } else { // 삭제하려는 index-1 값을 찾아서 next를 그 다음 next 값으로 let i = 0 while (i &lt; index) { prev = node node = node.next i++ } prev.next = node.next this._length-- } return node.data } else { return null } } // indexOf(데이터): 해당 데이터의 인덱스를 반환한다. 존재하지 않을 경우 결과 값은 -1이다. indexOf(data) { let curr = this._head let index = 0 while (curr.next) { if (curr.data === data) { return index } curr = curr.next index++ } return -1 } // remove(데이터): 데이터를 삭제한다. remove(item) { let curr = this._head if (!this._head) return \"빈 리스트입니다\" // head일경우 if (curr.data === item) { this._head = curr.next this._length-- } else { while (curr.next) { if (curr.next.data === item) { curr.next = curr.next.next this._length-- break } curr = curr.next } } } // insert(위치, 데이터): 해당 위치에 데이터를 삽입한다. insert(index, item) { // index가 유효한 값인지 일단 먼저 체크 if (index &gt; -1 &amp;&amp; index &lt;= this._length) { let curr = this._head const newNode = new Node(item) let i = 0 // 헤드로 if (index === 0) { this._head = newNode this._head.next = curr this._length++ } else { // 추가하려는 index-1 값을 찾아서 let i = 0 let prev = null while (i &lt; index) { prev = curr curr = curr.next i++ } let nextTemp = prev.next prev.next = newNode newNode.next = nextTemp this._length++ } } else { return null } } // isEmpty(): 데이터가 하나도 없다면 true를, 그 외엔 false를 반환한다. isEmpty() { if (this._length === 0) return true return false } //size(): 데이터 개수를 반환한다. 배열의 length 프로퍼티와 비슷하다. size() { return this._length }} 실행시켜보면 const linked = new LinkedList()linked.append(1)linked.append(2)linked.append(3)linked.append(4)linked.append(5)console.log(linked)/* LinkedList { _length: 5, _head: Node { data: 1, next: Node { data: 2, next: [Node] } }} */linked.insert(3, 7)console.log(JSON.stringify(linked))/* {\"_length\":6,\"_head\":{\"data\":1,\"next\":{\"data\":2,\"next\":{\"data\":3,\"next\":{\"data\":7,\"next\":{\"data\":4,\"next\":{\"data\":5,\"next\":null}}}}}}} */console.log(linked.remove(4))console.log(JSON.stringify(linked))/* {\"_length\":5,\"_head\":{\"data\":1,\"next\":{\"data\":2,\"next\":{\"data\":3,\"next\":{\"data\":7,\"next\":{\"data\":5,\"next\":null}}}}}} */console.log(linked.indexOf(4))/* -1*/","link":"/2019/12/07/Programming/Algorithm/linked-list/"},{"title":"스택/큐 - 다리를 지나는 트럭","text":"문제 트럭 여러 대가 강을 가로지르는 일 차선 다리를 정해진 순으로 건너려 합니다. 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 알아내야 합니다. 트럭은 1초에 1만큼 움직이며, 다리 길이는 bridge_length이고 다리는 무게 weight까지 견딥니다. ※ 트럭이 다리에 완전히 오르지 않은 경우, 이 트럭의 무게는 고려하지 않습니다. 예를 들어, 길이가 2이고 10kg 무게를 견디는 다리가 있습니다. 무게가 [7, 4, 5, 6]kg인 트럭이 순서대로 최단 시간 안에 다리를 건너려면 다음과 같이 건너야 합니다. 경과시간 / 다리를 지난 트럭 / 다리를 건너는 트럭 / 대기 트럭 0 [] [] [7,4,5,6] 1~2 [] [7] [4,5,6] 3 [7] [4] [5,6] 4 [7] [4,5] [6] 5 [7,4] [5] [6] 6~7 [7,4,5] [6] [] 8 [7,4,5,6] [] [] 따라서, 모든 트럭이 다리를 지나려면 최소 8초가 걸립니다. solution 함수의 매개변수로 다리 길이 bridge_length, 다리가 견딜 수 있는 무게 weight, 트럭별 무게 truck_weights가 주어집니다. 이때 모든 트럭이 다리를 건너려면 최소 몇 초가 걸리는지 return 하도록 solution 함수를 완성하세요. 제한 조건 1. bridge_length는 1 이상 10,000 이하입니다. 2. weight는 1 이상 10,000 이하입니다. 3. truck_weights의 길이는 1 이상 10,000 이하입니다. 4. 모든 트럭의 무게는 1 이상 weight 이하입니다. 풀이과정 다리를 건너고 있는 트럭의 배열을 passing_trucks, 이미 다리를 건넌 트럭의 배열을 passed_trucks이라 정의한다. passing_trucks배열을 forEach문으로 돌면서 truck.count가 bridge_length와 같으면 해당 트럭을 passing_trucks 배열에서 제거해주고 아니면 truck.count++한다. passing_trucks의 weight의 합이 다리가 견딜 수 있는 무게 weight를 넘지 않으면 다리에 트럭을 하나 더 보낸다. 이 과정을 passed_trucks배열의 크기가 처음 대기트럭 배열의 크기와 같아질 때까지 반복한다. while문을 반복할 때마다 answer++한다. passing_trucks배열에서 제거해 줄 때 실수했던 부분이 처음에는 passing_trucks.splice(index, 1) 이렇게 바로 배열에서 제거했더니 원본 배열 자체가 변경되어 처음 passing_trucks의 길이만큼 forEach문을 충분히 돌지 못했다. 그래서 forEach문을 돌 때는 truck.count === bridge_length인 트럭의 인덱스만 저장해뒀다가 forEach문이 끝난 뒤에 passing_trucks에서 제거해주었다. 나의 풀이 function solution(bridge_length, weight, truck_weights) { let answer = 0 const passing_trucks = [] const passed_trucks = [] const len = truck_weights.length while (passed_trucks.length &lt; len) { // 브릿지를 다 지났는지 체크 아니면 +1 let passedTruckIndex = null passing_trucks.forEach((truck, index) =&gt; { if (truck.count === bridge_length) { //passing_trucks.splice(index, 1) passedTruckIndex = index passed_trucks.push(truck) } else { truck.count++ } }) if (passedTruckIndex !== null) { passing_trucks.splice(passedTruckIndex, 1) } // 트럭이 더 올라올 수 있으면 passing_trucks에 추가 const first = truck_weights[0] if (sumPassingTrucksWeights(passing_trucks) + first &lt;= weight) { const item = { weight: truck_weights.shift(), count: 1 } passing_trucks.push(item) } answer++ } return answer}function sumPassingTrucksWeights(passing_trucks) { const sum = passing_trucks.reduce((a, b) =&gt; { return a + b.weight }, 0) return sum}","link":"/2019/12/01/Programming/Algorithm/passed-trucks/"},{"title":"정렬 - H-index","text":"문제 H-Index는 과학자의 생산성과 영향력을 나타내는 지표입니다. 어느 과학자의 H-Index를 나타내는 값인 h를 구하려고 합니다. 위키백과1에 따르면, H-Index는 다음과 같이 구합니다. 어떤 과학자가 발표한 논문 n편 중, h번 이상 인용된 논문이 h편 이상이고 나머지 논문이 h번 이하 인용되었다면 h가 이 과학자의 H-Index입니다. 어떤 과학자가 발표한 논문의 인용 횟수를 담은 배열 citations가 매개변수로 주어질 때, 이 과학자의 H-Index를 return 하도록 solution 함수를 작성해주세요. 제한사항 과학자가 발표한 논문의 수는 1편 이상 1,000편 이하입니다. 논문별 인용 횟수는 0회 이상 10,000회 이하입니다. 입출력 예 citations return [3, 0, 6, 1, 5] 3 입출력 예 설명 이 과학자가 발표한 논문의 수는 5편이고, 그중 3편의 논문은 3회 이상 인용되었습니다. 그리고 나머지 2편의 논문은 3회 이하 인용되었기 때문에 이 과학자의 H-Index는 3입니다. 풀이과정 논문 배열을 인용횟수 내림차순으로 정렬한다. i번째 논문이 인용된 횟수 &gt;= i+1인 케이스의 최대값을 찾아내면 된다~! 논문인용 배열이 [0, 0, 0] 인 경우 결과값은 0이 나와야 한다. 정렬후 첫번째 값이 0인 케이스를 예외처리 해주었다. sorted[i] &gt;= i + 1가 아닌 경우를 발견하면 무의미하게 for문을 돌지 않고 바로 break하도록 했다. 처음에는 오름차순으로 정렬해서 [0, 1, 3, 5, 6] i번째 논문의 인용횟수 === i+1인 케이스를 찾을려고 했는데 [22, 42] =&gt; 2일 경우 예외가 발생했다. 입출력 예제의 경우처럼 i번째 논문의 인용횟수 === i+1인 케이스도 있지만 그렇지 않은 경우도 있을 수 있다는 걸 캐치하지 못했었다. 나의 풀이 function solution(citations) { var answer = 0 const sorted = citations.sort((a, b) =&gt; b - a) const len = sorted.length if (sorted[0] === 0) { return answer } for (let i = 0; i &lt; len; i++) { if (sorted[i] &gt;= i + 1) { answer = i + 1 } else { break } } return answer}","link":"/2019/11/27/Programming/Algorithm/sort-h-index/"},{"title":"스택/큐 - 프린터","text":"문제 일반적인 프린터는 인쇄 요청이 들어온 순서대로 인쇄합니다. 그렇기 때문에 중요한 문서가 나중에 인쇄될 수 있습니다. 이런 문제를 보완하기 위해 중요도가 높은 문서를 먼저 인쇄하는 프린터를 개발했습니다. 이 새롭게 개발한 프린터는 아래와 같은 방식으로 인쇄 작업을 수행합니다. 1. 인쇄 대기목록의 가장 앞에 있는 문서(J)를 대기목록에서 꺼냅니다. 2. 나머지 인쇄 대기목록에서 J보다 중요도가 높은 문서가 한 개라도 존재하면 J를 대기목록의 가장 마지막에 넣습니다. 3. 그렇지 않으면 J를 인쇄합니다. 예를 들어, 4개의 문서(A, B, C, D)가 순서대로 인쇄 대기목록에 있고 중요도가 2 1 3 2 라면 C D A B 순으로 인쇄하게 됩니다. 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 알고 싶습니다. 위의 예에서 C는 1번째로, A는 3번째로 인쇄됩니다. 현재 대기목록에 있는 문서의 중요도가 순서대로 담긴 배열 priorities와 내가 인쇄를 요청한 문서가 현재 대기목록의 어떤 위치에 있는지를 알려주는 location이 매개변수로 주어질 때, 내가 인쇄를 요청한 문서가 몇 번째로 인쇄되는지 return 하도록 solution 함수를 작성해주세요. 제한사항 현재 대기목록에는 1개 이상 100개 이하의 문서가 있습니다. 인쇄 작업의 중요도는 1~9로 표현하며 숫자가 클수록 중요하다는 뜻입니다. location은 0 이상 (현재 대기목록에 있는 작업 수 - 1) 이하의 값을 가지며 대기목록의 가장 앞에 있으면 0, 두 번째에 있으면 1로 표현합니다. 풀이과정 처음에 문제해석을 잘못했다. 첫번째 프린트보다 중요도가 큰 게 있으면 바로 중요도가 가장 높은 것을 프린트하는 줄 알고 const index = array.indexOf(biggerOne)array.splice(index, 1) 로 가장 중요도가 높은 프린트물을 배열에서 제거했다. 원래 문제의 조건은 가장 첫번째 프린트물이 가장 중요도가 높지않을 경우, 제일 끝으로 push한다이다. 알고리즘 문제를 풀면서 문제의 규칙, 조건들을 잘못 해석하지 않고 제대로 파악하는 것이 중요하겠다. 일단 priorities배열에 같은 중요도의 프린트물도 있으니까 구분을 짓기 위해 index와 중요도값을 가지는 data를 맵핑한 배열을 만든다. priorities의 요소 하나하나씩 비교하는 경우의 수 (len * (len - 1))만큼 forloop을 돌린다. 첫 번째 요소보다 중요도가 높은 것이 있으면 배열에 shift메소드를 사용해서 첫 요소를 제거하고 push를 통해 제일 마지막에 넣어준다. 그리고 첫번째 요소보다 더 중요도가 높은 것이 없다면 shift를 사용해 배열에서 제거해주고 answer값을 +1해준다. 만약 제거된 아이템이 내가 찾으려던 아이템과 동일하면 forloop을 나온다. 나의 풀이 function solution(priorities, location) { var answer = 0 const newpriorities = priorities.map((data, index) =&gt; { return { data, index } }) const myItem = newpriorities[location] const len = newpriorities.length for (let i = 0; i &lt; (len * (len - 1)) / 2; i++) { let firstItem = newpriorities[0] const biggerOne = newpriorities.find(priority =&gt; priority.data &gt; firstItem.data) if (biggerOne) { newpriorities.shift() newpriorities.push(firstItem) } else { newpriorities.shift() answer++ if (firstItem.data === myItem.data &amp;&amp; firstItem.index === myItem.index) { break } } } return answer}","link":"/2019/11/29/Programming/Algorithm/printer/"},{"title":"Rotate List","text":"문제 링크드리스트가 주어졌을 때, k만큼 오른쪽으로 이동해라. 이 때 k는 음이 아닌 수. Example 1: Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL, k = 2 Output: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Explanation: rotate 1 steps to the right: 5-&gt;1-&gt;2-&gt;3-&gt;4-&gt;NULL rotate 2 steps to the right: 4-&gt;5-&gt;1-&gt;2-&gt;3-&gt;NULL Example 2: Input: 0-&gt;1-&gt;2-&gt;NULL, k = 4 Output: 2-&gt;0-&gt;1-&gt;NULL Explanation: rotate 1 steps to the right: 2-&gt;0-&gt;1-&gt;NULL rotate 2 steps to the right: 1-&gt;2-&gt;0-&gt;NULL rotate 3 steps to the right: 0-&gt;1-&gt;2-&gt;NULL rotate 4 steps to the right: 2-&gt;0-&gt;1-&gt;NULL 출처 - https://leetcode.com/problems/rotate-list/ 풀이 과정 처음 생각했던 방법은 링크드리스트의 마지막요소의 전 요소를 찾은 후, 그 요소의 next를 null로 만들고 마지막 요소를 새로운 head로 만드는 방식이었다. 하지만 이렇게 할 경우, [1,2,3] k=2000000 이런 인풋에서는 시간초과오류가 났다. 실행시간이 N(n * k), n=length of list이다. 이 방법이 아니라 새로운 방법으로 풀어야 했다. var rotateRight = function(head, k) { let last = head let newFirst = null // 빈 리스트일경우, 리스트 크기가 1일 경우는 제외 if (head &amp;&amp; head.next) { while (k) { last = findBeforeLastItem(head) newFirst = last.next newFirst.next = head last.next = null head = newFirst k-- } } return head}// 마지막 전 원소 찾기const findBeforeLastItem = last =&gt; { while (last.next &amp;&amp; last.next.next) { last = last.next } return last} 릿코드 디스커스에서 circular linked list를 이용하면 쉽게 풀 수 있다는 글을 보고 원형연결리스트를 만들어보았다. 이 때, tail값을 미리 저장해둔다. 원형연결리스트를 만들면서 리스트의 길이(len)도 체크한다. k만큼 rotate을 했을 때의 tail의 next는 새로운 head가 되고, tail.next = null로 할당해주면 다시 선형 linked list가 된다. k가 len보다 커지면 똑같은 연산이 반복되므로 나머지 연산을 이용해 반복을 줄인다.k % len 우리가 현재 찾는 값은 rotate했을 때의 tail값이다. let n = len - (k % len) 이 계산식을 통해 구해진 n번 만큼 tail을 이동하면 구할 수 있다. 결과값으로 구해진 tail의 next값이 리턴할 링크드 리스트의 head이고, tail.next는 다시 null로 세팅한다. 이렇게 계산하면 실행시간은 N(n)이 되겠다. 원형연결리스트를 이용하면 문제가 풀린다는 힌트를 얻고도 문제를 해결하는 데 꽤 많이 시간을 쏟았다. let n = len - (k % len) 이 계산식을 도출해내기까지 생각이 많이 필요했다. 리스트 길이 이상으로 rotate을 하면 반복이 되므로 나머지연산(k % len)으로 반복횟수를 줄이고, tail을 찾는 것이기 때문에 (k % len)번이 아니라 len - (k % len)번 while문을 돌려야 한다. 나의 풀이 var rotateRight = function(head, k) { let node = head let tail = head let len = 0 // 빈 리스트 제외 if (node) { len++ while (node.next) { node = node.next len++ } // circlular linked list 만들기 tail = node tail.next = head let n = len - (k % len) while (n) { tail = tail.next n-- } head = tail.next tail.next = null return head } else { return node }}","link":"/2019/12/10/Programming/Algorithm/rotate-list/"},{"title":"top-k-frequent-elements","text":"문제 빈 배열이 아닌 정수 배열이 주어졌을 때, 가장 많이 등장한 요소 k개를 가지는 배열로 리턴하세요. Example 1: Input: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2: Input: nums = [1], k = 1 Output: [1] Note: You may assume k is always valid, 1 ≤ k ≤ number of unique elements. Your algorithm’s time complexity must be better than O(n log n), where n is the array’s size. 출처 - https://leetcode.com/problems/top-k-frequent-elements/ 풀이과정 일단 주어진 배열을 forloop으로 돌면서 numsObj에 요소별로 frequency 값을 셋팅한다. { 1: 3, 2: 2, 3: 1} 빈 배열 buckets을 선언한다. frequency를 index로 하고 값으로 numsObj의 key를 배열 형태로 넣어준다. 마지막으로 buckets배열을 뒤에서부터 돌면서 가장 frequency가 높은 값을 answer배열에 넣어준다. answer배열의 크기가 k가 되면 결과값을 리턴한다. 시간 복잡도는 O(n)이므로 조건에 맞는다. (frequency가 겹치는 경우가 거의 없다고 가정하면. 혹은 frequency가 겹치는 경우가 있어도 n값보다는 훨씬 작은 수이기 때문에 무시한다.) 나의 풀이 /** * @param {number[]} nums * @param {number} k * @return {number[]} */var topKFrequent = function(nums, k) { let answer = [] let numsObj = {} nums.forEach(item =&gt; { if (numsObj[item]) { numsObj[item]++ } else { numsObj[item] = 1 } }) const keys = Object.keys(numsObj) buckets = [] for (let i = 0; i &lt; keys.length; i++) { const freq = numsObj[keys[i]] if (buckets[freq]) { buckets[freq].push(keys[i]) } else { buckets[freq] = [keys[i]] } } for (let i = buckets.length - 1; i &gt; -1; i--) { if (buckets[i]) { for (let j = 0; j &lt; buckets[i].length; j++) { answer.push(Number(buckets[i][j])) if (answer.length === k) { break } } } if (answer.length === k) { break } } return answer}","link":"/2019/12/24/Programming/Algorithm/top-k-frequent-elements/"},{"title":"동적계획법 - 타일 장식물","text":"문제 대구 달성공원에 놀러 온 지수는 최근에 새로 만든 타일 장식물을 보게 되었다. 타일 장식물은 정사각형 타일을 붙여 만든 형태였는데, 한 변이 1인 정사각형 타일부터 시작하여 마치 앵무조개의 나선 모양처럼 점점 큰 타일을 붙인 형태였다. 타일 장식물의 일부를 그리면 다음과 같다. 그림에서 타일에 적힌 수는 각 타일의 한 변의 길이를 나타낸다. 타일 장식물을 구성하는 정사각형 타일 한 변의 길이를 안쪽 타일부터 시작하여 차례로 적으면 다음과 같다. [1, 1, 2, 3, 5, 8, .] 지수는 문득 이러한 타일들로 구성되는 큰 직사각형의 둘레가 궁금해졌다. 예를 들어, 처음 다섯 개의 타일이 구성하는 직사각형(위에서 빨간색으로 표시한 직사각형)의 둘레는 26이다. 타일의 개수 N이 주어질 때, N개의 타일로 구성된 직사각형의 둘레를 return 하도록 solution 함수를 작성하시오. 제한 사항 N은 1 이상 80 이하인 자연수이다. 풀이 과정 N개의 타일로 구성된 직사각형의 둘레는 N변과 N-1변을 각각 2배 해주면 구할 수 있다. [1, 1, 2, 3, 5, 8, .] 정사각형 타일 한 변의 길이를 나열한 배열의 모습을 보면 피보나치 수열의 모습과 동일하다. 그래서 처음에는 피보나치 함수를 아래와 같이 만들었더니 효율성 검사를 통과하지 못했다. function fibonacci(n) { if (n &lt; 2) { return 1 } else { return fibonacci(n - 1) + fibonacci(n - 2) }} n=5의 경우를 보면, fibonacci(5) = fibonacci(4) + fibonacci (3) -&gt; fibonacci(2) + fibonacci(3) + fibonacci(2) + fibonacci(1) -&gt; fibonacci(1) + fibonacci(1) + fibonacci(2) + fibonacci(1) + fibonacci(1) + fibonacci(1) + fibonacci(1) 이렇게 동일한 계산이 반복된다는 것을 알 수 있다. 이미 계산된 값에 대해서는 다시 재계산이 일어나지 않도록 메모이제이션*을 했다. 이전에 계산된 값이 있으면 그 값을 가져다 쓰도록 코드를 수정했다. (*메모이제이션은 컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로써 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술이다. 동적 계획법의 핵심이 되는 기술) 나의 풀이 const memo = []function solution(N) { return 2 * (fibonacci(N) + fibonacci(N - 1))}function fibonacci(n) { if (n &lt; 2) { return 1 } else if (memo[n]) { return memo[n] } else { return (memo[n] = fibonacci(n - 1) + fibonacci(n - 2)) }}","link":"/2019/12/03/Programming/Algorithm/tile-ornaments/"},{"title":"스택/큐 - 탑","text":"문제 수평 직선에 탑 N대를 세웠습니다. 모든 탑의 꼭대기에는 신호를 송/수신하는 장치를 설치했습니다. 발사한 신호는 신호를 보낸 탑보다 높은 탑에서만 수신합니다. 또한, 한 번 수신된 신호는 다른 탑으로 송신되지 않습니다. 예를 들어 높이가 6, 9, 5, 7, 4인 다섯 탑이 왼쪽으로 동시에 레이저 신호를 발사합니다. 그러면, 탑은 다음과 같이 신호를 주고받습니다. 높이가 4인 다섯 번째 탑에서 발사한 신호는 높이가 7인 네 번째 탑이 수신하고, 높이가 7인 네 번째 탑의 신호는 높이가 9인 두 번째 탑이, 높이가 5인 세 번째 탑의 신호도 높이가 9인 두 번째 탑이 수신합니다. 높이가 9인 두 번째 탑과 높이가 6인 첫 번째 탑이 보낸 레이저 신호는 어떤 탑에서도 수신할 수 없습니다. 송신 탑(높이) 수신 탑(높이) 5(4) 4(7) 4(7) 2(9) 3(5) 2(9) 2(9) - 1(6) - 맨 왼쪽부터 순서대로 탑의 높이를 담은 배열 heights가 매개변수로 주어질 때 각 탑이 쏜 신호를 어느 탑에서 받았는지 기록한 배열을 return 하도록 solution 함수를 작성해주세요. 제한 사항 heights는 길이 2 이상 100 이하인 정수 배열입니다. 모든 탑의 높이는 1 이상 100 이하입니다. 신호를 수신하는 탑이 없으면 0으로 표시합니다. 풀이과정 위 문제에서 어떻게 스택과 큐의 자료구조를 사용해야할 지 몰라 일단 생각나는대로 풀어봤다. heights를 forloop안에 i번보다 앞에 있는 요소들과 비교하는 forloop을 한번 더 돌렸다. heights[j] &gt; heights[i]인 케이스가 있으면 그 때의 j+1값을 푸시했고, 해당 사항이 없으면 0을 푸시했다. 나의 풀이 function solution(heights) { var answer = [] for (let i = 0; i &lt; heights.length; i++) { for (let j = i - 1; j &gt;= 0; j--) { if (heights[j] &gt; heights[i]) { answer.push(j + 1) break } } if (answer.length !== i + 1) { answer.push(0) } } return answer}","link":"/2019/11/28/Programming/Algorithm/tower/"},{"title":"Unique Number of Occurrences","text":"문제 정수 배열이 주어질 때, 배열의 각 값의 출현 횟수가 유니크한 경우에만 true를 리턴하는 함수를 작성하세요. Example 1: Input: arr = [1,2,2,1,1,3] Output: true Explanation: The value 1 has 3 occurrences, 2 has 2 and 3 has 1. No two values have the same number of occurrences. Example 2: Input: arr = [1,2] Output: false Example 3: Input: arr = [-3,0,1,-3,1,1,1,-3,10,0] Output: true Constraints: 1 &lt;= arr.length &lt;= 1000 -1000 &lt;= arr[i] &lt;= 1000 출처 - https://leetcode.com/problems/unique-number-of-occurrences/ 풀이과정 일단 각 숫자별로 출현횟수를 obj에 담고, obj의 값만 배열로 만든다. 출현횟수 배열을 돌면서 출현횟수 값이 똑같은 경우가 있는지를 filter 함수를 통해 dup에 담고 dup.length &gt; 1 하다면 동일한 출현횟수가 있는 경우이므로 false를 리턴, 아니면 true를 리턴한다. 나의 풀이 /** * @param {number[]} arr * @return {boolean} */var uniqueOccurrences = function(arr) { let obj = {} for (let i = 0; i &lt; arr.length; i++) { const value = arr[i] if (obj[value]) { obj[value] += 1 } else { obj[value] = 1 } } const list = Object.values(obj) let ret = true for (let i = 0; i &lt; list.length; i++) { const dup = list.filter(item =&gt; item === list[i]) if (dup.length &gt; 1) { ret = false break } } return ret}","link":"/2019/12/14/Programming/Algorithm/unique-number-of-occurrences/"},{"title":"ElasticSearch 스냅샷 생성 및 복원","text":"AWS elasticsearch에서 자동 백업을 지원하지만 이걸 복원하려면 AWS Support에 직접 요청하는 방식이라 원하는 시점에 복원하지 못할 수도 있다. 또한 elasticsearch 버전을 올리기위해 마이그레이션을 할 때는 새로운 elasticsearch를 생성하고 직접 백업 및 복원을 해야한다. =&gt; 수동으로 스냅샷 생성하고 복원하는 작업이 필요하다. 1. 준비사항 1-1. 스냅샷이 저장될 S3 만들기 버킷이름 정하기 되도록 해당 ES와 동일한 리전을 선택 나머지는 기본설정값으로 1-2. IAM Role 생성 IAM -&gt; Role(역할) - Create New Role(역할만들기) AWS 서비스 - EC2 - &quot;다음&quot;버튼 Attach Policy에서는 아무것도 선택하지 않고 “다음” 검토 - 원하는 역할이름 (EsSnapshotRole)입력하고 - 역할만들기 신뢰관계 - 신뢰 관계 편집 // 신뢰 관계{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Effect\": \"Allow\", \"Principal\": { \"Service\": \"es.amazonaws.com\" }, \"Action\": \"sts:AssumeRole\" } ]} 1-3. IAM Policy 생성 후 연결 정책 생성 버튼 시각적편집기/JSON 중에서 JSON탭 선택 아래와 같은 데이터 넣음 (s3-bucket-name에 본인이 만든 버킷이름 넣음) { \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [\"s3:ListBucket\"], \"Effect\": \"Allow\", \"Resource\": [\"arn:aws:s3:::s3-bucket-name\"] }, { \"Action\": [\"s3:GetObject\", \"s3:PutObject\", \"s3:DeleteObject\"], \"Effect\": \"Allow\", \"Resource\": [\"arn:aws:s3:::s3-bucket-name/*\"] } ]} 정책검토 클릭 - 정책 이름( EsCosmoshub2SnapshotPolicy) 입력 후, 정책 생성 1-4. IAM 정책과 역할 연결 IAM - Role - 아까 만든 역할 클릭 정책연결 클릭 미리 만든 정책검색 - 체크박스 클릭 - 정책연결 2. 스냅샷 생성 2-1. 스냅샷 저장소 생성 AWS elasticsearch service에서는 스냅샷 저장소 생성을 curl 명령어로 할 수 없음. python을 이용하거나 POSTMAN 이용. 포스트맨을 이용해보겠다. 포스트맨 Authorization설정에 type을 AWS Signature를 선택한 후 접근권한이 있는 계정 정보(AccessKey, SecretKey) 및 Advanced정보(AWS region, Service name)를 넣는다. PUT elasticsearch-domain-endpoint/_snapshot/{스냅샷 레포 이름}// body{ &quot;type&quot;: &quot;s3&quot;, &quot;settings&quot;: { &quot;bucket&quot;: &quot;s3버킷이름&quot;, &quot;region&quot;: &quot;ap-northeast-2&quot;, &quot;role_arn&quot;: &quot;arn:aws:iam::793775630439:role/역할이름&quot; }}// 아래와 같이 응답오면 okay{ &quot;acknowledged&quot;: true} 만약 위의 과정에서 아래와 같은 에러가 발생한다면 신뢰관계 - 신뢰 관계를 편집해줘야한다. { &quot;error&quot;: { &quot;root_cause&quot;: [ { &quot;type&quot;: &quot;repository_verification_exception&quot;, &quot;reason&quot;: &quot;[kava_backup] path is not accessible on master node&quot; } ], &quot;type&quot;: &quot;repository_verification_exception&quot;, &quot;reason&quot;: &quot;[kava_backup] path is not accessible on master node&quot;, &quot;caused_by&quot;: { &quot;type&quot;: &quot;i_o_exception&quot;, &quot;reason&quot;: &quot;Unable to upload object [tests-Yf1EOrcpS_iSjfSL6PVFwQ/master.dat] using a single upload&quot;, &quot;caused_by&quot;: { &quot;type&quot;: &quot;a_w_s_security_token_service_exception&quot;, &quot;reason&quot;: &quot;a_w_s_security_token_service_exception: Access denied (Service: AWSSecurityTokenService; Status Code: 403; Error Code: AccessDenied; Request ID: f2bf46e0-a6d4-11e9-a6e8-897239377f7d)“ } } }, &quot;status&quot;: 500} 2-2. 스냅샷 생성 PUT {es주소}/_snapshot/{스냅샷 레포 이름}/{스냅샷 이름}{&quot;accepted&quot;: true}// 라고 뜨면 생성완료 GET {es주소}/_snapshot/{스냅샷 레포 이름}/{스냅샷 이름}// 통해서 완료여부 확인가능 3. 스냅샷 복원 POST https://{es주소}/_snapshot/{스냅샷 레포 이름}/{복원할 스냅샷 이름}/_restore 스냅샷 생성할 때와 마찬가지로 실행하자마자 반환값이 나오지만 뒤에서 계속 복원중인 상태. 복원 진행중일때는 클러스터 상태가 Red이고 원래의 클러스터 상태로 돌아오므로 클러스터 상태를 통해 복원이 완료됐는지 체크 [참고] 스냅샷 생성에 필요한 시간은 Amazon ES 도메인의 크기에 따라 다르다. 스냅샷 작업이 길게 실행되면 일반적으로 다음과 같은 오류가 발생한다. &quot;504 GATEWAY_TIMEOUT. &quot; elasticsearch에 저장하는 데이터가 보통 대용량이기 때문에 자주나타나는 에러다 무시하고 작업이 성공적으로 완료될 때까지 기다리면 된다. GET https://{es주소}/_cluster/health 3-1. 다른 elasticsearch로 스냅샷을 복원하는 경우 elasticsearch 를 마이그레이션 하거나 다른 elasticsearch 클러스터에 복원하려는 경우 새로운 elasticserach 에 스냅샷 저장소만 생성하면 된다. 스냅샷 저장소를 앞서 생성한 스냅샷 저장소와 동일한 옵션으로 생성하면 같은 S3를 바라보게 되므로 복원도 바로 된다 3-1-1. 새로 생성한 ES에 snapshot 저장소 생성 PUT https://{새로운 es 주소}/_snapshot/{스냅샷 레포 이름}// body (복원하려는 스냅샷 저장소 정보와 동일하게){ &quot;type&quot;: &quot;s3&quot;, &quot;settings&quot;: { &quot;bucket&quot;: &quot;버킷이름&quot;, &quot;region&quot;: &quot;ap-northeast-2&quot;, &quot;role_arn&quot;: &quot;arn:aws:iam::793775630439:role/{role이름}&quot; }} 3-1-2. 복원요청 POST https://{새로운es주소}/_snapshot/{스냅샷 레포 이름}/{스냅샷 이름}/_restore{&quot;accepted&quot;: true}// 응답이 위와 같이 오면 복원완료! 아래와 같은 에러 발생시, url 참고 [kava_backup:snap_shot_20190715/reFsXleAQlW7dss3uvNEew] cannot restore index [tx_index] because an open index with same name already exists in the cluster. Either close or delete the existing index or restore the index under a different name by providing a rename pattern and replacement namehttps://aws.amazon.com/ko/premiumsupport/knowledge-center/elasticsearch-kibana-error/ [참고] https://blog.weirdx.io/post/32308?fbclid=IwAR3sC_l3GeImMAKI2ArwtvlxSnoxzBdId8F5_TJdO7cCRqtYmtOREGaz9UA https://m.blog.naver.com/PostView.nhn?blogId=znxcx93&amp;logNo=221305307740&amp;proxyReferer=https%3A%2F%2Fwww.google.com%2F","link":"/2019/12/02/Programming/ElasticSearch/snapshot/"},{"title":"Array - pop, push, shift, unshift","text":"자바스크립트 array method를 정리해보자 자바스크립트에는 배열에 아이템을 추가/삭제할 수 있는 4가지 메소드를 제공한다. pop() 배열에서 마지막 요소를 제거하고 그 요소를 반환한다. 만약 빈 배열에 pop()을 호출하면, undeifined를 반환한다. 원본배열 자체가 변한다. const fruits = [\"banana\", \"apple\", \"grape\", \"pineapple\"]const popped = fruits.pop()console.log(popped) // pineappleconsole.log(fruits) // [\"banana\", \"apple\", \"grape\"] push() 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환한다. pop()과 마찬가지로 원본배열이 바뀐다. const animals = [\"pigs\", \"goats\", \"sheep\"]const count = animals.push(\"cows\")console.log(count) // 4console.log(animals) // (4) [\"pigs\", \"goats\", \"sheep\", \"cows\"]animals.push(\"chickens\", \"cats\", \"dogs\") // 7 shift() 배열에서 첫번째 요소를 제거하고, 제거된 요소를 반환한다. 원본배열 자체가 변한다. 0 번째 위치의 요소를 제거하고 연이은 나머지 값들의 위치를 한칸씩 앞으로 당긴다. 만약 빈 배열에 shift()를 호출하면 undefined 리턴. const fruits = [\"banana\", \"apple\", \"grape\", \"pineapple\"]const firstItem = fruits.shift()console.log(firstItem) // bananaconsole.log(fruits) // (3) [\"apple\", \"grape\", \"pineapple\"] unshift() 새로운 요소를 배열의 맨 앞쪽에 추가하고 새로운 길이를 반환한다. 원본배열이 바뀐다. const fruits = [\"banana\", \"apple\", \"grape\", \"pineapple\"]fruits.unshift(\"mango\", \"tangerine\")// 6console.log(fruits)// (6) [\"mango\", \"tangerine\", \"banana\", \"apple\", \"grape\", \"pineapple\"] [참고] https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/pop","link":"/2019/12/01/Programming/JavaScript/array-method/"},{"title":"화살표 함수(arrow-function)와 function 차이점","text":"function에서 this는 함수 자신을 나타내고, 화살표함수는 this를 따로 변경하지 않는다. (원래 나타내던 this를 그대로 쓴다) 앵귤러의 ts파일에서의 this는 컴포넌트 인스턴스를 의미한다. 앵귤러에서 가끔 function을 이용해야할 경우, 컴포넌트 인스턴스의 변수들을 참조하려면 let _this = this를 이용하면 된다. dismissModal() { let _this = this; $(function() { $(\"#myModal\").on(\"hidden.bs.modal\", function() { _this.userPwd = \"\"; _this.userEmail = \"\"; }); });} function안에서 this를 그냥 쓰면, this는 function 자체를 나타내기 때문에 userPwd과 userEmail이 undefined되었다는 에러가 뜬다. 그래서 let _this = this를 이용해 컴포넌트 인스턴스를 _this에 담아서 function 내부에서 컴포넌트 인스턴스를 참조할 수 있도록 하면 된다.","link":"/2018/05/15/Programming/JavaScript/arrow-function/"},{"title":"NodeJS에서 import 구문 사용하기","text":"NodeJS는 아직 CommonJS 기반 모듈 시스템을 사용하기 때문에 ES6의 import나 export와 같은 키워드는 디폴트로 지원하지 않는다. CommonJS가 제공하는 require방식이 아니라 import키워드를 사용하고 싶다면 아래와 같은 작업이 필요한데, 바벨을 통해 ES6문법으로 작성된 js파일을 ES5 문법으로 변환해주는 작업을 해줘야한다. 1. 필요한 모듈 설치 // babel/cli는 터미널에서 커맨드를 입력해서 Babel을 사용할 때 필요한 모듈yarn add babel-cli --dev// 프리셋은 버전별로 필요 플러그인들을 모아놓은 세트//babel-preset-env 은 그런 프리셋과 플러그인들을 모아 관리하고 있는 모듈yarn add babel-preset-env --devyarn add babel-preset-stage-3 --dev 2. 프로젝트 루트 위치에 바벨 설정 파일 (.babelrc) 생성 // 곧 표준으로 받아들여질 stage-3에 있는 문법을 기준으로 트랜스파일 하겠다고 바벨에서 알려준다.{ \"presets\": [\"env\", \"stage-3\"]} 3. package.json 에 scripts 추가 { \"scripts\": { \"start\": \"babel-node index.js\" }, \"devDependencies\": { \"babel-cli\": \"^6.26.0\", \"babel-preset-env\": \"^1.7.0\", \"babel-preset-stage-3\": \"^6.24.1\" }} 위와 같이 작성 후 yarn start를 하면 index.js 파일이 표준 자바스크립트 문법으로 컴파일되어 실행된다.","link":"/2019/12/07/Programming/JavaScript/nodejs-babel/"},{"title":"material-ui 빌드 최적화 하는 방법","text":"문제상황 import { Button, TextField } from \"@material-ui/core\" 이렇게 import를 하면 Button, TextField만 임포트되는 게 아니라 @material/core에 있는 모든 모듈들이 빌드파일이 포함된다. 딱 사용하려는 모듈만 import를 하려면 추가적으로 처리가 필요하다. 1. 바벨 플러그인 임포트 모듈 설치 yarn add -D babel-plugin-import 2-1. 웹팩을 사용한다면 webpack.config.js 파일 수정 { test: /\\.(js|mjs|jsx|ts|tsx)$/, include: paths.appSrc, loader: require.resolve(\"babel-loader\"), options: { customize: require.resolve(\"babel-preset-react-app/webpack-overrides\"), plugins: [ [ \"babel-plugin-import\", { libraryName: \"@material-ui/core\", // Use \"'libraryDirectory': '',\" if your bundler does not support ES modules libraryDirectory: \"\", camel2DashComponentName: false }, \"core\" ], ... ], ... } }, 2-2. 아니면, 프로젝트 루트 위치에 // .babelrc.jsconst plugins = [ [ \"babel-plugin-import\", { libraryName: \"@material-ui/core\", // Use \"'libraryDirectory': '',\" if your bundler does not support ES modules libraryDirectory: \"esm\", camel2DashComponentName: false }, \"core\" ], [ \"babel-plugin-import\", { libraryName: \"@material-ui/icons\", // Use \"'libraryDirectory': '',\" if your bundler does not support ES modules libraryDirectory: \"esm\", camel2DashComponentName: false }, \"icons\" ]]module.exports = { plugins } [참고] https://material-ui.com/guides/minimizing-bundle-size/#ecmascript","link":"/2019/12/04/Programming/React/material-ui-optimization/"},{"title":"스터디 - 고계 자바스크립트","text":"이번에 정리할 내용은 Chapter 2. 고계 자바스크립트이다. 이 장의 내용 자바스크립트가 함수형 언어로 적합한 이유 자바스크립트는 다중 패러다임 개발이 가능한 언어 불변성 및 변경에 대한 정책 고계함수와 일급 함수 클로저와 스코프 개념 클로저의 활용 왜 자바스크립트인가? 편재성(어디에나 있음) - 동적형식(dynamically typed)이고 객체지향적 범용언어이자 프로그래밍 언어 중에 가장 널리 쓰이면서, 모바일, 웹사이트, 웹서버, 데스크톱, 임베디드 애플리케이션, 심지어 DB에 이르기까지 광범위하게 쓰인다. 아직도 꾸준히 진화, 개선 중이다 - 현재 가장 주력버전인 ES6에서는 화살표함수, 상수, 이터레이터, 프로미스 등 함수형 프로그래밍에 걸맞은 기능이 많이 추가되었다. 함수형 장치가 많이 탑재되었지만, 자바스크립트는 어디까지나 함수형인 동시에 객체지향 언어라는 사실을 명심해야한다. 많은 개발자들이 가변 연산, 명령식 제어구조, 객체 인스턴스의 상태를 변경하는 코드를 아무렇지 않게 쓰고 있어 진짜 함수형 자바스크립트 코드는 흔치않다. 그럼 먼저 객체지향과 함수형 프로그래밍의 패러다임 차이를 살펴보자. 함수형 대 객체지향 프로그래밍 함수형/객체지향 모두 중대형 시스템 개발에 사용가능하다. 자바스크립트는 이 두 패러다임을 적절히 잘 버무려놓은 언어라 이 둘을 잘 조합해서 사용할 수 있다. 개발자의 개인적인 취향과 해결해야할 문제의 요건에 따라 조합이 달라질 수 있다. 먼저, 함수형/객체지향 두 접근 방법이 서로 어떤 차이점이 있는지 이해해보자. 어떤 학습 관리 시스템의 Student 객체를 간단히 모형화modeling한다고 하자. Student는 클래스나 형식 계층 관점에서 성, 이름, 주소 같은 기본 속성을 포함한 Person의 하위형이라고 볼 수 있다. 추가할 기능이 있으면 Student보다 더 구체화한 형식, CollegeStudent 같은 형식을 만들어 붙이면 된다. ==&gt; 객체지향 프로그램의 핵심이 바로!! 새로운 파생객체를 생성하여 코드를 재사용하는 것! 객체지향과 함수형의 가장 중요한 차이점은 바로 이런 데이터(객체 속성)와 기능(함수)을 조직하는 방법에 있다. 객체지향 프로그래밍 인스턴스 메소드를 통해 가변 상태를 노출하고 조작할 수 있도록, 객체 기반의 캡슐화에 지나치게 의존한 채 가변 상태의 무결성을 유지힌다. 결국 객체의 데이터와 잘게 나뉜(fine-grained) 기능이 단단히 유착되어 응집도가 높은 패키지가 형성된다. 객체지향의 모든 추상화의 주된 형태가 객체이다. 함수형 프로그래밍 호출자caller로부터 데이터를 숨길 필요 없이 소규모의, 아주 단순한 자료형만을 대상으로 움직인다(?) 데이터와 기능을 느슨하게 결합한다. 여러 자료형에 두루 적용 가능하고 굵게 나뉜(coarse-grained)연산에 더 의존한다. 함수는 함수형 패러다임의 주된 추상화 형태이다. 두 패러다임을 잘 활용하려면 객체를 불변 개체entity나 불변 값으로 바라보고 기능을 함수로 분리하여 객체 내에서 작동되게끔 해야한다. 예를 들면, // 메소드는 대개 this로 객체 상태에 접근get fullname() { return [this._firstname, this._lastname].join(' ');}// this는 사실상 전달받은 객체로 교체var fullname = person =&gt; [person.firstname, person.lastname].join(' '); 자바스크립트의 동적 형식언어라 fullname()은 Person의 모든 파생형 객체(또는 firstname, lastname 속성을 가진 객체 전부)에서 잘 작동한다. =&gt; 다형성polymorphic함수를 지원한다. OOP는 (Parent에서 Student가 나오듯) 메소드에 상속 계층을 두고 데이터를 서로 단단히 묶는 일에 열중한다. 반면 FP는 다양한 자료형을 아우르는 일반적인 다형성 함수를 선호하며 this는 가급적 사용하지 않는다. fullname()을 독립형 함수로 분리하면 객체 데이터를 this로 접근할 이유가 사라진다. this를 쓰면 메소드 스코프 밖에 위치한 인스턴스 수준의 데이터에 접근할 수 있어서 부수효과를 일으킬 수 있다. FP로 개발한 코드는 객체 데이터가 특정코드에 종속되지 않아 재사용성, 유지보수성이 좋다. 어떤 사람Person과 거주 국가가 같은 사람을 전부 찾고, 어떤 학생Student과 거주 국가와 다니는 학교가 모두 같은 학생을 전부 찾는 코드를 개발해보자. 객제지향적으로 this와 super로 한 객체와 그 부모 객체가 단단히 결합된 코드가 될 것이다.//Person 클래스peopleInSameCountry(friends) { var result = [] for ( let i in friends ) { var friend = friends[i] if(this.address.country === friend.address.country) { result.push(friend) } } return result} // Student 클래스 studentInSameCountryAndSchool(friends) { // super로 부모클래스에 접근하여 데이터를 받아온다 var closeFriends = super.peopleInSameCountry(friends) var result = [] for ( let i in closeFriends ) { var friend = closeFriends[i] if(firend.school === this.school) { result.push(friend) } } return result } church.studentInSameCountryAndSchool([curry, turing, kleene]) 2. 함수형으로 순수성과 참조 투명성에 기반을 둔 FP방식을 따르면, 상태와 기능을 철저히 분리한 다음 이들을 다시 조합한 새로운 함수로 연산을 추가할 수 있다. 문제를 작은 함수들도 잘게 나눈다.```bash// 학생의 거주 국가와 학교를 비교하는 selector함수var selector = (country, school) =&gt; (student) =&gt; student.address.country === country &amp;&amp; student.school === school;// 원하는 필터 기준을 selector함수로 주입하여 배열 원소를 걸러낸다var findStudentBy = (friends, selector) =&gt; friends.filter(seletor)//findStudentBy는 Person과 연관된 객체, 또 school, country를 조합한 객체를 받아 작동하는 함수다.findStudentBy([curry, turing, church, kleene], selector(&apos;US&apos;, &apos;Princeton&apos;)) 이제 두 패러다임의 차이점이 확실히 보이나요? 객체지향은 데이터와 데이터 관계의 본질에 초점을 두고! 함수형의 관심사는 해야할 일, 즉 기능!! 자바스크립트 객체의 상태 관리 프로그램의 상태state란 어느 한 시점에 찍은 모든 객체에 저장된 데이터의 스냅샷snapshot이다. 자바스크립트는 너무나 동적이어서 언제건 속성을 추가, 삭제, 수정할 수 있다. 데이터를 완전히 캡슐화하고 보호하는 건 개발자가 훈련을 통해 엄격히 지켜야할 목표다!! 객체를 값으로 취급 프로그래밍 언어에서 문자열과 숫자는 처음부터 불변값이라 가장 이해하기 쉬운 자료형이다. 이런 식으로 동작하는 형식들을 값value라고 한다. 1장에서 불변성을 바탕으로 사고하려면 사실상 모든 객체를 값으로 취급해야한다고 했다. 여러 프로그래밍언어는 자바의 final과 같이 객체의 속성을 불변 상태로 고정시키는 장치를 지원한다. 그러나 자바스크립트에서는 자료형의 불변성을 지원하지 않는다. 기본형 값은 불변이지만 기본형을 가리키는 변수 상태가 바뀌니까. 다른 언어를 적어도 흉내라도 내려면 사용자 정의 객체도 마치 처음부터 불변이었던 것 처럼 작동시킬 수 있어야한다. 상수 레퍼런스 constant reference는 ES6부터 추가된 const 키워드로 선언한다. 값을 재할당하거나 레퍼런스를 다시 선언할 수 없다. const gravity_ms = 0.806gravity_ms = 20 // 에러발생 하지만 const로는 FP가 요구하는 수준의 불변성을 실현하기 어렵다. const student = new Student('Mina', 'Choi', '111-2222', 'Princeton')student.lastname = 'Kim' //속성값이 바뀐다. 더 업격한 불변성 정책이 필요하다!! 객체 구조가 단순하다면 값 객체 패턴 value-object pattern도 괜찮은 방안이다. 값 객체는 객체의 동등성equality가 항등성identity나 레퍼런스가 아닌, 오직 값에 따라 좌우되는 객체! 일단 값 객체를 선언한 이후에 그 상태는 절대 변하지 않는다. function zipCode(code, location) { let _code = code let _location = location return { code: function() { return _code }, location: function() { return _location }, fromString: function(str) { let parts = str.split('-') // 새로운 객체를 반환 return zipCode(parts[0], parts[1]) }, toString: function() { return _code + '-' + _location } }}const princetonZip = zipCode('08544', '3345')princetonZip.toString() // '08544-3345' 메소드를 일부만 호출자caller에게 공개하고, _code, _location을 의사-프라이빗pseudo-private 변수처럼 다루는 객체 리터럴 인터페이스object literal interface를 반환하는 식으로 자바스크립트 함수를 이용하면 우편번호의 내부 상태 접근을 차단할 수 있다. 값 객체는 함수형 프로그래밍의 영향을 받은 객체지향 디자인 패턴으로, 서로 다른 패러다임이 상호 보완적인 관계를 유지할 수 있음을 보여주는 실례다. 하지만 실세계의 문제를 전부 값 객체로 모형화modeling하기엔 충분치 않다. 다행히 자바스크립트에는 Object.freeze()라는 멋진 방법이 있다. 가동부를 깊이 동결 Object.freeze()함수는 writable 속성을 false로 셋팅해서 객체 상태를 못 바꾸게 동결한다. const student = Object.freeze(new Student('Mina', 'Choi', '111-2222', 'Princeton'))student.lastname = 'Kim' // 에러발생!! Cannot assign to read only property!! Object.freeze()는 상속한 속성까지 고정하므로 Student 인스턴스를 동결하면 그 부모인 Person이 물려준 속성까지 모두 같은 방법으로 동결한다. 단, 중첩된 객체 속성까지 동결하는 건 불가능 Object.freeze()는 얕은 연산이라서 확실히 동결하고 싶을 때는 일일이 수작업으로 동결해야한다. // 재귀함수로 객체를 깊이 동결var isObject = val =&gt; val &amp;&amp; typeof val === 'object'function deepFreeze(obj) { if(isObject(obj) //아직 동결되지 않은 객체만 동결 &amp;&amp; !Object.isFrozen(obj)) { Object.keys(obj).forEach(name =&gt; deepFreeze(obj[name])) //루트 객체 동결 Object.freeze(obj) } return obj} BUT!! 상태를 전혀 바꾸지 않는 애플리케이션이란 그리 현실적이지 않다.! 따라서 복잡다기함을 줄인다는 차원에서 원본 객체에서 새 객체를 만드는 엄격한 정책을 허용하면 크게 도움될거다. 객체 그래프를 렌즈로 탐색/수정 함수형으로 접근해서 객체의 불변 상태를 한곳에서 관리하는 렌즈lense라는 기법 // 작업중… 함수 함수형 프로그래밍에서 함수는 작업의 기본 단위! 함수function은 () 연산자를 적용하여 평가할 수 있는 모든 호출 가능 표현식을 가리키며, 호출자caller에게 계산한 값 또는 undefined를 반환한다. FP의 함수는 사용 가능한 결과를 낼 경우에만 유의미하다. 이 책에서는 표현식expression(값을 내는 함수)과 구문statement(값을 내지 않는 함수) 두 용어를 구분한다. 함수를 일급 시민으로 자바스크립트 함수는 실제로 객체이기 때문에 일급first-class이며 일급시민이라고도 한다. // 함수를 선언하는 방법1. function multiplier(a, b) { return a * b }2. const square = function (x) { // 익명함수 return x * x } const sqaure = x =&gt; x * x // 람다표현식 함수를 호출할 때는 square(2) 함수 객체 자체를 출력하려면 sqaure // 객체 속성에서 메소드 형태로 할당할 수도 있다. const obj = { method: function (x) { return x * x } }3. 많이 쓰이지는 않지만 생성자를 통해 함수를 인스턴스화 하는 방법도 있다. const multiplier = new Function('a', 'b', 'return a * b') multiplier(2, 3) // 6 자바스크립트 함수는 모두 Function 형식의 인스턴스다. 함수의 length 속성은 정규 매개변수 개수를 나타내고, apply(), call() 메소드는 함수를 주어진 콘텍스트로 호출한다. 익명함수는 어떤 함수의 기능을 확장하거나 특화시킬 때 인수로 전달한다. 예를 들어, Array.sort는 비교자comparator함수 객체를 인수로 받고, sort는 기본적으로 원소를 문자열로 바꾼 후 유니코드 값을 기준으로 자연정렬natural sorting한다. // 기본 sortconst fruit = ['Coconut', 'apples']fruit.sort() // ['Coconut', 'apples']// 커스텀people.sort((p1, p2) =&gt; p1.getAge() - p2.getAge() // comparator 함수) sort() 같은 자바스크립트 함수는 값을 할당할 수 있으면서 다른 함수도 인수로 받을 수 있으므로 고계함수 범주에 속한다. 고계함수 함수도 작동 원리는 일반 객체와 같아서 함수를 인수로 전달하거나 함수를 반환받을 수 있다. 이런 함수를 고계함수higher-order function이라고 한다. // 한 함수를 다른 함수의 인자로 넘기는 예function applyOperation(a, b, opt) { return opt(a, b)}const multiplier = (a, b) =&gt; a * bapplyOperation(2, 3, multiplier) // 6// 다른 함수를 반환하는 예function add(a) { return function(b) { return a + b }}add(3)(3) // 6 자바스크립트에서 함수는 일급 + 고계여서 다른 값들과 똑같다!!! 즉, 자신이 받은 입력값을 기반으로 정의된 언젠가는 실행될yet-to-executed 값일 뿐이다. 고계함수를 조합하여 유의미한 표현식을 만들기도 한다. 미국 거주자 명단을 출력하는 프로그램을 생각해보자! // 알기 쉽게 명령형으로 작성하면function printPeopleInTheUs(people) { for ( let i = 0; i &lt; people.length; i++ ) { var thisPerson = people[i] if(thisPersion.address.country === 'US') { console.log(thisPerson) } }}printPeopleInTheUs([p1, p2, p3]) 이것을 고계함수를 사용해서 멋지게 추상화해보면!!! function printPeople(people, action) { for ( let i = 0; i &lt; people.length; i++ ) { action(people[i]) }}function action(person) { if(thisPersion.address.country === 'US') { console.log(thisPerson) }}printPeople(people, action) multiplier, comparator, action 같은 명사로 함수를 명명하는 건 자바스크립트 같은 언어에서 볼 수 있는 독특한 패턴이다. 자바스크립트 함수는 일급이라서 일단 변수에 할당한 뒤 나중에 실행해도 된다. // printPeople를 리팩토링해서 고계함수의 장점을 한 껏 살려보면!!function printPeople(people, selector, printer) { people.forEach(function(person) { if(selector(person)) { printer(person) } })}const inUs = person =&gt; person.address.country === 'US'// 고계함수를 쓰면 선언적 패턴이 점점 늘어나기 시작해서표현식만 봐도 프로그램이 하는 일을 파악할 수 있다.printPeople(people, inUs, console.log) 함수 호출 유형 자바스크립트 함수는 호출 시점의 런타임 콘텍스트, 즉 함수 본체 내부의 this값을 자유롭게 지정할 수 있으며 호출방법도 다양하다. 1. 전역 함수로 호출 : this 레퍼런스는 전역 객체, 또는 undefined(엄격모드에서)function doWork() { this.myVar = '어떤 값'}doWork() // doWork()에서의 this레퍼런스는 전역객체를 가르킨다.2. 메소드로 호출 : this레퍼런스는 항상 메소드를 소유한 객체이다.var obj = { prop: '어떤 속성', getProp: function() { return this.prop // 객체매소드 호출시 this는 소유객체를 가리킨다. }}obj.getProp()3. 앞에 new를 붙여 생성자로 호출 : 새로 만든 객체의 레퍼런스를 암시적으로 반환function MyType(arg) { this.prop = arg // 함수를 new로 호출할 경우 this가 가리키는 것은 방금전 생성되어 반환된 객체}var someVal = new Mytype('어떤 인수') 위에서 보는 바와 같이 this 레퍼런스가 가리키는 대상은 함수를 사용하는 방법에 따라 달라진다. 그러므로 함수가 실행되는 콘텍스트를 잘 살펴야한다. 함수 메서드 자바스크립트 함수는 프로토타입에 소속된 (일종의 상위함수) apply와 call 메소드로도 호출할 수 있다. // 함수를 인수를 받아 그 실행결과를 논리적으로 부정하는 함수function negate(func) { return function() { // Function.apply()로 원본 인수를 넣어 함수실행 return !func.apply(null, arguments) }}function isNull(val) { return val === null}// isNull을 부정하여 isNotNull함수를 정의const isNotNull = negate(isNull)isNotNull(null) // falseisNotNull({}) // true apply는 인수 배열을, call은 인수를 목록으로 받는다. Function.prototype.apply(thisArg, [매개변수 배열])Function.prototype.call(thisArg, arg1, arg2) thisArg가 어떤 객체면 그 객체가 메소드의 호출자로 세팅된다. null이면 전역 함수처럼 작동하는 엄격모드에서 실행하면 실제 null값이 들어간다. 클로저와 스코프 클로저는 함수를 선언할 당시의 환경에 함수를 묶어둔 자료구조이다. 정적스코프static scope, 어휘스코프lexical scope라고도 한다. function zipCode(code, location) { let _code = code let _location = location return { code: function() { return _code }, location: function() { return _location }, fromString: function(str) { let parts = str.split('-') // 새로운 객체를 반환 return zipCode(parts[0], parts[1]) }, toString: function() { return _code + '-' + _location } }}const princetonZip = zipCode('08544', '3345')princetonZip.code() // 08544 위 코드를 보면 zipCode 함수가 반환한 객체 리터럴이 이 함수 스코프 밖에 선언된 변수 _code에 자유롭게 접근할 수 있다. 즉 zipCode 실행 이후에도 그 결과 반환된 객체는 자신을 감싼 함수에 선언되었던 정보를 계속 참조할 수 있다. 함수가 자신을 둘러싼 주변 상태에 접근할 수 있기 때문에 클로저를 이용하면 명확하고 가독성 높은 코드를 작성할 수 있다. 또 클로저는 이벤트 처리 및 콜백, 프라이빗 변수 모방, 그리고 자바스크립트의 일부 약점을 보완하는 용도로 유익하다. 함수 클로저의 작동 규칙은 자바스크립트의 스코핑 규칙과 밀접한 관련이 있다. 스코프는 일련의 변수 바인딩을 한데 모아 변수가 정의된 코드 영역을 확정하는데, 클로저는 함수의 스코프를 상속한 것이다. function makeAddFunction(amount) { // add함수는 makeAddFunction에 바인딩되어 amount변수에 접근가능 function add(number) { return number + amount } return add}var addToTen = makeAddFunction(10)addToTen(10) // 20 위의 예제에서 amount변수는 더이상 활성스코프에 없지만 반환된 함수를 호출하면 여전히 되살릴 수 있다. 중첩된 함수 add가 자신의 계산로직뿐만 아니라 자신을 둘러싼 모든 변수의 스냅샷을 간직하고 있기 때문! 일반적으로 함수의 스코프는 다음 두 가지를 포함 모든 함수 매개변수 (전역 변수를 포함해서) 바깥 스코프에 위치한 모든 변수 //클로저var outputVar = 'Outer'function makeInner(params) { var innerVar = 'Inner' function inner() { console.log(`${outerVar}, ${innerVar}, ${params}이 보여요`) } return inner}var inner = makeInner('Params')inner() // Outer, Inner, Params이 보여요 makeInner가 반환한 함수가 자신이 선언되었던 스코프에 존재했던 변수들을 모두 기억해서 쓰레기통으로 들어가지 않게 붙잡아둔 것! 전역 스코프의 문제점 전역 스코프global scope는 가장 단순하면서, 가장 나쁜 스코프. 전역 스코프에는 어느 함수에도 포함되지 않은 객체 및 변수가 자리하고, 어디에서는 접근가능하다. 그래서 namespace가 충돌할 소지가 높고, override문제도 발생할 수 있다. 전역 데이터는 변수 상태가 언제 어떻게 바뀌는지 머릿속으로 따라가야해서 코드가 많아질수록 복잡도가 높아진다. FP스타일로 개발할 땐 되도록 전역변수는 삼가야한다. 자바스크립트의 함수 스코프 함수 스코프function scope는 자바스크립트가 선호하는 스코프 방식이다. 함수 내부에 선언된 변수는 모두 해당 함수의 지역변수라서 다른 곳에서는 안 보이고, 함수가 반환되는 시점에 이들은 모두 사라진다. function doWork() { let student = new Student() let address = new Address() .... // student와 address는 doWork함수에 바딩인된 지역 변수라서 함수 밖에서는 접근할 수 없다.} 변수 찾는 순서 변수의 함수 스코프를 체크 지역 스코프에 없으면 자신을 감싼 바깥쪽 어휘스코프로 이동해서 전역 스코프에 도달할 때까지 변수 레퍼런스를 찾는다. 그래도 참조하는 대상이 없으면 undefined 의사 블록 스코프 표준 ES5 자바스크립트는 for, while, if, swith처럼 제어 구조를 중괄호 {}로 감싼 블록 수준의 스코프를 지원하지 않는다. function doWork() { if(!myVar) { var myVar = 10 } console.log(myVar) // 10}doWork() myVar변수는 if문 내부에서 선언했지만 if블록 바깥에서도 보인다. 자바스크립트는 내부적으로 변수와 함수 선언부를 현재스코프(여기서는 함수스코프) 제일 위쪽으로 호이스팅hoisting(끌어올림)하기 때문에 이런 일이 발생한다. // 모호한 루프 카운터 문제var arr = [1, 2, 3, 4]function processArr() { function multipleBy10(val) { i = 10 // var i = 10 으로 바꾸면 함수 내부 스코프에 한정되어 루프카운터 i와 충돌하지 않는다. return val * i } // 루프카운터 i는 processArr함수의 최상단으로 이동하여 선언, multipleBy10함수의 클로저에 포함. // 루프카운터가 뜻하지 않게 10으로 변경 for(var i = 0; i &lt; arr.length; i++) { arr[i] = multipleBy10(arr[i]) } return arr}processArr() // [10, 2, 3, 4] ES6부터는 let 키워드로 루프 카운터를 해당 루프블록에 바인딩하여 모호함을 어느정도 극복할 수 있다. // let을 쓰면 호이스팅 문제가 해소되고 i는 제 스코프에 위치한다.for(let i = 0; i&lt;arr.length; i++) { // ....}i // undefined 클로저 응용 클로저를 이용하면 자바스크립트의 독특한 함수 체제를 멋지게 활용할 수 있다. 프라이빗 변수를 모방 다른 프로그래밍 언어에서는 private과 같은 접근제어자로 내부 속성을 셋팅할 수 있다. 자바스크립트에는 이러한 키워드가 없다. 다행히 클로저를 이용하면 비슷하게 흉내낼 수 있다. 위에서 본 zipCode함수가 객체를 반환하는 부분이 그렇다. 객체 리터럴을 반환하고, 이 객체는 자신을 감싼 함수의 지역 변수에 접근하는 메소드가 있다. 하지만 지역 변수 자체는 노출하지 않기 때문에 꽤 그럴싸하게 프라이빗 변수처럼 쓸 수 있다. 전역범위의 데이터 공유를 피하기 위해 전역 namespace를 관리하는 수단으로도 쓰인다. 실제로 자바스크립트 라이브러리, 모듈 개발자는 전체모듈의 프라이빗 메소드와 데이터를 숨길 때 클로저를 활용! 이것을 모듈패턴module-pattern이라고 한다. // 대략적인 모듈의 뼈대var MyModule = (function MyModule(export) { // 에러발생시 스택을 보며 추적할때 IIFE를 식별할 수 있게 함수이름을 붙인다. let _myPrivateVar = \"\" // 두 메소드를 제외하고 프라이빗 변수는 이 함수 바깥에서 접근할 수 없다. export.method1 = function () { // 이 객체 스코프 아래에서 메소드를 전역범위로 표출. 그 결과 의사 이름공간이 생성 } export.method2 = function () { } return export;}(MyModule || {})) // 모든 숨겨진 상태와 메소드를 은밀히 포함한 단일 객체, MyModule.method1()으로 호출 서버 측 비동기 호출 자바스크립트의 일급 고계함수는 다른 함수에 콜백으로 건넬 수 있다. getJSON('/students', (students) =&gt; { getJSON('/students/grades', // 두 응답 모두 처리 grades =&gt; progressGrades(grades), error =&gt; console.log(error.message)) // 점수조회중 발생한에러처리 }, (error) =&gt; { console.log(error.message) // 학생조회중 발생한 에러처리 } ) 고계함수 getJSON은 성공/실패 두 콜백함수를 인수로 받는다. 가상의 블록 스코프 변수를 생성 함수형으로 접근하면 클로저와 함수 스코프를 적극 활용한 forEach를 사용하면 된다. arr.forEach(function(ele, i) { ...}) 이 장을 마치며 자바스크립트는 OOP와 FP 양쪽 다 가능한 팔방미인 언어다. OOP에 불변성을 도입하면 함수형 프로그래밍을 멋지게 쓸 수 있다. 고계/일급 함수는 함수형 자바스크립트를 구사하는 근간이다. 클로저는 정보 감춤, 모듈개발 뿐만 아니라 여러 자료형에 걸쳐 굵게 나뉜 함수에 원하는 기능을 매개변수로 넘기는 등 다양한 쓰임새로 쓰인다. 본 스터디는 “함수형 자바스크립트” 책을 중심으로 진행한다.","link":"/2019/03/07/Programming/JavaScript/study-high-order-javascript/"},{"title":"스터디 - 재사용 가능한, 모듈적인 코드로 - 두번째","text":"지난 글에 이어서 함수 파이프라인을 합성 문제를 더 작고 단순한 하위문제들로 쪼갠 다음 이것들을 다시 조합해서 해결하는 방안을 찾는 능력의 중요성! 함수형 프로그램의 목표는 합성을 유도하는 필요한 자료구조를 얻는 것 함수 합성: 서술과 평가를 구분 함수 합성이란 한마디로 복잡한 작업을 한데 묶어 간단한 작업으로 쪼개는 과정 람다JS 함수 R.compose로 두 순수함수를 합성하는 예제 const R = require(\"ramda\")const _ = require(\"lodash\")const str = `We can only see a short distance ahead but we can see plenty there that needs to be done.`const explode = str =&gt; str.split(/\\s+/)const count = arr =&gt; arr.lengthconst countWords = R.compose(count, explode)console.log(\"countWords(str)\", countWords(str)) 흥미로운 사실은 countWords를 실행하기 전에는 아무 평가도 하지 않는다는 점 합성이 끝나면 해당 인수(countWords에 전달하는 인수)를 받아 호출되기를 기다리는 또다른 함수가 반환된다. 함수의 서술부와 평가부를 분리하는 함수합성의 미학! 합성은 함수의 출력과 입력을 연결하여 진정한 함수 파이프라인을 완성한다. // compose 구현부function compose(/* 함수 */) { let args = arguments let start = args.length - 1 // compose는 실제 인수를 넣고 호출한 또다른함수를 출력 return function() { let i = start // 전달된 인수를 넣고 동적으로 함수를 적용 let result = args[start].apply(this, arguments) while (i--) // 이전 단계 반환값을 다시 인수로 넣고 그다음함수를 계속 반복 result = args[i].call(this, result) return result }} const trim = str =&gt; str.replace(/\\s*|\\s$/g, \"\")const nomarlize = str =&gt; str.replace(/\\-/g, \"\")const validLength = (param, str) =&gt; str.length === paramconst checkLengthSsn = _.partial(validLength, 9)const clearInput = R.compose(nomarlize, trim)const isValidSsn = R.compose(checkLengthSsn, clearInput)console.log(\"clearInput(` 444-44-444`)\", clearInput(` 444-44-444`))console.log(\"isValidSsn(` 444-44-444`)\", isValidSsn(` 444-44-444`)) 이런 개념을 바탕으로 단순한 함수들을 조합해서 전체 프로그램을 구축하는 것. 합성은 결합 가능한 연산 conjunctive operation 이라서 논리 AND 연산자로 원소를 합칠 수 있다. 함수형 라이브러리로 합성 람다JS 같은 함수형 라이브러리는 처음부터 커링을 염두에 두고 모든 함수를 구성했기 때문에 파이프라인으로 합성하면 함수를 다용도로 활용할 수 있다. const students = [\"Rosser\", \"Turing\", \"Kleene\", \"Church\"]const grades = [80, 100, 90, 99]// 가장 똑똑한 학생 구하기const smartestStudent = R.compose(R.head, R.pluck(0), R.reverse, R.sortBy(R.prop(1)), R.zip)const ret = smartestStudent(students, grades)console.log(\"ret\", ret)// 알기 쉽게 함수 별칭을 사용const first = R.headconst getName = R.pluck(0)const reverse = R.reverseconst sortByGrade = R.sortBy(R.prop(1))const combine = R.zipR.compose(first, getName, reverse, sortByGrade, combine) 순수/분순 함수 다루기 불순한 impure한 코드는 실행 후 부수효과가 드러나고 외부 디펜던시 탓에 구성함수의 스코프 바깥에서 데이터에 접근할 수 밖에 없다. 실세계에서는 순수/불순한 코드가 섞여있을 수 밖에 없으므로 양쪽을 확실하게 구분하고 가급적 불순코드를 (가장 좋게는 단일함수로) 격리하는 방법을 찾아야한다. // 커링 및 합성을 응용한 showStudent 프로그램const findObject = R.curry((db, id) =&gt; { // 리팩터링한 find() 메서드는 저장소 객체를 매개변수로 받기 때문에 합성하기 쉽다 const obj = find(db, id) if (obj === null) { throw new Error(`IDrk [${id}]인 객체는 없습니다`) } return obj})// students 객체 저장소를 가리키게 하여 findObject를 부분평가하면 결국 findStudent라는 새함수가 생성const findStudent = findObject(DB(\"students\"))const csv = ({ ssn, firstname, lastname }) =&gt; `${ssn}, ${firstname}, ${lastname}`const append = R.curry((elementId, info) =&gt; { document.querySelector(elementId).innerHTML = info return info})const showStudent = R.compose(append(\"#student-info\"), csv, findStudent, normalize, trim)showStudent(\"4444-4444\") 무인수 프로그래밍 R.compose(first, getName, reverse, sortByGrade, combine) 기존의 함수 선언과 달리 자신의 구성함수의 매개변수를하나도 드러내지 않는다. compose또는 pipe 함수를 사용하면 인수를 선언할 필요가 없기 때문에 간결하면서도 선언적인 무인수 코드를 작성할 수 있다. 무인수스타일코드 이 함수들이 어떤 형식의 인수를 받는지, 전체 표현식 안에서 어떻게 연결되는지 아무 선언도 하지 않는다. const runProgram = R.pipe(R.map(R.toLower), R.uniq, R.sortBy(R.identity))const ret = runProgram([ \"Functional\", \"Programming\", \"CUrry\", \"Memoization\", \"Partial\", \"Curry\", \"Programming\"])console.log(\"ret\", ret) 함수 조합기로 제어흐름을 관리 조건 로직을 구사하거나 다수의 함수를 차례로 실행하는 경우, 애플리케이션의 제어흐름을 관리하는 데 유용한 유틸리티 조합기 - 함수 또는 다른 조합기 같은 기본 장치를 조합하여 제어로직처럼 작동시킬 수 있는 고계함수, 조합기는 대부분 함수형 프로그램이 잘 흘러가도록 조정하는 일이 주임무라 자신의 변수를 선언하거나 비즈니스 로직을 두진않는다. compose, pipe이외에도 종류가 많지만 자주 쓰는 것들 정리해보면 항등(identity) 주어진 인수와 똑같은 값을 반환하는 함수 identity :: (a) -&gt; a 탭(tap) 코드 추가 없이 void 함수(로깅이나 파일/HTML 페이지 쓰기 등)를 연결하여 합성할 때 유용. 자신을 함수에 넘기고 자신을 돌려받는다. tap :: (a -&gt; *) -&gt; a -&gt; a 선택(alternation) - OR-조합기 alt 조합기는 함수 호술시 기본 응답을 제공하는 단순 조건 로직을 수행 함수2개를 받아 false, null, undefined가 아닌 값이 있으면 첫 번째 함수의 결과를, 그렇지 않으면 두번째 함수의 결과를 반환. 순차열(sequence) - S-조합기 함수 순차열의 순회, 2개 또는 더 많은 함수를 인수로 받아, 동일한 값에 대해 각 함수를 차례로 실행하는 또다른 함수를 반환. 이 조합기를 이용하면 서로 연관되어 있지만 독립적인 일련의 연산을 수행할 수 있다. 포크(fork) 또는 조인(join) 포크 조합기는 하나의 자원을 두가지방법으로 처리후 그 결과를 다시 조합한다. 하나의 조인 함수와 주어진 입력을 처리할 종단함수 2개를 받는다. 함수형 프로그래밍은 불변성, 순수성이 기본 원리이므로 프로그램을 구성하는 함수의 모듈성과 재사용성을 세세하게 조절할 수 있다. 자바스크립트에서는 함수를 이용해서 모듈을 구현할 수 있다고 했는데 마찬가지로 전체 모듈을 합성하고 재사용하는 일도 얼마든지 가능하다 이장에서 배운 기법들로 순수함수를 추상하여 합성 가능한 형태로 만드는 게 목적이다.","link":"/2019/04/25/Programming/JavaScript/study-modular-code-2/"},{"title":"스터디 - 재사용 가능한, 모듈적인 코드로","text":"이번에 정리할 내용은 Chapter 4. 재사용 가능한, 모듈적인 코드로! 이 장의 내용 함수 체인과 함수 파이프라인 비교 함수형 라이브러리 람다JS 소개 커링, 부분 적용, 함수 바인딩 개념 탐구 함수 합성으로 모듈적인 프로그램 제작 함수 조합기로 프로그램의 흐름을 개선 모듈성은 프로그램을 더 작고 독립적인 부분으로 나눌 수 있는 정도를 뜻한다. 모듈적 프로그램modular program은 자신을 구성하는 부속들로부터 자신의 의미를 도출할 수 있다는 점에서 뚜렷이 구분된다. 이들 부속품은 다른 시스템에 그대로 또는 더 쪼개서 통합할 수 있는 재사용 가능한 컴포넌트다. 이러한 코드는 생산성을 높일 뿐만 아니라 코드 유지보수성 및 가독성을 향상시키는데 도움이 된다. 3장에서는 하나의 래퍼 객체를 중심으로 단단히 결합된 메서드 체인으로 문제를 해결했다. 4장에서는 함수 합성을 통해 느슨하게 결합된 파이프라인을 만들고, 보다 유연한 독립적인 컴포넌트를 만들어보자. 이렇게 하려면 먼저 코드를 적정 수준으로 추상해야한다. 이 때 람다JS라는 함수형 프레임워크의 도움을 받아 부분 평가 및 합성 같은 주요 함수형 기법을 어떻게 구사하는지 살펴보자. 메서드 체인 대 함수 파이프라인 3장에서는 메서드 체인으로 함수를 연결했다. 파이프라이닝은 함수를 연결하는 또다른 기법이다. 함수란 입력 형식과 출력 형식 간의 수학적인 매핑을 뜻한다. [참고]함수형 커뮤니티에서는 하스켈 언어 표기법을 많이 쓴다.&lt;function-name&gt; :: &lt;inputs&gt; -&gt; &lt;outputs&gt; 함수 체이닝과 파이프라이닝을 이해하려면 함수를 형식 간의 매핑으로 바라봐야한다. 메서드를 체이닝 (단단한 결합, 제한된 표현성) 함수 파이프라인을 배열 (느슨한 결합, 유연성) 메소드를 여럿 체이닝 map, filter 함수는 배열을 넘겨받아 새 배열을 돌려준다고 했다. _.chain(names) // 뒤에 점(.)을 붙여 로대시JS의 다른 메서드를 호출 .filter(isValid) .map(s =&gt; s.replace(/_/, \" \")) .uniq() .map(_.startCase) .sort() .value() 명령형에 비해 구조적으로도 향상됐고, 가독성도 좋아졌다. 하지만 로대시JS가 제공하는 연산만 쓸 수 있기 때문에 다른 (또는 직접 만든) 라이브러리 함수를 쉽게 연결할 수 없다. 고수준에서 보면 배열 메서드의 순차열은 아래와 같다. 여기서 체인을 끊어버리고 독립적인 함수열을 자유롭게 배열할 수 있으면 좋겠다.(우리가 만든 메서드나 다른 라이브러리의 메서드를 자유롭게 연산 과정에 추가할 수 있으면 좋겠다.) 그래서 함수 파이프라인이 필요한 것이다. 함수를 파이프라인에 나열 함수형 프로그래밍에서는 메서드 체이닝의 한계에서 벗어나, 출신에 관계없이 어떤 함수라도 유연하게 결합할 수 있다. 파이프라인pipeline이란 한 함수의 출력이 다음 함수의 입력이 되게끔 느슨하게 배열한, 방향성directional 함수 순차열이다. 아래는 서로다른 객체형을 다루는 함수를 연결한 파이프라인의 개념도다. 이 장에서는 함수 호출을 위의 그림과 같이 고수준의 간명한 함수 파이프라인으로 배열하는 기법을 연구한다. 체이닝과 파이프라인의 접근방법 차이 체이닝 - 객체 메서드를 통해 함수들을 단단히 결합 파이프라인 - 함수 입출력을 서로 연결지어 느슨하게 결합된 컴포넌트를 만든다. 단, 함수의 항수(인수 개수)와 형식이 호환되지 않으면 연결할 수 없다. 함수 호환 요건 함수형 프로그래밍에서는 파이프라인이 프로그램을 구축하는 유일한 수단! 정의된 문제를 해결하기 위해서는 단계별로 명확하게 정의된 계산을 차례차례 해내가는 과정이 필요하다. 이 계산 단계가 코드에서는 함수로 표현된다. 각 함수는 입력과 출력이 서로 호환돼야 한다. 형식 : 한 함수의 반환 형식과 수신 함수의 인수 형식이 일치해야 한다. 항수 : 수신 함수는 앞 단계 함수가 반환한 값을 처리하기 위해 적어도 하나 이상의 매개변수를 선언해야 한다. 형식이 호환되는 함수 함수 파이프라인을 설계할 때는 한 함수가 반환하는 것과 다른 함수가 받는 것이 반드시 호환되어야 한다. 정적 형식statically typed 언어에서는 형식이 큰 관심사이지만 자바스크립트는 형식이 느슨한 언어라서 그렇지 않다. 어떤 객체가 실제로 특정 형식처럼 작동하면 그 형식은 그냥 그 객체의 형식인 것 덕 타이핑(“오리처럼 걷고 말하는 동물이 있다면 그건 다름아닌 오리다”)이라고 한다. 자바스크립트는 동적 파견dynamic dispatch 체제 덕분에 형식과 무관하게 객체에서 속성과 메서드를 가져올 수 있지만, 함수가 어떤 형식의 값을 기대하는지 알아야 프로그램을 이해하기가 더 쉬워진다. 하스켈 표기법으로 코드에 주석을 붙여 문서화하는 식으로라도 입출력을 명확하게 정의해두면 프로그램을 이해하기가 수월해진다. trim과 normalize로 함수 파이프라인을 수동으로 구성// trim :: String -&gt; Stringconst trim = (str) =&gt; str.replace(/^\\s*|\\s*$/g, '');// normalize :: String -&gt; Stringconst normalize = (str) =&gt; str.replace(/\\-/g, '');normalize(trim(\" 444-444-4444 \")) // '4444444444 형식은 틀림없이 중요한 이슈지만, 자바스크립트에서는 함수가 취하는 인수 개수의 호환 여부가 더 중요하다. 함수와 항수:튜플 항수란 함수가 받는 인수의 개수다. 함수의 길이라고도 한다. 다른 프로그래밍에서는 항수를 당연하게 생각하지만 FP에서는 함수에 선언된 인수의 개수가 많아질 수록 복잡도가 증가하는 경우가 많다. 가령 문자열 인수를 하나만 받는 함수는 서너개 받는 함수보다 훨씬 단순하다고 볼 수 있다. // 인수가 1개인 순수함수는 한가지용도! 즉 단일 책임을 담당하므로 가장 단순한 함수// isValid :: String -&gt; Booleanfunction isValid(str) { ...}//makeAsyncHttp :: String, String, Array -&gt; Booleanfunction makeAsyncHttp(method, url, data) { // 모든 인수를 먼저 계산해야하므로 사용하기 어렵다. ...} 우리의 목표는 함수의 인수를 가능한한 적게 하는 것, 그래야 인수가 많은 함수보다 더 유연하고 다목적으로 활용할 수 있다. 하지만 단항 함수를 얻는 것은 쉽지않다. isValid가 오류 내용까지 메시지 형태로 반환하도록 고치면 isValid :: String -&gt; (Boolean, String)isValid(' 4444-44444-444 ') // (false, '입력값이 너무 길어요!') 그런데 이렇게 두가지 다른 값을 동시에 반환할 수 있을까??? 함수형 언어는 튜플이라는 자료구조를 지원한다. 튜플은 유한 원소를 지닌 정렬된 리스트로, 보통 한 번에 두세 개 값을 묶어 (a, b, c) 와 같이 쓴다. isValid가 검사 결과와 에러 메시지를 함께 묶은 튜플 형태로 결과를 내면 한 개체로 반환할 수 있고, 필요시 그 다음 함수에 건네줄 수 있다. 튜플은 형식이 다른 원소를 한데 묶어 다른 함수에 건네주는 일이 가능한 불변성 자료구조다. 물론 객체 리터럴이나 배열같은 임의의 형식으로 반환하는 방법이 있긴하지만 튜플이 다음 측면에서 더 유리하다. 불변성: 튜플은 한번 만들어지면 나중에 내용을 못 바꿈. 임의 형식의 생성 방지 : 튜플은 전혀 무관한 값을 서로 연관지을 수 있다. 단지 데이터를 묶겠다고 새로운 형식을 정의하고 인스턴스화하는 건 괜스레 데이터 모형을 복잡하게 할 뿐… 이형배열의 생성 방지 : 형식이 다른 원소가 배열에 섞여 있으면 형식을 검사하는 방어코드를 수반하므로 다루기가 까다롭다. 배열은 태생 자체가 동일한 형식의 객체를 담는 구조다. 튜플은 2장에 나왔던 값 객체와 작동방식이 유사. 자바스크립트에서는 튜플 자료형을 처음부터 지원하지 않아서 자신만의 튜플을 구현해서 쓰면 된다. // 4-2 형식화한 튜플자료형const Tuple = function(/* 형식 */) { // Array.prototype.slice.call(arguments)는 arguments.slice(), 즉 주어진 인자들의 배열을 복사한 배열을 얻는 역할 const typeInfo = Array.prototype.slice.call(arguments) // 튜플에 담긴 인수 형식을 읽는다. const _T = function(/* 값 */) { // 내부형 _T는 튜플의 형식과 값이 맞는지 확인 const values = Array.prototype.slice.call(arguments) // 튜플에 저장된 값을 꺼낸다. // null 값 유무를 체크. 함수형 자료형은 null 값이 스며드는 것을 허용해선 안된다. if (values.some(val =&gt; val === null || val === undefined)) { throw new ReferenceError(\"튜플을 null값을 가질 수 없다.\") } // 정의된 형식 개수와 튜플 항수가 일치하는지 체크 if (values.length !== typeInfo.length) { throw new TypeError(\"튜플 항수가 프로토타입과 맞지 않다.\") } // 각 튜플값의 형식이 올바른지 checkType함수로 조사. // 각 튜플의 원소는 ._n(원소 인덱스 n은 1부터 시작)로 참조가능한 튜플속성으로 바꾼다. values.forEach((val, index) =&gt; { this[\"_\" + (index + 1)] = checkType(typeInfo[index])(val) }, this) Object.freeze(this) // 튜플을 불변 인스턴스화한다. // 튜플 값을 전부 꺼내 배열로 만든다. // ES6 해체 할당을 이용하면 튜플 값을 변수로 매핑할 수 있다. _T.prototype.values = () =&gt; { return Object.keys(this).map(k =&gt; this[k], this) } } return _T} 위 코드에서 튜플 객체는 크기가 고정된 불변성 자료구조로, 함수 간 통신에 사용가능한 n개의 이형 값을 담을 수 있다. ES6부터 지원하는 해체할당destructuring assignment과 조합하면 튜플 값을 변수로 깔끔하게 매핑할 수 있다. // StringPair형식const StringPair = Tuple(String, String)const name = (StringPair(\"Barkley\", \"Rosser\")[(first, last)] = name.values())first // Barkleylast // Rosser// 항수가 맞지 않아 에러가 난다.const fullName = StringPair(\"J\", \"Barkley\", \"Rosser\") 튜플로 함수 항수를 줄일 순 있지만, 튜플만으로 만족스럽지 못할 땐 더 나은 방안이 있다. 항수를 추상하는 동시에 모듈성, 재사용성을 높이는 함수 커링이라는 천연 조미료다. 커리된 함수를 평가 커링을 이해하려면 먼저 일반(비커리된) 평가와 커리된 평가의 차이점을 분명히 인지해야 한다. 자바스크립트에서는 비커리된 일반 함수를 호출할 때 인수가 모자라도 별문제없이 실행된다. 이와 달리 모든 매개변수가 명시된 커리된 함수에 일부 인수만 넣어 호출하면, 함수가 실행되는 게 아니라 모자란 나머지 인수가 다 채워지기를 기다리는 새로운 함수가 반환된다. 커링은 다변수 함수가 인수를 전부 받을 때까지 실행을 보류, 또는 지연시켜 단계별로 나뉜 단항 함수의 순차열로 전환하는 기법이다. 매개변수가 3개인 curry함수를 수학적으로 쓰면 다음과 같다. curry(f) :: ((a, b, c) -&gt; d) -&gt; a -&gt; b -&gt; c -&gt; d curry는 (a, b, c)라는 입력을 인수가 하나뿐인 호출로 해체하는 함수 간의 매핑이다. 자바스크립트로는 자동으로 함수를 커리할 수 없으므로 직접 코드 구현해야한다. 먼저 수동으로 커리하는 간단한 예제를 보면 // 두 인수를 수동으로 커리function curry2(fn) { // 처음 curry2 호출시 첫번째인수를 포착 return function(firstArg) { // 두번째호출시 두번째인수를 포착 return function(secondArg) { // 두인수 firstArg, secondArg로 함수를 실행한 결과값을 반환 return fn(firstArg, secondArg) } }} 반환된 함수는 나중에 사용할 인수를 포착하기 위해 함수 래퍼를 중첩한 코드에 불과하다. 커링은 클로저의 또다른 사례라고도 할 수 있다. const name = curry2(last, first) =&gt; new StringPair(last, first)// 두 인수를 모두 넣으면 함수평가가 완료[first, last] = StringPair(\"Barkley\", \"Rosser\").values()first // Barkleylast // Rosser// 하나만 넣으면 나머지 인수를 undefined로 넣고 평가하는게 아니라,// 또다른 함수를 반환name('Curry') // -&gt; Function 4-2에서 사용했던 checkType 함수를 람다JS라는 함수형 라이브러리의 함수를 빌려 구현해보자. 람다JS의 모든 기능은 전역변수 R을 통해 접근가능하다. 람다JS는 커링, 부분 적용, 합성 등의 기법을 구사할 때 매개변수를 간편하게 배열할 수 있기 때문 // checkType :: Type -&gt; Object -&gt; Objectconst checkType = R.curry((typeDef, obj) =&gt; { // R.is()로 형식 정보를 체크 if (!R.is(typeDef, obj)) { let type = typeof obj throw new TypeError(`형식 불일치: [${typeDef}]이어야 하는데, [${type}]이다.`) } return obj})checkType(String)(\"Curry\") // =&gt; 'Curry'checkType(Number)(3) // =&gt; 3checkType(Number)(3.5) // =&gt; 3.5let now = new Date()checkType(Date)(now) // =&gt; nowcheckType(Object)({}) // =&gt; {}checkType(String)(42) // =&gt; TypeError 단순한 작업이야 수동으로 커리할 수 있겠지만 기능이 복잡해지고 인수가 늘어나면 자동으로 처리할 방법이 필요하다. R.curry를 쓰면 인수 개수와 상관없이 순수 함수형 언어의 자동 커링장치를 모방할 수 있다. 자동 커링은 선언된 인수 개수만큼 중첩된 함수 스코프를 인위적으로 생성하는 작업이라고 보면 된다. // fullname을 커리한 코드// fullname :: (String, String) -&gt; Stringconst fullname = function (first, last) { ...}// fullname :: String -&gt; String -&gt; Stringconst fullname = function (first) { return function (last) { ... } } 그렇다면, 커링은 어디에 써먹는 기법일까? 함수 팩토리모방 재사용 가능한 모듈적 함수 템플릿을 구현 함수 팩토리를 모방 객체지향에서 인터페이스는 클래스가 반드시 구현해야할 규약을 정해놓은 추상적인 형식이다. 동일한 인터페이스를 두 클래스가 구현한 예제 DB에서 학생정보 얻어오는 클래스 캐시에서 학생정보 얻어오는 클래스 호출자 관점에서 메서드를 호출한다는 사실이 중요하지, 객체의 출처는 관심없다. 이것이 바로 팩토리 메서드 패턴으로 설계한 객체지향코드의 아름다운 자태다. 자바스크립트로 바꿔보면 //fetchStudentFromDb :: DB -&gt; (String -&gt; Student)const fetchStudentFromDb = R.curry(function(db, ssn) { // 객체 db에서 찾는다. return find(db, ssn)})//fetchStudentFromArray :: Array -&gt; ( String -&gt; Student)const fetchStudentFromArray = R.curry(function(arr, ssn) { // 배열에서 찾는다. return arr[ssn]}) 이 함수는 커리해놔서 일반 팩토리 메서드 findStudent로 평가하는 부분과 함수를 정의한 부분을 떼어놓을 수 있다. 실제 구현부는 둘 중하나 const findStudent = useDb ? fetchStudentFromDb(db) : fetchStudentFromArray(arr)findStudent(\"4444-444-4444\") 이제 다른 모듈의 호출자는 실제 구현부를 알지 못해도 얼마든지 findStudent를 가져다 쓸 수 있다. 재사용 가능한 함수 템플릿 구현 애플리케이션의 상태(에러, 경고, 디버그 등) 별로 로그를 나누어 처리하고 싶은 경우가 있다. 함수 템플릿은 생성 시점에 커리된 인수 개수를 기준으로 연관된 함수들을 묶어놓은 것 console.log보다 기능이 우수한 Log4js를 사용해서 예제를 들어보겠다. // Log4js의 일반적인 사용법const logger = new Log4js.getLogger(\"StudentEvents\")logger.info(\"학생이 정상적으로 추가되었다.\")// 로그를 팝업창에logger.addAppender(new Log4js.JSAlertAppender())// 로그메시지를 일반텍스트 대신 JSON형식으로logger.setLayout(new Log4js.JSONLayout()) 하지만 이렇게 일일이 개별 파일에 코드를 복붙하면 엄청난 중복이 발생…! 재사용이 가능함 함수 템플릿(즉, 로거모듈)을 커링 기법으로 정의하는 편이 유연성, 재사용 측면에서 좋다. // 로거 함수 템플리을 만듦const logger = function(appender, layout, name, level, message) { // 원하는 appender를 정의 const appneders = { alert: new Log4js.JSAlertAppender(), console: new Log4js.BrowserConsoleAppender() } // 원하는 레이아웃 제공기를 정의 const layouts = { basic: new Log4js.BasicLayout(), json: new Log4js.JSONLayout(), xml: new Log4js.XMLLayout() } const appender = appneders[appender] appneder.setLayout(layouts[layout]) const logger = new Log4js.getLogger(name) logger.addAppender(appender) // 구성 매개변수를 모두 적용해서 로그를 남긴다. logger.log(level, message, null)} 로거를 커리하면 상황별로 적합한 로거를 모두 한곳에서 관리하고 재사용할 수 있다. // 마지막 두 인수만 빼고 모두 평가const log = R.curry(logger)(&apos;alert&apos;, &apos;json&apos;, &apos;FJS)log(&apos;ERROR&apos;, &apos;에러가 발생했습니다.&apos;)// =&gt; 팝업창을 띄우고 요청한 메시지를 경고 문구로 표시한다. 여러 에러 처리 구문을 하나의 함수나 파일로 구현하고 싶으면, 유연하게 마지막 매개변수를 제외한 나머지 매개변수를 부분 세팅하면 된다. const logError = R.curry(logger)(\"console\", \"basic\", \"FJS\", \"ERROR\")logError(\"코드 404 에러가 발생했습니다.\") 내부적으로는 이 함수에 curry함수를 연속 호출해서 결국 단항 함수 하나만 남을 것이다. 기존 함수에서 새 함수를 만들고 매개변수는 몇개라도 전달 가능하니 인수가 정해질때마다 단계별로 함수를 쉽게 쌓아 올릴 수 있다. 커링의 가장 중요한 의의는 다인수 함수를 단항 함수로 바꾼다는 것이다. 커링의 대용품인 부분 적용partial application과 매개변수 바인딩parameter binding은 자바스크립트에서도 어느 정도 지원되는 기법으로, 함수 파이프라인에 연결해도 잘 작동할 수 있도록 항수가 더 작은 함수를 만든다. 부분 적용과 매개변수 바인딩 부분 적용은 함수의 일부 매개변수값을 처음부터 고정시켜 항수가 더 작은 함수를 생성하는 기법이다. 커링처럼 부분 적용도 함수의 길이를 직접 줄이는 임무를 수행하지만 방법은 조금 다르다. 커링은 부분호출할 때마다 단항 함수를 중첩생성하며, 내부적으로는 이들을 단계별로 합성하여 최종 결과를 낸다. 커링은 여러 인수를 부분 평가하는 식으로도 변용할 수 있어서 개발자가 평가 시점과 방법을 좌지우지할 수 있다. 부분 적용은 함수 인수를 미리 정의된 값으로 묶은(할당한) 후, 인수가 적은 함수를 새로 만든다. 이 결과 함수는 자신의 클로저에 고정된 매개변수를 갖고 있으며, 후속 호출시 이미 평가를 마친 상태다. // 4-7. partial()구현부function partial() { let fn = this, boundArgs = Array.prototype.slice.call(arguments) // 로대시JS같은 라이브러리의 partial구현부는 언더스코어객체를 자리끼우개로 쓴다. // 대충만들어 쓸 때는 undefined로 해당 매개변수를 건너뛰게 한다. let placeholder = \"&lt;&lt;자리끼우개 객체&gt;&gt;\" // 모든 매개 변수가 부분적용된 새 함수를 생성 let bound = function() { let position = 0, length = boundArgs.length let args = Array(length) for (let i = 0; i &lt; length; i++) { // 자리끼우개 객체는 나중에 호출할 때 쓰려고 함수 매개변수를 정의하지 않고 건너뛰므로, // 어떤 매개변수를 바인딩하고 호출의 일부로 제공할지 개발자가 선택할 수 있다. args[i] = boundArgs[i] === placeholder ? arguments[position++] : boundArgs[i] } while (position &lt; arguments.length) { args.push(arguments[position++]) } // 적절한 콘텍스트와 바인딩된 인수를 Function.apply()에 넣고 함수호출 return fn.apply(this.args) } return bound} 방금전에 봤던 로거함수에 특정 매개변수를 부분 적용하면 더 구체적인 로직을 적용할 수 있다. const consoleLog = _.partial(logger, \"console\", \"json\", \"FJS 부분적용\") 이 함수를 보면서 커링과 부분 적용의 차이점을 다시 한번 보자. 세 매개변수를 부분 적용해서 만든 consoleLog 함수를 호출(단계별로 나뉜 게 아니라 1회성 호출)하려면 다른 두 인수도 필요하다. 따라서 커링처럼 consoleLog함수에 인수를 하나만 준다고 새 함수가 생성되는 게 아니라, 마지막 인수처리에 undefined를 넣고 함수를 평가하게 된다. 커링은 부분 적용을 자동화한 것이다. 커링과 부분 적용은 차이점을 아래와 같이 표현할 수 있다. //커링// 모든 인수가 다 들어올 때까지 함수를 리턴..var curriedFn = function(a) { return function(b) { return function(c) { return a + \", \" + b + \",\" + c + \"는 좋은 친구들입니다.\" } }}//부분 적용// 미리 셋팅된 a 매개변수외에 b, c에 대해서는 커링적용안됨. 없으면 없는대로 undefined로 처리됨var partialAppliedFn = function(a) { return function(b, c) { return a + \", \" + b + \",\" + c + \"는 좋은 친구들입니다.\" }} 부분 적용과 작동 방식은 다르지만, 비슷하게 동작하는 Function.prototype.bind() 함수를 응용한 함수 바인딩 기법도 있다. const log = _.bind(logger, undefined, \"console\", \"json\", \"FJS 바인딩\")log(\"WARN\", \"함수형 프로그래밍, 정말 멋지군!\") _.bind 함수의 두번째 인수는 왜 undefined일까? 바인딩 결과 생성된 함수는 소유 객체 콘텍스트에서 실행되므로 undefined를 넘겨서 전역콘텍스트에 바인딩하라고 런타임에 요청한 것이다. _.partial, _.bind 는 두가지 용도로 쓰인다. 언어의 핵심을 확장 지연된 함수에 바인딩 언어의 핵심을 확장 부분 적용은 String, Number 같은 핵심 자료형을 확장하여 언어의 표현성을 풍부하게 할 목적으로 사용할 수 있다. // 문자열을 배열로 변환// match에 정규표현식을 부분적용해서 주어진 문자열을 특정 데이터가 포함된 배열로 변환// \\w : 영문자 및 _ 문자와 일치String.prototype.explode = _.partial(String.prototype.match, /[\\w]/gi)\"ABC\".explode() // ['A', 'B', 'C'] 지연된 함수에 바인딩 소유 객체를 전제로 메서드를 다룰 때는 함수 바인딩으로 콘텍스트 객체를 세팅하는 일이 중요하다. const Scheduler = (function() { // undefined를 넘겨줘서 전역콘텍스트에서 실행되도록 const delayedFn = _.bind(setTimeout, undefined, _, _) return { delay5: _.partial(delayedFn, _, 5000), delay10: _.partial(delayedFn, _, 10000), delay: _.partial(delayedFn, _, _) }})()Scheculer.delay5(function() { consoleLog(\"5초 후에 실행\")}) 이렇게 스케쥴러만 있으면 함수 본체 안에 감싼 코드를 원하는 시간 이후에 실행시킬 수 있다.","link":"/2019/04/01/Programming/JavaScript/study-modular-code/"},{"title":"리액트 라우터 component vs render 차이","text":"리액트 라우터를 통해 렌더된 컴포넌트에 props를 어떻게 넘길 수 있는지 알아보자. 특정 path와 그 때 렌더할 component를 Route에 넘겨주면 애플리케이션이 특정 path에 오면 그 component가 렌더링이 된다. &lt;Route path=\"/dashboard\" component=\"{Dashboard}\" /&gt; 만약, Dashboard에 props를 넘겨주고 싶으면? 단순히 Route에 props를 하나 추가하면 안 된다. 리액트라우터는 이 props를 컴포넌트에 전달하지 않는다. &lt;Route path=\"/dashboard\" component=\"{Dashboard}\" isAuthed=\"{true}\" /&gt; 안됨 다른 방법으로는 아래와 같이 component에 dashboard를 리턴하는 inline function을 만드는 것을 생각할 수 있다. &lt;Route path=\"/dashboard\" component={() =&gt; &lt;Dashboard isAuthed=\"{true}\" /&gt;} /&gt; 위 방법은 동작은 하지만, 성능상 좋은 해결책이 아니다. 공식문서에 따르면, “When you use the component props, the router uses React.createElement to create a new React element from the given component. That means if you provide an inline function to the component attribute,_ you would create a new component every render._ This results in the existing component unmounting and the new component mounting instead of just updating the existing component.” 이미 존재하는 컴포넌트를 재활용하는게 아니라, 해당 컴포넌트를 렌더링할 때마다 언마운트 후 새로운 컴포넌트를 마운팅하는 거라 component에 function을 넘기는 것을 추천하지 않는다. 리액트라우터팀은 간단한 해결책을 제공했다. prop으로 component를 쓰는 대신, render을 쓰는 것이다. render는 functional component를 허용한다. 그리고 render를 사용하면 불필요하게 컴포넌트가 재마운트되지 않는다. &lt;Route path=\"/dashboard\" render={props =&gt; &lt;Dashboard {...props} isAuthed=\"{true}\" /&gt;} /&gt; 요약해보면, 만약 리액트라우터를 통해 렌더링되는 컴포넌트에 props를 넘기고 싶다면, Route의 component prop을 이용하는 것 대신에, render prop을 사용하면 된다. render를 사용하면 컴포넌트가 불필요하게 다시 마운트되지 않고, inline function에서 리턴하는 컴포넌트에 넘기는 props들을 제대로 전달한다. [참고] https://tylermcginnis.com/react-router-pass-props-to-components/","link":"/2019/12/04/Programming/React/react-router-component-vs-render/"}],"tags":[{"name":"1일1알고리즘풀이","slug":"1일1알고리즘풀이","link":"/tags/1일1알고리즘풀이/"},{"name":"Angular","slug":"Angular","link":"/tags/Angular/"},{"name":"Component","slug":"Component","link":"/tags/Component/"},{"name":"ObjectUnsubscribedError","slug":"ObjectUnsubscribedError","link":"/tags/ObjectUnsubscribedError/"},{"name":"architecture","slug":"architecture","link":"/tags/architecture/"},{"name":"Directive","slug":"Directive","link":"/tags/Directive/"},{"name":"Custom Directive","slug":"Custom-Directive","link":"/tags/Custom-Directive/"},{"name":"click outside","slug":"click-outside","link":"/tags/click-outside/"},{"name":"formgroup","slug":"formgroup","link":"/tags/formgroup/"},{"name":"Forms","slug":"Forms","link":"/tags/Forms/"},{"name":"injector","slug":"injector","link":"/tags/injector/"},{"name":"injector-tree","slug":"injector-tree","link":"/tags/injector-tree/"},{"name":"이진탐색","slug":"이진탐색","link":"/tags/이진탐색/"},{"name":"binary-search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"알고리즘","slug":"알고리즘","link":"/tags/알고리즘/"},{"name":"빅오 표기법","slug":"빅오-표기법","link":"/tags/빅오-표기법/"},{"name":"Big-O","slug":"Big-O","link":"/tags/Big-O/"},{"name":"ngrx","slug":"ngrx","link":"/tags/ngrx/"},{"name":"너비우선탐색","slug":"너비우선탐색","link":"/tags/너비우선탐색/"},{"name":"breadth-first-search","slug":"breadth-first-search","link":"/tags/breadth-first-search/"},{"name":"contructor","slug":"contructor","link":"/tags/contructor/"},{"name":"ngOninit","slug":"ngOninit","link":"/tags/ngOninit/"},{"name":"clipboard.js","slug":"clipboard-js","link":"/tags/clipboard-js/"},{"name":"크로스 도메인","slug":"크로스-도메인","link":"/tags/크로스-도메인/"},{"name":"CORS","slug":"CORS","link":"/tags/CORS/"},{"name":"SOP","slug":"SOP","link":"/tags/SOP/"},{"name":"for문","slug":"for문","link":"/tags/for문/"},{"name":"foreach문","slug":"foreach문","link":"/tags/foreach문/"},{"name":"for~in문","slug":"for-in문","link":"/tags/for-in문/"},{"name":"for~of문","slug":"for-of문","link":"/tags/for-of문/"},{"name":"엑셀","slug":"엑셀","link":"/tags/엑셀/"},{"name":"csv","slug":"csv","link":"/tags/csv/"},{"name":"else if","slug":"else-if","link":"/tags/else-if/"},{"name":"switch","slug":"switch","link":"/tags/switch/"},{"name":"다익스트라알고리즘","slug":"다익스트라알고리즘","link":"/tags/다익스트라알고리즘/"},{"name":"dijkstra-algorithm","slug":"dijkstra-algorithm","link":"/tags/dijkstra-algorithm/"},{"name":"해시테이블","slug":"해시테이블","link":"/tags/해시테이블/"},{"name":"hashtable","slug":"hashtable","link":"/tags/hashtable/"},{"name":"탐욕알고리즘","slug":"탐욕알고리즘","link":"/tags/탐욕알고리즘/"},{"name":"greedy-algorithm","slug":"greedy-algorithm","link":"/tags/greedy-algorithm/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"json import","slug":"json-import","link":"/tags/json-import/"},{"name":"image-path","slug":"image-path","link":"/tags/image-path/"},{"name":"MSBUILD","slug":"MSBUILD","link":"/tags/MSBUILD/"},{"name":"MSB3428","slug":"MSB3428","link":"/tags/MSB3428/"},{"name":"npm install error","slug":"npm-install-error","link":"/tags/npm-install-error/"},{"name":"interface","slug":"interface","link":"/tags/interface/"},{"name":"class","slug":"class","link":"/tags/class/"},{"name":"재귀","slug":"재귀","link":"/tags/재귀/"},{"name":"recursion","slug":"recursion","link":"/tags/recursion/"},{"name":"Routing","slug":"Routing","link":"/tags/Routing/"},{"name":"Router","slug":"Router","link":"/tags/Router/"},{"name":"매개변수","slug":"매개변수","link":"/tags/매개변수/"},{"name":"인수","slug":"인수","link":"/tags/인수/"},{"name":"parameter","slug":"parameter","link":"/tags/parameter/"},{"name":"argument","slug":"argument","link":"/tags/argument/"},{"name":"퀵정렬","slug":"퀵정렬","link":"/tags/퀵정렬/"},{"name":"quicksort","slug":"quicksort","link":"/tags/quicksort/"},{"name":"선택 정렬","slug":"선택-정렬","link":"/tags/선택-정렬/"},{"name":"selection-sort","slug":"selection-sort","link":"/tags/selection-sort/"},{"name":"GoogleAnayltics","slug":"GoogleAnayltics","link":"/tags/GoogleAnayltics/"},{"name":"SPA","slug":"SPA","link":"/tags/SPA/"},{"name":"안드로이드","slug":"안드로이드","link":"/tags/안드로이드/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"InflateException","slug":"InflateException","link":"/tags/InflateException/"},{"name":"BinarySearchTree","slug":"BinarySearchTree","link":"/tags/BinarySearchTree/"},{"name":"build.gradle","slug":"build-gradle","link":"/tags/build-gradle/"},{"name":"안드로이드 그래들","slug":"안드로이드-그래들","link":"/tags/안드로이드-그래들/"},{"name":"HashTable","slug":"HashTable","link":"/tags/HashTable/"},{"name":"java","slug":"java","link":"/tags/java/"},{"name":"LinkedList","slug":"LinkedList","link":"/tags/LinkedList/"},{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"화살표 함수","slug":"화살표-함수","link":"/tags/화살표-함수/"},{"name":"arrow-function","slug":"arrow-function","link":"/tags/arrow-function/"},{"name":"function","slug":"function","link":"/tags/function/"},{"name":"this","slug":"this","link":"/tags/this/"},{"name":"NodeJS","slug":"NodeJS","link":"/tags/NodeJS/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"material-ui","slug":"material-ui","link":"/tags/material-ui/"},{"name":"함수형 자바스크립트","slug":"함수형-자바스크립트","link":"/tags/함수형-자바스크립트/"},{"name":"고계 자바스크립트","slug":"고계-자바스크립트","link":"/tags/고계-자바스크립트/"},{"name":"재사용 가능한, 모듈적인 코드로","slug":"재사용-가능한-모듈적인-코드로","link":"/tags/재사용-가능한-모듈적인-코드로/"},{"name":"react-router","slug":"react-router","link":"/tags/react-router/"}],"categories":[{"name":"Programming","slug":"Programming","link":"/categories/Programming/"},{"name":"Angular","slug":"Programming/Angular","link":"/categories/Programming/Angular/"},{"name":"Algorithm","slug":"Programming/Algorithm","link":"/categories/Programming/Algorithm/"},{"name":"JavaScript","slug":"Programming/JavaScript","link":"/categories/Programming/JavaScript/"},{"name":"Basic","slug":"Programming/Basic","link":"/categories/Programming/Basic/"},{"name":"etc","slug":"Programming/etc","link":"/categories/Programming/etc/"},{"name":"Essay","slug":"Essay","link":"/categories/Essay/"},{"name":"이직일기","slug":"Essay/이직일기","link":"/categories/Essay/이직일기/"},{"name":"Android","slug":"Programming/Android","link":"/categories/Programming/Android/"},{"name":"ElasticSearch","slug":"Programming/ElasticSearch","link":"/categories/Programming/ElasticSearch/"},{"name":"React","slug":"Programming/React","link":"/categories/Programming/React/"}]}